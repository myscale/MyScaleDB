#!/usr/bin/env python3
import logging
import os.path as p
from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter, ArgumentTypeError
import time
from typing import Any, Dict, List, Literal, Optional, Tuple, Union
import subprocess

CWD = p.dirname(p.realpath(__file__))

FILE_WITH_VERSION_PATH = "../cmake/autogenerated_myscale_versions.txt"
CHANGELOG_IN_PATH = "debian/changelog.in"
CHANGELOG_PATH = "debian/changelog"

VERSIONS = Dict[str, Union[int, str]]

VERSIONS_TEMPLATE="""# This variables autochanged by scripts/myscale_version_helper.py:

# NOTE: has nothing common with DBMS_TCP_PROTOCOL_VERSION,
# only DBMS_TCP_PROTOCOL_VERSION should be incremented on protocol changes.
SET(MYSCALE_VERSION_MAJOR {major})
SET(MYSCALE_VERSION_MINOR {minor})
SET(MYSCALE_VERSION_PATCH {patch})
SET(MYSCALE_VERSION_DESCRIBE {describe})
SET(MYSCALE_VERSION_STRING {string})
# end of autochange

"""
def removeprefix(string: str, prefix: str) -> str:
    if string.startswith(prefix):
        return string[len(prefix) :]  # noqa: ignore E203, false positive
    return string


def removesuffix(string: str, suffix: str) -> str:
    if string.endswith(suffix):
        return string[: -len(suffix)]
    return string

class VersionType:
    ALPHA = "alpha"
    BETA = "beta"
    TESTING = "testing"
    VALID = (ALPHA, BETA, TESTING)

class Runner:
    """lightweight check_output wrapper with stripping last NEW_LINE"""

    def __init__(self, cwd: str = CWD):
        self._cwd = cwd

    def run(self, cmd: str, cwd: Optional[str] = None, **kwargs: Any) -> str:
        if cwd is None:
            cwd = self.cwd
        print("Running command: %s", cmd)
        output = str(subprocess.check_output(cmd, shell=True, cwd=cwd, encoding="utf-8", **kwargs).strip())
        return output

    @property
    def cwd(self) -> str:
        return self._cwd

    @cwd.setter
    def cwd(self, value: str) -> None:
        # Set _cwd only once, then set it to readonly
        if self._cwd != CWD:
            return
        self._cwd = value

    def __call__(self, *args, **kwargs):
        return self.run(*args, **kwargs)

git_runner = Runner()


def local_behind_git(local: Tuple[int, int, int], git: Tuple[int, int, int]):
    # 判断 local 记录的版本是否落后于 git 上最新的版本
    for i in range(0, 3):
        if local[i] < git[i]:
            return True
        elif local[i] > git[i]:
            return False

    return False
class MyScaleVersion:
    """Immutable version class. On update returns a new instance"""

    def __init__(
        self,
        major: Union[int, str],
        minor: Union[int, str],
        patch: Union[int, str],
        with_git: bool = True,
    ):
        self._major = int(major)
        self._minor = int(minor)
        self._patch = int(patch)
        self._with_git = with_git
        self._version_with_type = ""
        self._version_type = ""
    
    def update_version_from_git(self):
        # 在对本地文件存储的 version 进行操作前进行判断，若本地 version 落后于 git 的 version，则先将本地 version 保持和 git 一致
        git_tag = git_runner.run("git tag --sort=-creatordate | grep '^myscale' | head -n 1").split('-')[1]
        git_tag_parts = removeprefix(string=git_tag, prefix="v").split('.')
        if(local_behind_git(local=(self._major, self._minor, self._patch), 
                            git=(int(git_tag_parts[0]), int(git_tag_parts[1]), int(git_tag_parts[2])))):
            print(f"Caution🌵: local version{(self._major, self._minor, self._patch)} behind"
                    f" git version({git_tag}), your version update will base on {git_tag}")
            self._major=int(git_tag_parts[0])
            self._minor=int(git_tag_parts[1])
            self._patch=int(git_tag_parts[2])

    def update(self, part: Literal["major", "minor", "patch"]) -> "MyScaleVersion":
        """If part is valid, returns a new version"""
        if part == "major":
            return self.major_update()
        if part == "minor":
            return self.minor_update()
        if part == "patch":
            return self.patch_update()
        raise KeyError(f"wrong part {part} is used")

    def major_update(self) -> "MyScaleVersion":
        if self._with_git:
            self.update_version_from_git()
        return MyScaleVersion(self.major + 1, 0, 0, self._with_git)

    def minor_update(self) -> "MyScaleVersion":
        if self._with_git:
            self.update_version_from_git()
        return MyScaleVersion(self.major, self.minor + 1, 0, self._with_git)

    def patch_update(self) -> "MyScaleVersion":
        if self._with_git:
            self.update_version_from_git()
        return MyScaleVersion(self.major, self.minor, self.patch + 1, self._with_git)


    @property
    def major(self) -> int:
        return self._major

    @property
    def minor(self) -> int:
        return self._minor

    @property
    def patch(self) -> int:
        return self._patch

    @property
    def version_with_type(self):
        if self._version_type:
            return f"myscale-v{self.string}-{self._version_type}"
        return f"myscale-v{self.string}"

    @property
    def version_type(self) -> str:
        return self._version_type

    @property
    def string(self):
        return ".".join((str(self.major), str(self.minor), str(self.patch)))

    def as_dict(self) -> VERSIONS:
        return {
            "major": self.major,
            "minor": self.minor,
            "patch": self.patch,
            "describe": self.version_with_type,
            "string": self.string,
        }

    def as_tuple(self) -> Tuple[int, int, int]:
        return (self.major, self.minor, self.patch)

    def with_version_type(self, version_type):
        if version_type not in VersionType.VALID and not version_type.startswith("rc"):
            raise ValueError(f"version type {version_type} not in {VersionType.VALID}, and not starts with rc")
        self._version_type = version_type
        # self._version_with_type = f"myscale-v{self.string}-{version_type}"


###

def validate_version(version: str) -> None:
    parts = version.split(".")
    if len(parts) != 3:
        raise ValueError(f"{version} does not match 3 parts")
    for part in parts:
        int(part)


def get_abs_path(path: str) -> str:
    return p.abspath(p.join(git_runner.cwd, path))


def read_versions_from_file(versions_path: str = FILE_WITH_VERSION_PATH) -> VERSIONS:
    versions = {}
    path_to_file = get_abs_path(versions_path)
    with open(path_to_file, "r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line.startswith("SET("):
                continue

            value = 0  # type: Union[int, str]
            # 取出 SET() 内的 name 和 value
            name, value = line[4:-1].split(maxsplit=1)
            name = removeprefix(name, "MYSCALE_VERSION_").lower()  # major / minor / patch ...
            try:
                value = int(value)
            except ValueError:
                pass
            versions[name] = value

    return versions


def get_version_from_repo(versions_path: str = FILE_WITH_VERSION_PATH) -> MyScaleVersion:
    versions = read_versions_from_file(versions_path)
    return MyScaleVersion(
        versions["major"],
        versions["minor"],
        versions["patch"],
        with_git=True
    )


def get_version_from_string(version: str, with_git: bool=True) -> MyScaleVersion:
    validate_version(version)
    parts = version.split(".")
    return MyScaleVersion(parts[0], parts[1], parts[2], with_git)

def update_cmake_version(version: MyScaleVersion, versions_path: str = FILE_WITH_VERSION_PATH) -> None:
    path_to_file = get_abs_path(versions_path)
    print(f"new version has been generated: {version.as_dict()}")
    with open(path_to_file, "w", encoding="utf-8") as f:
        f.write(VERSIONS_TEMPLATE.format_map(version.as_dict()))

 


def main():
    """The simplest thing it does - reads versions from cmake and produce the
    environment variables that may be sourced in bash scripts"""
    parser = ArgumentParser(
        formatter_class=ArgumentDefaultsHelpFormatter,
        description="The script reads versions from cmake and produce ENV variables",
    )
    parser.add_argument(
        "--version-path",
        "-p",
        default=FILE_WITH_VERSION_PATH,
        help="relative path to the cmake file with versions",
    )
    parser.add_argument(
        "--version-type",
        "-t",
        # choices=VersionType.VALID,
        help="optional parameter to generate DESCRIBE",
    )
    parser.add_argument(
        "--export",
        "-e",
        action="store_true",
        help="if the ENV variables should be exported",
    )
    parser.add_argument(
        "--update",
        "-u",
        choices=("major", "minor", "patch"),
        help="the version part to update",
    )
    args = parser.parse_args()

    version = get_version_from_repo(args.version_path)

    if args.update:
        version = version.update(args.update)

    if args.version_type:
        version.with_version_type(args.version_type)

    if args.update or args.version_type:
        update_cmake_version(version)

    for k, v in version.as_dict().items():
        name = f"MYSCALE_VERSION_{k.upper()}"
        print(f"{name}='{v}'")
        if args.export:
            print(f"export {name}")


if __name__ == "__main__":
    main()
