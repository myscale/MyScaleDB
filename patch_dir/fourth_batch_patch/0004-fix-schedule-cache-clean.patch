From bedc49cad2c5ba795ac43adf385710b74971fab2 Mon Sep 17 00:00:00 2001
From: Zhenjia Li <zhenjial@moqi.ai>
Date: Thu, 27 Apr 2023 20:44:57 +0800
Subject: [PATCH 04/49] fix schedule cache clean

---
 src/Storages/MergeTree/MergeTreeData.cpp      | 79 +++++++++++++++++--
 src/Storages/MergeTree/MergeTreeData.h        |  7 +-
 .../MergeTreeVectorIndexBuilderUpdater.cpp    | 35 +++-----
 3 files changed, 89 insertions(+), 32 deletions(-)

diff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp
index d04e98f47c..353772c9e1 100644
--- a/src/Storages/MergeTree/MergeTreeData.cpp
+++ b/src/Storages/MergeTree/MergeTreeData.cpp
@@ -92,7 +92,6 @@
 
 #include <VectorIndex/DiskIOReader.h>
 #include <VectorIndex/MergeUtils.h>
-#include <VectorIndex/VectorIndexCommon.h>
 #include <VectorIndex/VectorSegmentExecutor.h>
 
 namespace fs = std::filesystem;
@@ -1790,24 +1789,89 @@ size_t MergeTreeData::clearOldPartsFromFilesystem(bool force)
     return parts_to_remove.size();
 }
 
-void MergeTreeData::clearCachedVectorIndex(const DataPartsVector & parts)
+void MergeTreeData::clearCachedVectorIndex(const DataPartsVector & parts, bool force)
 {
     StorageMetadataPtr meta_snapshot = getInMemoryMetadataPtr();
-    if(meta_snapshot->getVectorIndices().empty())
+    if (meta_snapshot->getVectorIndices().empty())
         return;
 
-/// TODO: how to remove old parts' caches
     for (const auto & part : parts)
     {
-        for(const auto & vec_index_desc : meta_snapshot->vec_indices)
+        for (const auto & vec_index_desc : meta_snapshot->vec_indices)
         {
             auto segment_ids = VectorIndex::getAllSegmentIds(part->getFullPath(), part, vec_index_desc.name, vec_index_desc.column);
             for (auto & segment_id : segment_ids)
-                VectorIndex::VectorSegmentExecutor::removeFromCache(segment_id.getCacheKey());
+            {
+                auto cache_key = segment_id.getCacheKey();
+
+                if (force)
+                {
+                    VectorIndex::VectorSegmentExecutor::removeFromCache(cache_key);
+                }
+                else
+                {
+                    /// Try to remove old parts' caches.
+                    LOG_DEBUG(log, "Try to remove old part' cache, part name: {}.", part->info.getPartName());
+
+                    bool can_do_clear = false;
+                    {
+                        auto lock = tryLockParts();
+                        if (lock.owns_lock() == true)
+                            can_do_clear = true;
+                    }
+
+                    if (can_do_clear)
+                    {
+                        auto active_part = getActiveContainingPart(cache_key.part_name_no_mutation);
+                        auto [clear_cache, _] = needClearVectorIndexCacheAndFile(active_part, meta_snapshot, cache_key);
+                        if (clear_cache)
+                            VectorIndex::VectorSegmentExecutor::removeFromCache(cache_key);
+                    }
+                }
+            }
         }
     }
 }
 
+std::pair<bool, bool> MergeTreeData::needClearVectorIndexCacheAndFile(
+    const DataPartPtr & part, const StorageMetadataPtr & metadata_snapshot, const VectorIndex::CacheKey & cache_key) const
+{
+    if (!part)
+    {
+        return std::make_pair(true, false);
+    }
+
+    bool existed = false;
+    auto old_part_info = MergeTreePartInfo::fromPartName(cache_key.part_name_no_mutation, format_version);
+    bool is_same = part->info == old_part_info;
+    bool is_mutate = !is_same && part->info.getPartNameWithoutMutation() == cache_key.part_name_no_mutation;
+
+    /// Check vector index in cache is same as metadata
+    if (!metadata_snapshot->vec_indices.empty())
+    {
+        /// Currently only one vector index is allowed.
+        const auto & vec_index_desc = metadata_snapshot->vec_indices[0];
+
+        LOG_DEBUG(
+            log,
+            "Cache: {} {}, metadata: {} {}",
+            cache_key.vector_index_name,
+            cache_key.column_name,
+            vec_index_desc.name,
+            vec_index_desc.column);
+
+        /// Further check the part status, decouple part or VPart with single vector index
+        if (cache_key.vector_index_name == vec_index_desc.name && cache_key.column_name == vec_index_desc.column
+            && ((is_same && part->containVectorIndex(cache_key.vector_index_name, cache_key.column_name))
+                || (!is_same && (part->containRowIdsMaps() || is_mutate))))
+        {
+            existed = true;
+        }
+    }
+
+    return std::make_pair(!existed, is_same);
+}
+
 void MergeTreeData::clearPrimaryKeyCache(const DataPartsVector & parts)
 {
     if (!getSettings()->enable_primary_key_cache)
@@ -1845,9 +1909,8 @@ void MergeTreeData::regularClearCachedIndex(const DataPartsVector & /* parts */)
 
 void MergeTreeData::clearPartsFromFilesystem(const DataPartsVector & parts_to_remove)
 {
-    /// The old part's vector index is reused by new part, no need to clear cache.
-    /// clearCachedVectorIndex(parts_to_remove);
     clearPrimaryKeyCache(parts_to_remove);
+    clearCachedVectorIndex(parts_to_remove, false);
 
     const auto settings = getSettings();
     if (parts_to_remove.size() > 1 && settings->max_part_removal_threads > 1 && parts_to_remove.size() > settings->concurrent_part_removal_threshold)
diff --git a/src/Storages/MergeTree/MergeTreeData.h b/src/Storages/MergeTree/MergeTreeData.h
index 8baf355bd3..bfa342947b 100644
--- a/src/Storages/MergeTree/MergeTreeData.h
+++ b/src/Storages/MergeTree/MergeTreeData.h
@@ -32,6 +32,7 @@
 #include <Storages/PartitionCommands.h>
 #include <Interpreters/PartLog.h>
 #include <Disks/StoragePolicy.h>
+#include <VectorIndex/SegmentId.h>
 
 
 #include <boost/multi_index_container.hpp>
@@ -224,6 +225,7 @@ public:
 
     using DataPartsLock = std::unique_lock<std::mutex>;
     DataPartsLock lockParts() const { return DataPartsLock(data_parts_mutex); }
+    DataPartsLock tryLockParts() const { return DataPartsLock(data_parts_mutex, std::try_to_lock); }
 
     MergeTreeDataPartType choosePartType(size_t bytes_uncompressed, size_t rows_count) const;
     MergeTreeDataPartType choosePartTypeOnDisk(size_t bytes_uncompressed, size_t rows_count) const;
@@ -608,8 +610,11 @@ public:
     /// If 'force' - don't wait for old_parts_lifetime.
     size_t clearOldPartsFromFilesystem(bool force = false);
     void clearPartsFromFilesystem(const DataPartsVector & parts);
-    void clearCachedVectorIndex(const DataPartsVector & parts);
+    void clearCachedVectorIndex(const DataPartsVector & parts, bool force = true);
     void clearPrimaryKeyCache(const DataPartsVector & parts);
+    /// Check whether the cache and vector index file need to be deleted according to the part to which the cache belongs.
+    std::pair<bool, bool> needClearVectorIndexCacheAndFile(
+        const DataPartPtr & part, const StorageMetadataPtr & metadata_snapshot, const VectorIndex::CacheKey & cache_key) const;
 
     ///this one checks cached vector index list every 10s and drop all that's removed in metadata.
     void regularClearCachedIndex(const DataPartsVector & parts);
diff --git a/src/Storages/MergeTree/MergeTreeVectorIndexBuilderUpdater.cpp b/src/Storages/MergeTree/MergeTreeVectorIndexBuilderUpdater.cpp
index 151458c459..45ce57d005 100644
--- a/src/Storages/MergeTree/MergeTreeVectorIndexBuilderUpdater.cpp
+++ b/src/Storages/MergeTree/MergeTreeVectorIndexBuilderUpdater.cpp
@@ -78,8 +78,6 @@ void MergeTreeVectorIndexBuilderUpdater::removeDroppedVectorIndices(const Storag
     std::string relative_data_path = fs::path(data.getRelativeDataPath()).parent_path().string();
     for (const auto & cache_item : cached_item_list)
     {
-        bool existed = false;
-
         /// not this table
         if (cache_item.first.table_path.find(relative_data_path) == std::string::npos)
             continue;
@@ -87,37 +85,28 @@ void MergeTreeVectorIndexBuilderUpdater::removeDroppedVectorIndices(const Storag
         const auto cache_key = cache_item.first;
 
         /// Need to check part no matter exists or not exists.
-        MergeTreeDataPartPtr part = data.getActiveContainingPart(cache_item.first.part_name_no_mutation);
+        MergeTreeDataPartPtr part = data.getActiveContainingPart(cache_key.part_name_no_mutation);
+        auto [clear_cache, clear_file] = data.needClearVectorIndexCacheAndFile(part, metadata_snapshot, cache_key);
 
-        /// Check vector index in cache is same as metadata
-        if (!metadata_snapshot->vec_indices.empty())
+        if (!clear_cache)
         {
-            /// Currently only one vector index is allowed.
-            const auto & vec_index_desc = metadata_snapshot->vec_indices[0];
-
-            LOG_DEBUG(log, "Cache: {} {}, metadata: {} {}", cache_item.first.vector_index_name, cache_item.first.column_name, vec_index_desc.name, vec_index_desc.column);
-
-            /// Further check the part status, decouple part or VPart with single vector index
-            if (cache_item.first.vector_index_name == vec_index_desc.name && cache_item.first.column_name == vec_index_desc.column &&
-                (part && (part->containVectorIndex(cache_item.first.vector_index_name, cache_item.first.column_name) || part->containRowIdsMaps())))
-            {
-                LOG_DEBUG(log, "Find Vector Index in metadata");
-                Search::Parameters params = cache_item.second;
+            LOG_DEBUG(log, "Find Vector Index in metadata");
+            Search::Parameters params = cache_item.second;
 
-                LOG_DEBUG(log, "Params: {}, desc params: {}", VectorIndex::ParametersToString(params),
-                    VectorIndex::ParametersToString(VectorIndex::convertPocoJsonToMap(vec_index_desc.parameters)));
-
-                existed = true;
-            }
+            LOG_DEBUG(
+                log,
+                "Params: {}, desc params: {}",
+                VectorIndex::ParametersToString(params),
+                VectorIndex::ParametersToString(VectorIndex::convertPocoJsonToMap(metadata_snapshot->vec_indices[0].parameters)));
         }
 
-        if (!existed)
+        if (clear_cache)
         {
             LOG_DEBUG(log, "Find not existed cache, remove it: {}", cache_key.toString());
             VectorIndex::VectorSegmentExecutor::removeFromCache(cache_key);
 
             /// Clear vector files in active part
-            if (part)
+            if (part && clear_file)
             {
                 if (part->containVectorIndex(cache_key.vector_index_name, cache_key.column_name))
                 {
-- 
2.32.1 (Apple Git-133)

