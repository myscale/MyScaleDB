From 044eca46a776580cf6ccc4431c1515bc8e9da3e6 Mon Sep 17 00:00:00 2001
From: Mochi Xu <mochix@moqi.ai>
Date: Fri, 19 May 2023 15:49:14 +0000
Subject: [PATCH 21/49] Add MyScale version for system.build_options

---
 cmake/autogenerated_myscale_versions.txt      |  11 +
 cmake/version.cmake                           |   1 +
 scripts/myscale_version_helper.py             | 297 ++++++++++++++++++
 ...StorageSystemBuildOptions.generated.cpp.in |   1 +
 4 files changed, 310 insertions(+)
 create mode 100644 cmake/autogenerated_myscale_versions.txt
 create mode 100644 scripts/myscale_version_helper.py

diff --git a/cmake/autogenerated_myscale_versions.txt b/cmake/autogenerated_myscale_versions.txt
new file mode 100644
index 0000000000..84d7b2c10a
--- /dev/null
+++ b/cmake/autogenerated_myscale_versions.txt
@@ -0,0 +1,11 @@
+# This variables autochanged by scripts/myscale_version_helper.py:
+
+# NOTE: has nothing common with DBMS_TCP_PROTOCOL_VERSION,
+# only DBMS_TCP_PROTOCOL_VERSION should be incremented on protocol changes.
+SET(MYSCALE_VERSION_MAJOR 0)
+SET(MYSCALE_VERSION_MINOR 9)
+SET(MYSCALE_VERSION_PATCH 2)
+SET(MYSCALE_VERSION_DESCRIBE myscale-v0.9.2-testing)
+SET(MYSCALE_VERSION_STRING 0.9.2)
+# end of autochange
+
diff --git a/cmake/version.cmake b/cmake/version.cmake
index acaa772ff2..f7e6982718 100644
--- a/cmake/version.cmake
+++ b/cmake/version.cmake
@@ -1,4 +1,5 @@
 include(${CMAKE_SOURCE_DIR}/cmake/autogenerated_versions.txt)
+include(${CMAKE_SOURCE_DIR}/cmake/autogenerated_myscale_versions.txt)
 
 set(VERSION_EXTRA "" CACHE STRING "")
 set(VERSION_TWEAK "" CACHE STRING "")
diff --git a/scripts/myscale_version_helper.py b/scripts/myscale_version_helper.py
new file mode 100644
index 0000000000..9cfeb417f4
--- /dev/null
+++ b/scripts/myscale_version_helper.py
@@ -0,0 +1,297 @@
+#!/usr/bin/env python3
+import logging
+import os.path as p
+from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter, ArgumentTypeError
+import time
+from typing import Any, Dict, List, Literal, Optional, Tuple, Union
+import subprocess
+
+CWD = p.dirname(p.realpath(__file__))
+
+FILE_WITH_VERSION_PATH = "../cmake/autogenerated_myscale_versions.txt"
+CHANGELOG_IN_PATH = "debian/changelog.in"
+CHANGELOG_PATH = "debian/changelog"
+
+VERSIONS = Dict[str, Union[int, str]]
+
+VERSIONS_TEMPLATE="""# This variables autochanged by scripts/myscale_version_helper.py:
+
+# NOTE: has nothing common with DBMS_TCP_PROTOCOL_VERSION,
+# only DBMS_TCP_PROTOCOL_VERSION should be incremented on protocol changes.
+SET(MYSCALE_VERSION_MAJOR {major})
+SET(MYSCALE_VERSION_MINOR {minor})
+SET(MYSCALE_VERSION_PATCH {patch})
+SET(MYSCALE_VERSION_DESCRIBE {describe})
+SET(MYSCALE_VERSION_STRING {string})
+# end of autochange
+
+"""
+def removeprefix(string: str, prefix: str) -> str:
+    if string.startswith(prefix):
+        return string[len(prefix) :]  # noqa: ignore E203, false positive
+    return string
+
+
+def removesuffix(string: str, suffix: str) -> str:
+    if string.endswith(suffix):
+        return string[: -len(suffix)]
+    return string
+
+class VersionType:
+    ALPHA = "alpha"
+    BETA = "beta"
+    TESTING = "testing"
+    VALID = (ALPHA, BETA, TESTING)
+
+class Runner:
+    """lightweight check_output wrapper with stripping last NEW_LINE"""
+
+    def __init__(self, cwd: str = CWD):
+        self._cwd = cwd
+
+    def run(self, cmd: str, cwd: Optional[str] = None, **kwargs: Any) -> str:
+        if cwd is None:
+            cwd = self.cwd
+        print("Running command: %s", cmd)
+        output = str(subprocess.check_output(cmd, shell=True, cwd=cwd, encoding="utf-8", **kwargs).strip())
+        return output
+
+    @property
+    def cwd(self) -> str:
+        return self._cwd
+
+    @cwd.setter
+    def cwd(self, value: str) -> None:
+        # Set _cwd only once, then set it to readonly
+        if self._cwd != CWD:
+            return
+        self._cwd = value
+
+    def __call__(self, *args, **kwargs):
+        return self.run(*args, **kwargs)
+
+git_runner = Runner()
+
+
+def local_behind_git(local: Tuple[int, int, int], git: Tuple[int, int, int]):
+    # Âà§Êñ≠ local ËÆ∞ÂΩïÁöÑÁâàÊú¨ÊòØÂê¶ËêΩÂêé‰∫é git ‰∏äÊúÄÊñ∞ÁöÑÁâàÊú¨
+    for i in range(0, 3):
+        if local[i] < git[i]:
+            return True
+        elif local[i] > git[i]:
+            return False
+
+    return False
+class MyScaleVersion:
+    """Immutable version class. On update returns a new instance"""
+
+    def __init__(
+        self,
+        major: Union[int, str],
+        minor: Union[int, str],
+        patch: Union[int, str],
+        with_git: bool = True,
+    ):
+        self._major = int(major)
+        self._minor = int(minor)
+        self._patch = int(patch)
+        self._with_git = with_git
+        self._version_with_type = ""
+        self._version_type = ""
+    
+    def update_version_from_git(self):
+        # Âú®ÂØπÊú¨Âú∞Êñá‰ª∂Â≠òÂÇ®ÁöÑ version ËøõË°åÊìç‰ΩúÂâçËøõË°åÂà§Êñ≠ÔºåËã•Êú¨Âú∞ version ËêΩÂêé‰∫é git ÁöÑ versionÔºåÂàôÂÖàÂ∞ÜÊú¨Âú∞ version ‰øùÊåÅÂíå git ‰∏ÄËá¥
+        git_tag = git_runner.run("git describe --tags --abbrev=0").split('-')[1]
+        git_tag_parts = removeprefix(string=git_tag, prefix="v").split('.')
+        if(local_behind_git(local=(self._major, self._minor, self._patch), 
+                            git=(int(git_tag_parts[0]), int(git_tag_parts[1]), int(git_tag_parts[2])))):
+            print(f"Cautionüåµ: local version{(self._major, self._minor, self._patch)} behind"
+                    f" git version({git_tag}), your version update will base on {git_tag}")
+            self._major=int(git_tag_parts[0])
+            self._minor=int(git_tag_parts[1])
+            self._patch=int(git_tag_parts[2])
+
+    def update(self, part: Literal["major", "minor", "patch"]) -> "MyScaleVersion":
+        """If part is valid, returns a new version"""
+        if part == "major":
+            return self.major_update()
+        if part == "minor":
+            return self.minor_update()
+        if part == "patch":
+            return self.patch_update()
+        raise KeyError(f"wrong part {part} is used")
+
+    def major_update(self) -> "MyScaleVersion":
+        if self._with_git:
+            self.update_version_from_git()
+        return MyScaleVersion(self.major + 1, 0, 0, self._with_git)
+
+    def minor_update(self) -> "MyScaleVersion":
+        if self._with_git:
+            self.update_version_from_git()
+        return MyScaleVersion(self.major, self.minor + 1, 0, self._with_git)
+
+    def patch_update(self) -> "MyScaleVersion":
+        if self._with_git:
+            self.update_version_from_git()
+        return MyScaleVersion(self.major, self.minor, self.patch + 1, self._with_git)
+
+
+    @property
+    def major(self) -> int:
+        return self._major
+
+    @property
+    def minor(self) -> int:
+        return self._minor
+
+    @property
+    def patch(self) -> int:
+        return self._patch
+
+    @property
+    def version_with_type(self):
+        if self._version_type:
+            return f"myscale-v{self.string}-{self._version_type}"
+        return f"myscale-v{self.string}"
+
+    @property
+    def version_type(self) -> str:
+        return self._version_type
+
+    @property
+    def string(self):
+        return ".".join((str(self.major), str(self.minor), str(self.patch)))
+
+    def as_dict(self) -> VERSIONS:
+        return {
+            "major": self.major,
+            "minor": self.minor,
+            "patch": self.patch,
+            "describe": self.version_with_type,
+            "string": self.string,
+        }
+
+    def as_tuple(self) -> Tuple[int, int, int]:
+        return (self.major, self.minor, self.patch)
+
+    def with_version_type(self, version_type):
+        if version_type not in VersionType.VALID and not version_type.startswith("rc"):
+            raise ValueError(f"version type {version_type} not in {VersionType.VALID}, and not starts with rc")
+        self._version_type = version_type
+        # self._version_with_type = f"myscale-v{self.string}-{version_type}"
+
+
+###
+
+def validate_version(version: str) -> None:
+    parts = version.split(".")
+    if len(parts) != 3:
+        raise ValueError(f"{version} does not match 3 parts")
+    for part in parts:
+        int(part)
+
+
+def get_abs_path(path: str) -> str:
+    return p.abspath(p.join(git_runner.cwd, path))
+
+
+def read_versions_from_file(versions_path: str = FILE_WITH_VERSION_PATH) -> VERSIONS:
+    versions = {}
+    path_to_file = get_abs_path(versions_path)
+    with open(path_to_file, "r", encoding="utf-8") as f:
+        for line in f:
+            line = line.strip()
+            if not line.startswith("SET("):
+                continue
+
+            value = 0  # type: Union[int, str]
+            # ÂèñÂá∫ SET() ÂÜÖÁöÑ name Âíå value
+            name, value = line[4:-1].split(maxsplit=1)
+            name = removeprefix(name, "MYSCALE_VERSION_").lower()  # major / minor / patch ...
+            try:
+                value = int(value)
+            except ValueError:
+                pass
+            versions[name] = value
+
+    return versions
+
+
+def get_version_from_repo(versions_path: str = FILE_WITH_VERSION_PATH) -> MyScaleVersion:
+    versions = read_versions_from_file(versions_path)
+    return MyScaleVersion(
+        versions["major"],
+        versions["minor"],
+        versions["patch"],
+        with_git=True
+    )
+
+
+def get_version_from_string(version: str, with_git: bool=True) -> MyScaleVersion:
+    validate_version(version)
+    parts = version.split(".")
+    return MyScaleVersion(parts[0], parts[1], parts[2], with_git)
+
+def update_cmake_version(version: MyScaleVersion, versions_path: str = FILE_WITH_VERSION_PATH) -> None:
+    path_to_file = get_abs_path(versions_path)
+    print(f"new version has been generated: {version.as_dict()}")
+    with open(path_to_file, "w", encoding="utf-8") as f:
+        f.write(VERSIONS_TEMPLATE.format_map(version.as_dict()))
+
+ 
+
+
+def main():
+    """The simplest thing it does - reads versions from cmake and produce the
+    environment variables that may be sourced in bash scripts"""
+    parser = ArgumentParser(
+        formatter_class=ArgumentDefaultsHelpFormatter,
+        description="The script reads versions from cmake and produce ENV variables",
+    )
+    parser.add_argument(
+        "--version-path",
+        "-p",
+        default=FILE_WITH_VERSION_PATH,
+        help="relative path to the cmake file with versions",
+    )
+    parser.add_argument(
+        "--version-type",
+        "-t",
+        # choices=VersionType.VALID,
+        help="optional parameter to generate DESCRIBE",
+    )
+    parser.add_argument(
+        "--export",
+        "-e",
+        action="store_true",
+        help="if the ENV variables should be exported",
+    )
+    parser.add_argument(
+        "--update",
+        "-u",
+        choices=("major", "minor", "patch"),
+        help="the version part to update",
+    )
+    args = parser.parse_args()
+
+    version = get_version_from_repo(args.version_path)
+
+    if args.update:
+        version = version.update(args.update)
+
+    if args.version_type:
+        version.with_version_type(args.version_type)
+
+    if args.update or args.version_type:
+        update_cmake_version(version)
+
+    for k, v in version.as_dict().items():
+        name = f"MYSCALE_VERSION_{k.upper()}"
+        print(f"{name}='{v}'")
+        if args.export:
+            print(f"export {name}")
+
+
+if __name__ == "__main__":
+    main()
diff --git a/src/Storages/System/StorageSystemBuildOptions.generated.cpp.in b/src/Storages/System/StorageSystemBuildOptions.generated.cpp.in
index d7034cf828..9634e2ce79 100644
--- a/src/Storages/System/StorageSystemBuildOptions.generated.cpp.in
+++ b/src/Storages/System/StorageSystemBuildOptions.generated.cpp.in
@@ -64,6 +64,7 @@ const char * auto_config_build[]
     "USE_ARROW", "@USE_ARROW@",
     "USE_ORC", "@USE_ORC@",
     "USE_MSGPACK", "@USE_MSGPACK@",
+    "MYSCALE_VERSION", "@MYSCALE_VERSION_DESCRIBE@",
     "GIT_HASH", "@GIT_HASH@",
     "GIT_BRANCH", R"IRjaNsZIL9Yh7FQ4(@GIT_BRANCH@)IRjaNsZIL9Yh7FQ4",
     "GIT_DATE", "@GIT_DATE@",
-- 
2.32.1 (Apple Git-133)

