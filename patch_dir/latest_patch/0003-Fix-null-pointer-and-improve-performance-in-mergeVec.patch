From 3ff484a6a71050f062e86c9db17eb1be137131d8 Mon Sep 17 00:00:00 2001
From: Jianmei Zhang <jianmeiz@moqi.ai>
Date: Wed, 21 Jun 2023 06:26:18 +0000
Subject: [PATCH] Fix null pointer and improve performance in
 mergeVectorScanResult()

---
 ...MergeTreeSelectWithVectorScanProcessor.cpp | 12 +--
 .../MergeTree/MergeTreeVectorScanManager.cpp  | 86 +++++++++++++------
 src/Storages/MergeTree/VectorScanResult.h     |  1 +
 3 files changed, 66 insertions(+), 33 deletions(-)

diff --git a/src/Storages/MergeTree/MergeTreeSelectWithVectorScanProcessor.cpp b/src/Storages/MergeTree/MergeTreeSelectWithVectorScanProcessor.cpp
index f3ded451d4..e712d27099 100644
--- a/src/Storages/MergeTree/MergeTreeSelectWithVectorScanProcessor.cpp
+++ b/src/Storages/MergeTree/MergeTreeSelectWithVectorScanProcessor.cpp
@@ -406,11 +406,14 @@ MergeTreeBaseSelectProcessor::BlockAndRowCount MergeTreeSelectWithVectorScanProc
             /// Get _part_offset if exists.
             if (mutable_part_offset_col)
             {
-                part_offset = typeid_cast<const ColumnUInt64 *>(mutable_part_offset_col.get());
-
                 /// _part_offset column exists in original select columns
                 if (!need_remove_part_offset)
+                {
                     result_columns.emplace_back(std::move(mutable_part_offset_col));
+                    part_offset = typeid_cast<const ColumnUInt64 *>(result_columns.back().get());
+                }
+                else
+                    part_offset = typeid_cast<const ColumnUInt64 *>(mutable_part_offset_col.get());
             }
 
             if (task->vector_scan_manager && task->vector_scan_manager->preComputed())
@@ -492,14 +495,13 @@ MergeTreeBaseSelectProcessor::BlockAndRowCount MergeTreeSelectWithVectorScanProc
             continue;
         }
 
-        ColumnPtr column_ptr = read_result.columns[ps];
+        ordered_columns.emplace_back(std::move(read_result.columns[ps]));
 
         /// Copy _part_offset column
         if (col_name == "_part_offset")
         {
-            part_offset = typeid_cast<const ColumnUInt64 *>(column_ptr.get());
+            part_offset = typeid_cast<const ColumnUInt64 *>(ordered_columns.back().get());
         }
-        ordered_columns.emplace_back(std::move(read_result.columns[ps]));
     }
 
     auto read_end_time = std::chrono::system_clock::now();
diff --git a/src/Storages/MergeTree/MergeTreeVectorScanManager.cpp b/src/Storages/MergeTree/MergeTreeVectorScanManager.cpp
index a2a0d96f72..7c1d0a01dd 100644
--- a/src/Storages/MergeTree/MergeTreeVectorScanManager.cpp
+++ b/src/Storages/MergeTree/MergeTreeVectorScanManager.cpp
@@ -688,6 +688,10 @@ void MergeTreeVectorScanManager::mergeVectorScanResult(
         LOG_DEBUG(log, "Label colum is null");
     }
 
+    /// Initialize was_result_processed
+    if (tmp_result->was_result_processed.size() == 0)
+        tmp_result->was_result_processed.assign(label_column->size(), false);
+
     auto final_distance_column = DataTypeFloat32().createColumn();
 
     /// create new column vector to save final results
@@ -717,6 +721,10 @@ void MergeTreeVectorScanManager::mergeVectorScanResult(
                 /// for each vector search result, try to find if there is one with label equals to row id.
                 for (size_t ind = 0; ind < label_column->size(); ++ind)
                 {
+                    /// Skip if this label has already processed
+                    if (tmp_result->was_result_processed[ind])
+                        continue;
+
                     if (label_column->getUInt(ind) == start_pos + offset)
                     {
                         /// LOG_DEBUG(log, "merge result: ind: {}, current_column_pos: {}, filter_id: {}", ind, current_column_pos, i + start_offset);
@@ -728,6 +736,8 @@ void MergeTreeVectorScanManager::mergeVectorScanResult(
                             final_result[col]->insert(field);
                         }
                         final_distance_column->insert(distance_column->getFloat32(ind));
+
+                        tmp_result->was_result_processed[ind] = true;
                     }
                 }
                 ++current_column_pos;
@@ -750,6 +760,9 @@ void MergeTreeVectorScanManager::mergeVectorScanResult(
                 end_pos = read_range.start_row + read_range.row_num;
                 for (size_t ind = 0; ind < label_column->size(); ++ind)
                 {
+                    if (tmp_result->was_result_processed[ind])
+                        continue;
+
                     const UInt64 label_value = label_column->getUInt(ind);
                     if (label_value >= start_pos && label_value < end_pos)
                     {
@@ -762,57 +775,74 @@ void MergeTreeVectorScanManager::mergeVectorScanResult(
                         }
 
                         final_distance_column->insert(distance_column->getFloat32(ind));
+
+                        tmp_result->was_result_processed[ind] = true;
                     }
                 }
                 prev_row_num += read_range.row_num;
             }
         }
-        else
+        else if (part_offset->size() > 0)
         {
             LOG_DEBUG(log, "Get part offset");
 
             /// When lightweight delete applied, the rowid in the label column cannot be used as index of pre_result.
             /// Match the rowid in the value of label col and the value of part_offset to find the correct index.
             const ColumnUInt64::Container & offset_raw_value = part_offset->getData();
+            size_t part_offset_size = part_offset->size();
 
-            /// start_pos and end_pos is used as start and end index of part_offset
             size_t start_pos = 0;
-            size_t end_pos = part_offset->size() - 1;
+            size_t end_pos = 0;
 
-            for (size_t ind = 0; ind < label_column->size(); ++ind)
+            for (auto & read_range : read_ranges)
             {
-                const UInt64 label_value = label_column->getUInt(ind);
-
-                /// read range doesn't consider LWD, hence start_row and row_num in read range cannot be used in this case.
-                size_t low = start_pos;
-                size_t high = end_pos;
-                size_t mid;
+                start_pos = read_range.start_row;
+                end_pos = read_range.start_row + read_range.row_num;
 
-                /// label_value (row id) = part_offset.
-                /// We can use binary search to quickly locate part_offset for current label.
-                while (low <= high)
+                for (size_t ind = 0; ind < label_column->size(); ++ind)
                 {
-                    mid = low + (high - low) / 2;
+                    if (tmp_result->was_result_processed[ind])
+                        continue;
+
+                    const UInt64 label_value = label_column->getUInt(ind);
 
-                    if (label_value == offset_raw_value[mid])
+                    /// Check if label_value inside this read range
+                    if (label_value < start_pos || (label_value >= end_pos))
+                        continue;
+
+                    /// read range doesn't consider LWD, hence start_row and row_num in read range cannot be used in this case.
+                    int low = 0;
+                    int high = part_offset_size - 1;
+                    int mid;
+
+                    /// label_value (row id) = part_offset.
+                    /// We can use binary search to quickly locate part_offset for current label.
+                    while (low <= high)
                     {
-                        /// Use the index of part_offset to locate other columns in pre_result and fill final_result.
-                        for (size_t i = 0; i < final_result.size(); ++i)
+                        mid = low + (high - low) / 2;
+
+                        if (label_value == offset_raw_value[mid])
                         {
-                            Field field;
-                            pre_result[i]->get(mid, field);
-                            final_result[i]->insert(field);
-                        }
+                            /// Use the index of part_offset to locate other columns in pre_result and fill final_result.
+                            for (size_t i = 0; i < final_result.size(); ++i)
+                            {
+                                Field field;
+                                pre_result[i]->get(mid, field);
+                                final_result[i]->insert(field);
+                            }
 
-                        final_distance_column->insert(distance_column->getFloat32(ind));
+                            final_distance_column->insert(distance_column->getFloat32(ind));
 
-                        /// break from binary search loop
-                        break;
+                            tmp_result->was_result_processed[ind] = true;
+
+                            /// break from binary search loop
+                            break;
+                        }
+                        else if (label_value > offset_raw_value[mid])
+                            low = mid + 1;
+                        else
+                            high = mid - 1;
                     }
-                    else if (label_value > offset_raw_value[mid])
-                        low = mid + 1;
-                    else
-                        high = mid - 1;
                 }
             }
         }
diff --git a/src/Storages/MergeTree/VectorScanResult.h b/src/Storages/MergeTree/VectorScanResult.h
index 472281fb5b..576886809b 100644
--- a/src/Storages/MergeTree/VectorScanResult.h
+++ b/src/Storages/MergeTree/VectorScanResult.h
@@ -14,6 +14,7 @@ struct VectorScanResult
     int top_k;
     int query_vector_num;
     MutableColumns result_columns;
+    std::vector<bool> was_result_processed;  /// Mark if the result was processed or not.
     UInt64 vector_scan_duration_ms;
     UInt64 read_duration_ms;
 
-- 
2.32.1 (Apple Git-133)

