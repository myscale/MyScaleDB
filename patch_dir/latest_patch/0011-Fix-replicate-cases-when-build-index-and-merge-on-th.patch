From 2867b56bba36e418e211f0face8df5dc6ced6668 Mon Sep 17 00:00:00 2001
From: Jianmei Zhang <jianmeiz@moqi.ai>
Date: Thu, 6 Jul 2023 02:55:08 +0000
Subject: [PATCH] Fix replicate cases when build index and merge on the same
 data part

---
 .../MergeTreeVectorIndexBuilderUpdater.cpp    | 42 +++++++++++++++++
 .../MergeTree/ReplicatedMergeTreeQueue.cpp    | 46 +++++++++++++++++--
 .../MergeTree/ReplicatedMergeTreeQueue.h      |  5 +-
 3 files changed, 88 insertions(+), 5 deletions(-)

diff --git a/src/Storages/MergeTree/MergeTreeVectorIndexBuilderUpdater.cpp b/src/Storages/MergeTree/MergeTreeVectorIndexBuilderUpdater.cpp
index b8d6f4b5bf..7d8e5d9d4f 100644
--- a/src/Storages/MergeTree/MergeTreeVectorIndexBuilderUpdater.cpp
+++ b/src/Storages/MergeTree/MergeTreeVectorIndexBuilderUpdater.cpp
@@ -487,6 +487,27 @@ BuildVectorIndexStatus MergeTreeVectorIndexBuilderUpdater::buildVectorIndexForOn
                         VectorIndexEventLog::addEventLog(data.getContext(), part, VectorIndexEventLogElement::BUILD_CANCELD);
                         return BuildVectorIndexStatus::SUCCESS;
                     }
+
+                    /// In replicated case, slow replica may build vector index for merged data part.
+                    /// Here check the future part has the same prefix name as build part.
+                    if (is_replicated)
+                    {
+                        String future_part_name_prefix = future_part->info.getPartNameWithoutMutation();
+                        if (future_part_name_prefix != part_name_prefix)
+                        {
+                            LOG_DEBUG(log, "future part '{}' is a merged part not mutated part from part '{}' build vector index, no need to move.", future_part_name_prefix, part_name_prefix);
+                            if (disk->exists(vector_tmp_relative_path))
+                            {
+                                LOG_DEBUG(log, "Will remove unneeded vector index");
+                                disk->removeRecursive(vector_tmp_relative_path);
+                            }
+                            else
+                                LOG_DEBUG(log, "[Unneeded] vector_tmp_relative_path doesn't exist {}", vector_tmp_relative_path);
+
+                            VectorIndexEventLog::addEventLog(data.getContext(), part, VectorIndexEventLogElement::BUILD_CANCELD);
+                            return BuildVectorIndexStatus::SUCCESS;
+                        }
+                    }
                 }
 
                 if (future_part && !future_part->getPartIsMutating())
@@ -617,6 +638,27 @@ BuildVectorIndexStatus MergeTreeVectorIndexBuilderUpdater::buildVectorIndexForOn
                     return BuildVectorIndexStatus::SUCCESS;
                 }
 
+                /// In replicated case, slow replica may build vector index for merged data part.
+                /// Here check the future part has the same prefix name as build part.
+                if (is_replicated)
+                {
+                    String future_part_name_prefix = future_part->info.getPartNameWithoutMutation();
+                    if (future_part_name_prefix != part_name_prefix)
+                    {
+                        LOG_DEBUG(log, "future part '{}' is a merged part not mutated part from part '{}' build vector index, no need to move.", future_part_name_prefix, part_name_prefix);
+                        if (disk->exists(vector_tmp_relative_path))
+                        {
+                            LOG_DEBUG(log, "Will remove unneeded vector index");
+                            disk->removeRecursive(vector_tmp_relative_path);
+                        }
+                        else
+                            LOG_DEBUG(log, "[Unneeded] vector_tmp_relative_path doesn't exist {}", vector_tmp_relative_path);
+
+                        VectorIndexEventLog::addEventLog(data.getContext(), part, VectorIndexEventLogElement::BUILD_CANCELD);
+                        return BuildVectorIndexStatus::SUCCESS;
+                    }
+                }
+
                 /// First, move index files to part and apply lightweight delete.
                 moveVectorIndexFilesToFuturePart(metadata_snapshot, vector_tmp_relative_path, future_part);
 
diff --git a/src/Storages/MergeTree/ReplicatedMergeTreeQueue.cpp b/src/Storages/MergeTree/ReplicatedMergeTreeQueue.cpp
index 7ced1b3fc9..6bed589870 100644
--- a/src/Storages/MergeTree/ReplicatedMergeTreeQueue.cpp
+++ b/src/Storages/MergeTree/ReplicatedMergeTreeQueue.cpp
@@ -1275,6 +1275,35 @@ bool ReplicatedMergeTreeQueue::shouldExecuteLogEntry(
                     return false;
                 }
             }
+
+            /// Check if this replica can merge source parts for vector index.
+            if (data.getInMemoryMetadataPtr()->hasVectorIndices())
+            {
+                MergeTreeData::DataPartPtr prev_part = nullptr;
+
+                /// loop through source parts and compare two adjacent data parts.
+                for (const auto & name : entry.source_parts)
+                {
+                    auto part = data.getPartIfExists(name, {MergeTreeDataPartState::Active});
+                    if (part)
+                    {
+                        if (prev_part)
+                        {
+                            String out_reason;
+                            if (!ReplicatedMergeTreeMergePredicate::canMergeWithVectorIndex(prev_part, part, &out_reason))
+                            {
+                                out_postpone_reason = fmt::format(
+                                        "Not executing log entry {} for part {} because {}",
+                                        entry.znode_name, entry.new_part_name, out_reason);
+                                LOG_DEBUG(log, fmt::runtime(out_postpone_reason));
+                                return false;
+                            }
+                        }
+
+                        prev_part = part;
+                    }
+                }
+            }
         }
 
         if (!ignore_max_size && sum_parts_size_in_bytes > max_source_parts_size)
@@ -2161,7 +2190,7 @@ bool ReplicatedMergeTreeMergePredicate::canMergeTwoParts(
     }
 
     /// Checks related to vector index
-    if (!canMergeWithVectorIndex(left, right))
+    if (!canMergeWithVectorIndex(left, right, out_reason))
         return false;
 
     return MergeTreeData::partsContainSameProjections(left, right);
@@ -2209,20 +2238,29 @@ bool ReplicatedMergeTreeMergePredicate::canMergeSinglePart(
 
 bool ReplicatedMergeTreeMergePredicate::canMergeWithVectorIndex(
     const MergeTreeData::DataPartPtr & left,
-    const MergeTreeData::DataPartPtr & right) const
+    const MergeTreeData::DataPartPtr & right,
+    String * out_reason)
 {
     /// Check if part contains merged vector index
     if (left->containRowIdsMaps() || right->containRowIdsMaps())
+    {
+        if (out_reason)
+            *out_reason = "source part " + left->name + " or " + right->name + " is a decouple part";
         return false;
+    }
 
     /// Check if part is building vector index
     {
         std::lock_guard lock(left->storage.currently_vector_indexing_parts_mutex);
         for (const auto & part_name : left->storage.currently_vector_indexing_parts)
         {
-            auto info = MergeTreePartInfo::fromPartName(part_name, queue.format_version);
+            auto info = MergeTreePartInfo::fromPartName(part_name, left->storage.format_version);
             if (left->info.contains(info) || right->info.contains(info))
+            {
+                if (out_reason)
+                    *out_reason = "source part " + left->name + " or " + right->name + " is currently building vector index";
                 return false;
+            }
         }
     }
 
@@ -2240,6 +2278,8 @@ bool ReplicatedMergeTreeMergePredicate::canMergeWithVectorIndex(
         }
         else
         {
+            if (out_reason)
+                *out_reason = "source part " + left->name + " or " + right->name + " doesn't contain the same built vector index";
             can_merge = false;
             break;
         }
diff --git a/src/Storages/MergeTree/ReplicatedMergeTreeQueue.h b/src/Storages/MergeTree/ReplicatedMergeTreeQueue.h
index 55c98cde4d..c6ea84a9de 100644
--- a/src/Storages/MergeTree/ReplicatedMergeTreeQueue.h
+++ b/src/Storages/MergeTree/ReplicatedMergeTreeQueue.h
@@ -497,8 +497,9 @@ public:
                           String * out_reason = nullptr) const;
 
     /// Can we merge two parts with vector index?
-    bool canMergeWithVectorIndex(const MergeTreeData::DataPartPtr & left,
-                                 const MergeTreeData::DataPartPtr & right) const;
+    static bool canMergeWithVectorIndex(const MergeTreeData::DataPartPtr & left,
+                                 const MergeTreeData::DataPartPtr & right,
+                                 String * out_reason = nullptr);
 
     /// Can we assign a merge this part and some other part?
     /// For example a merge of a part and itself is needed for TTL.
-- 
2.32.1 (Apple Git-133)

