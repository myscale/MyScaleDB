From 3e64b699c4f48056b7533af18ebeebb388806332 Mon Sep 17 00:00:00 2001
From: zhengl <zhengl@zhengldeMacBook-Pro.local>
Date: Tue, 22 Nov 2022 18:45:25 +0800
Subject: [PATCH 02/51] All tests about transaction are passed, and transaction
 can work correctlly.

---
 programs/server/Server.cpp                    |  2 +-
 src/Core/Settings.h                           |  1 -
 src/Functions/FunctionConstantBase.h          |  4 +-
 .../registerFunctionsMiscellaneous.cpp        |  2 +-
 src/IO/ReadHelpers.cpp                        |  7 ++
 src/IO/ReadHelpers.h                          |  1 +
 src/Storages/MergeTree/MergeTreeData.cpp      | 74 +++++++++----------
 .../MergeTree/MergeTreeMutationEntry.cpp      |  1 -
 8 files changed, 45 insertions(+), 47 deletions(-)

diff --git a/programs/server/Server.cpp b/programs/server/Server.cpp
index a86185ee2f..474d82c883 100644
--- a/programs/server/Server.cpp
+++ b/programs/server/Server.cpp
@@ -1710,7 +1710,7 @@ if (ThreadFuzzer::instance().isEffective())
 
 #ifdef ENABLE_LICENSE_CHECK
     /// Check license
-//    scheduleLicense();
+    scheduleLicense();
 #endif
 
     /// Set current database name before loading tables and databases because
diff --git a/src/Core/Settings.h b/src/Core/Settings.h
index 7a37db306c..28aee915f3 100644
--- a/src/Core/Settings.h
+++ b/src/Core/Settings.h
@@ -1006,7 +1006,6 @@ class IColumn;
       "the function will accept invalid polygons but may silently return wrong result.", \
       0) \
     M(UInt64, max_parser_depth, DBMS_DEFAULT_MAX_PARSER_DEPTH, "Maximum parser depth (recursion depth of recursive descend parser).", 0) \
-    M(Bool, allow_settings_after_format_in_insert, false, "Allow SETTINGS after FORMAT, but note, that this is not always safe (note: this is a compatibility setting).", 0) \
     M(Seconds, \
       temporary_live_view_timeout, \
       DEFAULT_TEMPORARY_LIVE_VIEW_TIMEOUT_SEC, \
diff --git a/src/Functions/FunctionConstantBase.h b/src/Functions/FunctionConstantBase.h
index 2d237c7725..c178b3a256 100644
--- a/src/Functions/FunctionConstantBase.h
+++ b/src/Functions/FunctionConstantBase.h
@@ -41,9 +41,9 @@ public:
 
     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }
 
-    ColumnPtr executeImpl(const ColumnsWithTypeAndName &, const DataTypePtr &, size_t input_rows_count) const override
+    ColumnPtr executeImpl(const ColumnsWithTypeAndName &, const DataTypePtr & result_type, size_t input_rows_count) const override
     {
-        return ColumnT().createColumnConst(input_rows_count, constant_value);
+        return result_type->createColumnConst(input_rows_count, constant_value);
     }
 
 private:
diff --git a/src/Functions/registerFunctionsMiscellaneous.cpp b/src/Functions/registerFunctionsMiscellaneous.cpp
index b6dd40a24f..10c75f2e90 100644
--- a/src/Functions/registerFunctionsMiscellaneous.cpp
+++ b/src/Functions/registerFunctionsMiscellaneous.cpp
@@ -76,7 +76,7 @@ void registerFunctionFile(FunctionFactory & factory);
 void registerFunctionConnectionId(FunctionFactory & factory);
 void registerFunctionPartitionId(FunctionFactory & factory);
 void registerFunctionIsIPAddressContainedIn(FunctionFactory &);
-void registerFunctionsTransactionCounters(FunctionFactory & factory);
+void registerFunctionsTransactionCounters(FunctionFactory &);
 void registerFunctionQueryID(FunctionFactory &);
 void registerFunctionInitialQueryID(FunctionFactory &);
 void registerFunctionServerUUID(FunctionFactory &);
diff --git a/src/IO/ReadHelpers.cpp b/src/IO/ReadHelpers.cpp
index e086f16be5..dcf5f8be78 100644
--- a/src/IO/ReadHelpers.cpp
+++ b/src/IO/ReadHelpers.cpp
@@ -26,6 +26,7 @@ namespace ErrorCodes
     extern const int CANNOT_PARSE_DATETIME;
     extern const int CANNOT_PARSE_DATE;
     extern const int INCORRECT_DATA;
+    extern const int ATTEMPT_TO_READ_AFTER_EOF;
 }
 
 template <typename IteratorSrc, typename IteratorDst>
@@ -137,6 +138,12 @@ void assertEOF(ReadBuffer & buf)
         throwAtAssertionFailed("eof", buf);
 }
 
+void assertNotEOF(ReadBuffer & buf)
+{
+    if (buf.eof())
+        throw Exception("Attempt to read after EOF", ErrorCodes::ATTEMPT_TO_READ_AFTER_EOF);
+}
+
 
 void assertStringCaseInsensitive(const char * s, ReadBuffer & buf)
 {
diff --git a/src/IO/ReadHelpers.h b/src/IO/ReadHelpers.h
index 9396e1d32f..71045c7c73 100644
--- a/src/IO/ReadHelpers.h
+++ b/src/IO/ReadHelpers.h
@@ -163,6 +163,7 @@ void readVectorBinary(std::vector<T> & v, ReadBuffer & buf, size_t MAX_VECTOR_SI
 
 void assertString(const char * s, ReadBuffer & buf);
 void assertEOF(ReadBuffer & buf);
+void assertNotEOF(ReadBuffer & buf);
 
 [[noreturn]] void throwAtAssertionFailed(const char * s, ReadBuffer & buf);
 
diff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp
index 16a441f606..8551cb26cf 100644
--- a/src/Storages/MergeTree/MergeTreeData.cpp
+++ b/src/Storages/MergeTree/MergeTreeData.cpp
@@ -2821,10 +2821,6 @@ bool MergeTreeData::renameTempPartAndReplace(
         return false;
     }
 
-    /// FIXME Transactions: it's not the best place for checking and setting maxtid,
-    /// because it's too optimistic. We should lock maxtid of covered parts at the beginning of operation.
-    MergeTreeTransaction::addNewPartAndRemoveCovered(shared_from_this(), part, covered_parts, txn);
-
     /// Deduplication log used only from non-replicated MergeTree. Replicated
     /// tables have their own mechanism. We try to deduplicate at such deep
     /// level, because only here we know real part name which is required for
@@ -2853,7 +2849,6 @@ bool MergeTreeData::renameTempPartAndReplace(
     part->renameTo(part_name, true);
 
     auto part_it = data_parts_indexes.insert(part).first;
-
     /// FIXME Transactions: it's not the best place for checking and setting removal_tid,
     /// because it's too optimistic. We should lock removal_tid of covered parts at the beginning of operation.
     MergeTreeTransaction::addNewPartAndRemoveCovered(shared_from_this(), part, covered_parts, txn);
@@ -4276,42 +4271,39 @@ MergeTreeData::DataPartsVector MergeTreeData::getDataPartsVectorForInternalUsage
 {
     DataPartsVector res;
     DataPartsVector buf;
+
+    for (auto state : affordable_states)
     {
-        auto lock = lockParts();
+        auto range = getDataPartsStateRange(state);
 
-        for (auto state : affordable_states)
+        if (require_projection_parts)
         {
-            auto range = getDataPartsStateRange(state);
-
-            if (require_projection_parts)
+            for (const auto & part : range)
             {
-                for (const auto & part : range)
-                {
-                    for (const auto & [p_name, projection_part] : part->getProjectionParts())
-                        res.push_back(projection_part);
-                }
-            }
-            else
-            {
-                std::swap(buf, res);
-                res.clear();
-                std::merge(range.begin(), range.end(), buf.begin(), buf.end(), std::back_inserter(res), LessDataPart()); //-V783
+                for (const auto & [_, projection_part] : part->getProjectionParts())
+                    res.push_back(projection_part);
             }
         }
+        else
+        {
+            std::swap(buf, res);
+            res.clear();
+            std::merge(range.begin(), range.end(), buf.begin(), buf.end(), std::back_inserter(res), LessDataPart()); //-V783
+        }
+    }
 
-        if (out_states != nullptr)
+    if (out_states != nullptr)
+    {
+        out_states->resize(res.size());
+        if (require_projection_parts)
         {
-            out_states->resize(res.size());
-            if (require_projection_parts)
-            {
-                for (size_t i = 0; i < res.size(); ++i)
-                    (*out_states)[i] = res[i]->getParentPart()->getState();
-            }
-            else
-            {
-                for (size_t i = 0; i < res.size(); ++i)
-                    (*out_states)[i] = res[i]->getState();
-            }
+            for (size_t i = 0; i < res.size(); ++i)
+                (*out_states)[i] = res[i]->getParentPart()->getState();
+        }
+        else
+        {
+            for (size_t i = 0; i < res.size(); ++i)
+                (*out_states)[i] = res[i]->getState();
         }
     }
 
@@ -5415,10 +5407,10 @@ std::optional<ProjectionCandidate> MergeTreeData::getQueryProcessingStageWithAgg
     size_t min_sum_marks = std::numeric_limits<size_t>::max();
     if (metadata_snapshot->minmax_count_projection && !has_lightweight_delete_parts.load(std::memory_order_relaxed)) /// Disable ReadFromStorage for parts with lightweight.
         add_projection_candidate(*metadata_snapshot->minmax_count_projection);
-    std::optional<ProjectionCandidate> minmax_conut_projection_candidate;
+    std::optional<ProjectionCandidate> minmax_count_projection_candidate;
     if (!candidates.empty())
     {
-        minmax_conut_projection_candidate.emplace(std::move(candidates.front()));
+        minmax_count_projection_candidate.emplace(std::move(candidates.front()));
         candidates.clear();
     }
     MergeTreeDataSelectExecutor reader(*this);
@@ -5432,21 +5424,21 @@ std::optional<ProjectionCandidate> MergeTreeData::getQueryProcessingStageWithAgg
     auto parts = getVisibleDataPartsVector(query_context);
 
     // If minmax_count_projection is a valid candidate, check its completeness.
-    if (minmax_conut_projection_candidate)
+    if (minmax_count_projection_candidate)
     {
         DataPartsVector normal_parts;
         query_info.minmax_count_projection_block = getMinMaxCountProjectionBlock(
             metadata_snapshot,
-            minmax_conut_projection_candidate->required_columns,
+            minmax_count_projection_candidate->required_columns,
             query_info,
             parts,
             normal_parts,
             max_added_blocks.get(),
             query_context);
 
-        if (query_info.minmax_count_projection_block && minmax_conut_projection_candidate->prewhere_info)
+        if (query_info.minmax_count_projection_block && minmax_count_projection_candidate->prewhere_info)
         {
-            const auto & prewhere_info = minmax_conut_projection_candidate->prewhere_info;
+            const auto & prewhere_info = minmax_count_projection_candidate->prewhere_info;
 
             if (prewhere_info->row_level_filter)
             {
@@ -5463,7 +5455,7 @@ std::optional<ProjectionCandidate> MergeTreeData::getQueryProcessingStageWithAgg
 
         if (normal_parts.empty())
         {
-            selected_candidate = &*minmax_conut_projection_candidate;
+            selected_candidate = &*minmax_count_projection_candidate;
             selected_candidate->complete = true;
             min_sum_marks = query_info.minmax_count_projection_block.rows();
         }
@@ -5487,7 +5479,7 @@ std::optional<ProjectionCandidate> MergeTreeData::getQueryProcessingStageWithAgg
 
                 if (!normal_result_ptr->error())
                 {
-                    selected_candidate = &*minmax_conut_projection_candidate;
+                    selected_candidate = &*minmax_count_projection_candidate;
                     selected_candidate->merge_tree_normal_select_result_ptr = normal_result_ptr;
                     min_sum_marks = query_info.minmax_count_projection_block.rows() + normal_result_ptr->marks();
                 }
diff --git a/src/Storages/MergeTree/MergeTreeMutationEntry.cpp b/src/Storages/MergeTree/MergeTreeMutationEntry.cpp
index 2f05c8fae3..533a38c9a0 100644
--- a/src/Storages/MergeTree/MergeTreeMutationEntry.cpp
+++ b/src/Storages/MergeTree/MergeTreeMutationEntry.cpp
@@ -151,7 +151,6 @@ MergeTreeMutationEntry::MergeTreeMutationEntry(DiskPtr disk_, const String & pat
     }
 
     assertEOF(*buf);
-    csn = Tx::PrehistoricCSN;
 }
 
 MergeTreeMutationEntry::~MergeTreeMutationEntry()
-- 
2.32.1 (Apple Git-133)

