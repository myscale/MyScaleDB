From 27ad4673f71b23adf7f5f7380d63e5a290233c27 Mon Sep 17 00:00:00 2001
From: Zhenjia Li <zhenjial@moqi.ai>
Date: Mon, 17 Apr 2023 10:13:03 +0000
Subject: [PATCH 32/51] Support delete from .... on cluster

---
 src/Interpreters/InterpreterDeleteQuery.cpp   | 49 +++++++------------
 src/Parsers/ASTDeleteQuery.cpp                |  2 +
 src/Parsers/ASTDeleteQuery.h                  |  7 ++-
 src/Parsers/ParserDeleteQuery.cpp             |  9 ++++
 .../test_replicated_database/test.py          | 42 ++++++++++++++++
 ...41_lightweight_delete_on_cluster.reference | 13 +++++
 .../02541_lightweight_delete_on_cluster.sql   | 23 +++++++++
 7 files changed, 112 insertions(+), 33 deletions(-)
 create mode 100644 tests/queries/0_stateless/02541_lightweight_delete_on_cluster.reference
 create mode 100644 tests/queries/0_stateless/02541_lightweight_delete_on_cluster.sql

diff --git a/src/Interpreters/InterpreterDeleteQuery.cpp b/src/Interpreters/InterpreterDeleteQuery.cpp
index e9cea4da11..3dbc06c0fd 100644
--- a/src/Interpreters/InterpreterDeleteQuery.cpp
+++ b/src/Interpreters/InterpreterDeleteQuery.cpp
@@ -5,15 +5,16 @@
 #include <Databases/IDatabase.h>
 #include <Interpreters/Context.h>
 #include <Interpreters/FunctionNameNormalizer.h>
+#include <Interpreters/InterpreterAlterQuery.h>
 #include <Interpreters/MutationsInterpreter.h>
+#include <Parsers/parseQuery.h>
+#include <Parsers/formatAST.h>
+#include <Parsers/ParserAlterQuery.h>
 #include <Parsers/ASTDeleteQuery.h>
-#include <Parsers/ASTAssignment.h>
-#include <Parsers/ASTExpressionList.h>
 #include <Storages/AlterCommands.h>
 #include <Storages/IStorage.h>
 #include <Storages/MutationCommands.h>
 #include <Storages/LightweightDeleteDescription.h>
-#include <Storages/MergeTree/MergeTreeData.h>
 
 
 namespace DB
@@ -68,35 +69,19 @@ BlockIO InterpreterDeleteQuery::execute()
     auto table_lock = table->lockForShare(getContext()->getCurrentQueryId(), getContext()->getSettingsRef().lock_acquire_timeout);
     auto metadata_snapshot = table->getInMemoryMetadataPtr();
 
-    /// Convert to MutationCommand
-    MutationCommands mutation_commands;
-    MutationCommand mut_command;
-
-    /// Build "UPDATE _row_exists = 0 WHERE predicate" query
-    mut_command.type = MutationCommand::Type::UPDATE;
-    mut_command.predicate = delete_query.predicate;
-
-    auto command = std::make_shared<ASTAlterCommand>();
-    command->type = ASTAlterCommand::UPDATE;
-    command->predicate = delete_query.predicate;
-    command->update_assignments = std::make_shared<ASTExpressionList>();
-    auto set_row_does_not_exist = std::make_shared<ASTAssignment>();
-    set_row_does_not_exist->column_name = LightweightDeleteDescription::FILTER_COLUMN.name;
-    auto zero_value = std::make_shared<ASTLiteral>(DB::Field(UInt8(0)));
-    set_row_does_not_exist->children.push_back(zero_value);
-    command->update_assignments->children.push_back(set_row_does_not_exist);
-    command->children.push_back(command->predicate);
-    command->children.push_back(command->update_assignments);
-    mut_command.column_to_update_expression[set_row_does_not_exist->column_name] = zero_value;
-    mut_command.ast = command->ptr();
-
-    mutation_commands.emplace_back(mut_command);
-
-    table->checkMutationIsPossible(mutation_commands, getContext()->getSettingsRef());
-    MutationsInterpreter(table, metadata_snapshot, mutation_commands, getContext(), false).validate();
-    table->mutate(mutation_commands, getContext());
-
-    return {};
+    /// Build "ALTER ... UPDATE _row_exists = 0 WHERE predicate" query
+    String alter_query = "ALTER TABLE " + table->getStorageID().getFullTableName()
+        + (delete_query.cluster.empty() ? "" : " ON CLUSTER " + backQuoteIfNeed(delete_query.cluster)) + " UPDATE `_row_exists` = 0 WHERE "
+        + serializeAST(*delete_query.predicate);
+
+    ParserAlterQuery parser;
+    ASTPtr alter_ast
+        = parseQuery(parser, alter_query.data(), alter_query.data() + alter_query.size(), "ALTER query", 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);
+
+    auto context = Context::createCopy(getContext());
+    context->setSetting("mutations_sync", 2); /// Lightweight delete is always synchronous
+    InterpreterAlterQuery alter_interpreter(alter_ast, context);
+    return alter_interpreter.execute();
 }
 
 }
diff --git a/src/Parsers/ASTDeleteQuery.cpp b/src/Parsers/ASTDeleteQuery.cpp
index ee7dba8dbf..01958fcd51 100644
--- a/src/Parsers/ASTDeleteQuery.cpp
+++ b/src/Parsers/ASTDeleteQuery.cpp
@@ -35,6 +35,8 @@ void ASTDeleteQuery::formatQueryImpl(const FormatSettings & settings, FormatStat
     }
     settings.ostr << backQuoteIfNeed(getTable());
 
+    formatOnCluster(settings);
+
     settings.ostr << (settings.hilite ? hilite_keyword : "") << " WHERE " << (settings.hilite ? hilite_none : "");
     predicate->formatImpl(settings, state, frame);
 }
diff --git a/src/Parsers/ASTDeleteQuery.h b/src/Parsers/ASTDeleteQuery.h
index bcb97639b6..9e73651b3f 100644
--- a/src/Parsers/ASTDeleteQuery.h
+++ b/src/Parsers/ASTDeleteQuery.h
@@ -2,15 +2,20 @@
 
 #include <Parsers/IAST.h>
 #include <Parsers/ASTQueryWithTableAndOutput.h>
+#include <Parsers/ASTQueryWithOnCluster.h>
 
 namespace DB
 {
 /// DELETE FROM [db.]name WHERE ...
-class ASTDeleteQuery : public ASTQueryWithTableAndOutput
+class ASTDeleteQuery : public ASTQueryWithTableAndOutput, public ASTQueryWithOnCluster
 {
 public:
     String getID(char delim) const final;
     ASTPtr clone() const final;
+    ASTPtr getRewrittenASTWithoutOnCluster(const std::string & new_database) const override
+    {
+        return removeOnCluster<ASTDeleteQuery>(clone(), new_database);
+    }
 
     ASTPtr predicate;
 
diff --git a/src/Parsers/ParserDeleteQuery.cpp b/src/Parsers/ParserDeleteQuery.cpp
index bd06c060ac..2222a7b4b1 100644
--- a/src/Parsers/ParserDeleteQuery.cpp
+++ b/src/Parsers/ParserDeleteQuery.cpp
@@ -16,6 +16,7 @@ bool ParserDeleteQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
     ParserKeyword s_from("FROM");
     ParserKeyword s_where("WHERE");
     ParserExpression parser_exp_elem;
+    ParserKeyword s_on{"ON"};
 
     if (s_delete.ignore(pos, expected))
     {
@@ -25,6 +26,14 @@ bool ParserDeleteQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
         if (!parseDatabaseAndTableAsAST(pos, expected, query->database, query->table))
             return false;
 
+        if (s_on.ignore(pos, expected))
+        {
+            String cluster_str;
+            if (!ASTQueryWithOnCluster::parse(pos, cluster_str, expected))
+                return false;
+            query->cluster = cluster_str;
+        }
+
         if (!s_where.ignore(pos, expected))
             return false;
 
diff --git a/tests/integration/test_replicated_database/test.py b/tests/integration/test_replicated_database/test.py
index 13e9c225a6..1f61a43eb7 100644
--- a/tests/integration/test_replicated_database/test.py
+++ b/tests/integration/test_replicated_database/test.py
@@ -208,6 +208,48 @@ def test_simple_alter_table(started_cluster, engine):
     competing_node.query("DROP DATABASE testdb SYNC")
 
 
+@pytest.mark.parametrize("engine", ["MergeTree", "ReplicatedMergeTree"])
+def test_delete_from_table(started_cluster, engine):
+    main_node.query(
+        "CREATE DATABASE testdb ENGINE = Replicated('/clickhouse/databases/test1', 'shard1', 'replica1');"
+    )
+    dummy_node.query(
+        "CREATE DATABASE testdb ENGINE = Replicated('/clickhouse/databases/test1', 'shard2', 'replica1');"
+    )
+
+    name = "testdb.delete_test_{}".format(engine)
+    main_node.query(
+        "CREATE TABLE {} "
+        "(id UInt64, value String) "
+        "ENGINE = {} PARTITION BY id%2 ORDER BY (id);".format(name, engine)
+    )
+    main_node.query("INSERT INTO TABLE {} VALUES(1, 'aaaa');".format(name))
+    main_node.query("INSERT INTO TABLE {} VALUES(2, 'aaaa');".format(name))
+    dummy_node.query("INSERT INTO TABLE {} VALUES(1, 'bbbb');".format(name))
+    dummy_node.query("INSERT INTO TABLE {} VALUES(2, 'bbbb');".format(name))
+
+    main_node.query(
+        "SET allow_experimental_lightweight_delete=1; DELETE FROM {} WHERE id=2;".format(
+            name
+        )
+    )
+
+    expected = "1\taaaa\n1\tbbbb"
+
+    table_for_select = name
+    if not "Replicated" in engine:
+        table_for_select = "cluster('testdb', {})".format(name)
+    for node in [main_node, dummy_node]:
+        assert_eq_with_retry(
+            node,
+            "SELECT * FROM {} ORDER BY id, value;".format(table_for_select),
+            expected,
+        )
+
+    main_node.query("DROP DATABASE testdb SYNC")
+    dummy_node.query("DROP DATABASE testdb SYNC")
+
+
 def get_table_uuid(database, name):
     return main_node.query(
         f"SELECT uuid FROM system.tables WHERE database = '{database}' and name = '{name}'"
diff --git a/tests/queries/0_stateless/02541_lightweight_delete_on_cluster.reference b/tests/queries/0_stateless/02541_lightweight_delete_on_cluster.reference
new file mode 100644
index 0000000000..02801a64d2
--- /dev/null
+++ b/tests/queries/0_stateless/02541_lightweight_delete_on_cluster.reference
@@ -0,0 +1,13 @@
+localhost	9000	0		0	0
+-- { echoOn }
+
+SELECT * FROM t1_local ORDER BY tc1, tc2;
+partition1	1	1
+partition2	1	2
+partition1	2	3
+partition2	2	4
+DELETE FROM t1_local ON CLUSTER test_shard_localhost WHERE tc1 = 1;
+localhost	9000	0		0	0
+SELECT * FROM t1_local ORDER BY tc1, tc2;
+partition1	2	3
+partition2	2	4
diff --git a/tests/queries/0_stateless/02541_lightweight_delete_on_cluster.sql b/tests/queries/0_stateless/02541_lightweight_delete_on_cluster.sql
new file mode 100644
index 0000000000..5d3da88d72
--- /dev/null
+++ b/tests/queries/0_stateless/02541_lightweight_delete_on_cluster.sql
@@ -0,0 +1,23 @@
+-- Tags: distributed, no-replicated-database
+-- Tag no-replicated-database: ON CLUSTER is not allowed
+
+SET distributed_ddl_output_mode='throw';
+
+CREATE TABLE t1_local ON CLUSTER test_shard_localhost(partition_col_1 String, tc1 int,tc2 int) ENGINE=MergeTree() PARTITION BY partition_col_1 ORDER BY tc1;
+
+INSERT INTO t1_local VALUES('partition1', 1,1);
+INSERT INTO t1_local VALUES('partition2', 1,2);
+INSERT INTO t1_local VALUES('partition1', 2,3);
+INSERT INTO t1_local VALUES('partition2', 2,4);
+
+SET allow_experimental_lightweight_delete=1;
+
+-- { echoOn }
+
+SELECT * FROM t1_local ORDER BY tc1, tc2;
+
+DELETE FROM t1_local ON CLUSTER test_shard_localhost WHERE tc1 = 1;
+
+SELECT * FROM t1_local ORDER BY tc1, tc2;
+
+-- { echoOff }
-- 
2.32.1 (Apple Git-133)

