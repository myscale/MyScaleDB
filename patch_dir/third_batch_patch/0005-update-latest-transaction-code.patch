From cbf94e76c2d629be2a2edf7f1c88db83b710f020 Mon Sep 17 00:00:00 2001
From: lvzheng <zhengl@moqi.ai>
Date: Tue, 29 Nov 2022 14:01:34 +0800
Subject: [PATCH 05/51] update latest transaction code.

---
 base/base/defines.h                           |  59 ++++
 cmake/warnings.cmake                          |   2 +-
 contrib/libcxx                                |   2 +-
 contrib/libcxx-cmake/CMakeLists.txt           |  12 +-
 src/Access/Common/AccessType.h                |   1 +
 src/Client/ClientBase.cpp                     |  10 +-
 src/Common/ErrorCodes.cpp                     |   2 +-
 src/Common/ErrorCodes.h                       |   3 +-
 src/Common/Exception.cpp                      |  15 +-
 src/Common/Exception.h                        |   2 +
 src/Common/GetPriorityForLoadBalancing.cpp    |  49 +++
 src/Common/GetPriorityForLoadBalancing.h      |  34 +++
 src/Common/ProfileEvents.cpp                  |   1 +
 src/Common/ZooKeeper/IKeeper.cpp              |   1 +
 src/Common/ZooKeeper/IKeeper.h                |  68 ++++-
 src/Common/ZooKeeper/KeeperException.h        |   4 +-
 src/Common/ZooKeeper/TestKeeper.cpp           |  58 +++-
 src/Common/ZooKeeper/TestKeeper.h             |  10 +
 src/Common/ZooKeeper/ZooKeeper.cpp            | 283 ++++++++++++++----
 src/Common/ZooKeeper/ZooKeeper.h              |  83 ++++-
 src/Common/ZooKeeper/ZooKeeperCommon.cpp      | 128 +++++++-
 src/Common/ZooKeeper/ZooKeeperCommon.h        |  37 ++-
 src/Common/ZooKeeper/ZooKeeperConstants.cpp   |   5 +-
 src/Common/ZooKeeper/ZooKeeperConstants.h     |   4 +
 src/Common/ZooKeeper/ZooKeeperIO.cpp          |  16 +-
 src/Common/ZooKeeper/ZooKeeperIO.h            |   6 +-
 src/Common/ZooKeeper/ZooKeeperImpl.cpp        | 122 ++++++--
 src/Common/ZooKeeper/ZooKeeperImpl.h          |  21 +-
 src/Common/noexcept_scope.h                   |  28 ++
 src/Coordination/KeeperConstants.h            |  25 ++
 src/Coordination/KeeperContext.h              |  23 ++
 src/Core/Settings.h                           |   6 +-
 src/Core/SettingsEnums.cpp                    |   5 +
 src/Core/SettingsEnums.h                      |   9 +
 .../FunctionsTransactionCounters.cpp          |   2 +-
 src/IO/ReadBufferFromString.h                 |   7 +
 src/IO/ReadHelpers.cpp                        |   7 -
 src/IO/ReadHelpers.h                          |   1 -
 src/Interpreters/InterpreterSystemQuery.cpp   |  16 +
 src/Interpreters/InterpreterSystemQuery.h     |   2 +
 .../InterpreterTransactionControlQuery.cpp    |  51 +++-
 .../InterpreterTransactionControlQuery.h      |   3 +-
 src/Interpreters/MergeTreeTransaction.cpp     | 105 ++++---
 src/Interpreters/MergeTreeTransaction.h       |  27 +-
 .../MergeTreeTransactionHolder.cpp            |   2 +-
 src/Interpreters/TransactionLog.cpp           | 281 ++++++++++++-----
 src/Interpreters/TransactionLog.h             |  43 ++-
 .../TransactionVersionMetadata.cpp            |  44 ++-
 src/Interpreters/TransactionVersionMetadata.h |   1 +
 src/Interpreters/TransactionsInfoLog.cpp      |   2 +-
 src/Interpreters/TransactionsInfoLog.h        |   1 +
 src/Interpreters/ZooKeeperLog.h               |   5 +
 src/Interpreters/executeQuery.cpp             | 121 ++++++--
 src/Parsers/ASTSystemQuery.h                  |   1 +
 src/Parsers/ParserQuery.h                     |   5 +
 src/Storages/MergeTree/MergeTreeData.cpp      |   8 +-
 src/Storages/MergeTree/MergeTreeData.h        |  33 +-
 .../MergeTree/MergeTreeDataSelectExecutor.cpp |   7 +-
 .../0_stateless/01167_isolation_hermitage.sh  |   2 +-
 .../0_stateless/01168_mutations_isolation.sh  |   2 +-
 .../01169_alter_partition_isolation_stress.sh |  24 +-
 .../01170_alter_partition_isolation.sh        |   2 +-
 .../01171_mv_select_insert_isolation_long.sh  |  32 +-
 .../01172_transaction_counters.reference      |   4 +-
 .../01172_transaction_counters.sql            |  11 +-
 .../01173_transaction_control_queries.sql     |  19 +-
 .../01174_select_insert_isolation.sh          |  16 +-
 tests/queries/shell_config.sh                 |  20 ++
 utils/keeper-bench/Generator.cpp              |   2 +-
 69 files changed, 1619 insertions(+), 424 deletions(-)
 create mode 100644 src/Common/GetPriorityForLoadBalancing.cpp
 create mode 100644 src/Common/GetPriorityForLoadBalancing.h
 create mode 100644 src/Common/noexcept_scope.h
 create mode 100644 src/Coordination/KeeperConstants.h
 create mode 100644 src/Coordination/KeeperContext.h

diff --git a/base/base/defines.h b/base/base/defines.h
index bd98e99f5b..c8c408b9c9 100644
--- a/base/base/defines.h
+++ b/base/base/defines.h
@@ -100,11 +100,70 @@
 #    define ALWAYS_INLINE_NO_SANITIZE_UNDEFINED ALWAYS_INLINE
 #endif
 
+#if defined(__clang__) && defined(__clang_major__) && __clang_major__ >= 14
+#    define DISABLE_SANITIZER_INSTRUMENTATION __attribute__((disable_sanitizer_instrumentation))
+#else
+#    define DISABLE_SANITIZER_INSTRUMENTATION
+#endif
+
+
 #if !__has_include(<sanitizer/asan_interface.h>) || !defined(ADDRESS_SANITIZER)
 #   define ASAN_UNPOISON_MEMORY_REGION(a, b)
 #   define ASAN_POISON_MEMORY_REGION(a, b)
 #endif
 
+#if !defined(ABORT_ON_LOGICAL_ERROR)
+    #if !defined(NDEBUG) || defined(ADDRESS_SANITIZER) || defined(THREAD_SANITIZER) || defined(MEMORY_SANITIZER) || defined(UNDEFINED_BEHAVIOR_SANITIZER)
+        #define ABORT_ON_LOGICAL_ERROR
+    #endif
+#endif
+
+/// chassert(x) is similar to assert(x), but:
+///     - works in builds with sanitizers, not only in debug builds
+///     - tries to print failed assertion into server log
+/// It can be used for all assertions except heavy ones.
+/// Heavy assertions (that run loops or call complex functions) are allowed in debug builds only.
+#if !defined(chassert)
+    #if defined(ABORT_ON_LOGICAL_ERROR)
+        #define chassert(x) static_cast<bool>(x) ? void(0) : abortOnFailedAssertion(#x)
+    #else
+        #define chassert(x) ((void)0)
+    #endif
+#endif
+
+/// Macros for Clang Thread Safety Analysis (TSA). They can be safely ignored by other compilers.
+/// Feel free to extend, but please stay close to https://clang.llvm.org/docs/ThreadSafetyAnalysis.html#mutexheader
+#if defined(__clang__)
+#    define TSA_GUARDED_BY(...) __attribute__((guarded_by(__VA_ARGS__)))                       /// data is protected by given capability
+#    define TSA_PT_GUARDED_BY(...) __attribute__((pt_guarded_by(__VA_ARGS__)))                 /// pointed-to data is protected by the given capability
+#    define TSA_REQUIRES(...) __attribute__((requires_capability(__VA_ARGS__)))                /// thread needs exclusive possession of given capability
+#    define TSA_REQUIRES_SHARED(...) __attribute__((requires_shared_capability(__VA_ARGS__)))  /// thread needs shared possession of given capability
+#    define TSA_ACQUIRED_AFTER(...) __attribute__((acquired_after(__VA_ARGS__)))               /// annotated lock must be locked after given lock
+#    define TSA_NO_THREAD_SAFETY_ANALYSIS __attribute__((no_thread_safety_analysis))           /// disable TSA for a function
+
+/// Macros for suppressing TSA warnings for specific reads/writes (instead of suppressing it for the whole function)
+/// Consider adding a comment before using these macros.
+#   define TSA_SUPPRESS_WARNING_FOR_READ(x) [&]() TSA_NO_THREAD_SAFETY_ANALYSIS -> const auto & { return (x); }()
+#   define TSA_SUPPRESS_WARNING_FOR_WRITE(x) [&]() TSA_NO_THREAD_SAFETY_ANALYSIS -> auto & { return (x); }()
+
+/// This macro is useful when only one thread writes to a member
+/// and you want to read this member from the same thread without locking a mutex.
+/// It's safe (because no concurrent writes are possible), but TSA generates a warning.
+/// (Seems like there's no way to verify it, but it makes sense to distinguish it from TSA_SUPPRESS_WARNING_FOR_READ for readability)
+#   define TSA_READ_ONE_THREAD(x) TSA_SUPPRESS_WARNING_FOR_READ(x)
+
+#else
+#    define TSA_GUARDED_BY(...)
+#    define TSA_PT_GUARDED_BY(...)
+#    define TSA_REQUIRES(...)
+#    define TSA_REQUIRES_SHARED(...)
+#    define TSA_NO_THREAD_SAFETY_ANALYSIS
+
+#    define TSA_SUPPRESS_WARNING_FOR_READ(x)
+#    define TSA_SUPPRESS_WARNING_FOR_WRITE(x)
+#    define TSA_READ_ONE_THREAD(x)
+#endif
+
 /// A template function for suppressing warnings about unused variables or function results.
 template <typename... Args>
 constexpr void UNUSED(Args &&... args [[maybe_unused]])
diff --git a/cmake/warnings.cmake b/cmake/warnings.cmake
index 2093d3dcc8..6bf326f410 100644
--- a/cmake/warnings.cmake
+++ b/cmake/warnings.cmake
@@ -25,7 +25,7 @@ if (COMPILER_CLANG)
     no_warning(vla-extension)
     no_warning(zero-length-array)
     no_warning(c11-extensions)
-
+    no_warning(thread-safety-negative) # experimental flag, too many false positives
     if (WEVERYTHING)
         add_warning(everything)
         no_warning(c++98-compat-pedantic)
diff --git a/contrib/libcxx b/contrib/libcxx
index 61e60294b1..172b2ae074 160000
--- a/contrib/libcxx
+++ b/contrib/libcxx
@@ -1 +1 @@
-Subproject commit 61e60294b1de01483caa9f5d00f437c99b674de6
+Subproject commit 172b2ae074f6755145b91c53a95c8540c1468239
diff --git a/contrib/libcxx-cmake/CMakeLists.txt b/contrib/libcxx-cmake/CMakeLists.txt
index 332fb0411c..a501c4df64 100644
--- a/contrib/libcxx-cmake/CMakeLists.txt
+++ b/contrib/libcxx-cmake/CMakeLists.txt
@@ -18,12 +18,14 @@ set(SRCS
 "${LIBCXX_SOURCE_DIR}/src/filesystem/directory_iterator.cpp"
 "${LIBCXX_SOURCE_DIR}/src/filesystem/int128_builtins.cpp"
 "${LIBCXX_SOURCE_DIR}/src/filesystem/operations.cpp"
+"${LIBCXX_SOURCE_DIR}/src/format.cpp"
 "${LIBCXX_SOURCE_DIR}/src/functional.cpp"
 "${LIBCXX_SOURCE_DIR}/src/future.cpp"
 "${LIBCXX_SOURCE_DIR}/src/hash.cpp"
 "${LIBCXX_SOURCE_DIR}/src/ios.cpp"
 "${LIBCXX_SOURCE_DIR}/src/ios.instantiations.cpp"
 "${LIBCXX_SOURCE_DIR}/src/iostream.cpp"
+"${LIBCXX_SOURCE_DIR}/src/legacy_pointer_safety.cpp"
 "${LIBCXX_SOURCE_DIR}/src/locale.cpp"
 "${LIBCXX_SOURCE_DIR}/src/memory.cpp"
 "${LIBCXX_SOURCE_DIR}/src/mutex.cpp"
@@ -33,6 +35,9 @@ set(SRCS
 "${LIBCXX_SOURCE_DIR}/src/random.cpp"
 "${LIBCXX_SOURCE_DIR}/src/random_shuffle.cpp"
 "${LIBCXX_SOURCE_DIR}/src/regex.cpp"
+"${LIBCXX_SOURCE_DIR}/src/ryu/d2fixed.cpp"
+"${LIBCXX_SOURCE_DIR}/src/ryu/d2s.cpp"
+"${LIBCXX_SOURCE_DIR}/src/ryu/f2s.cpp"
 "${LIBCXX_SOURCE_DIR}/src/shared_mutex.cpp"
 "${LIBCXX_SOURCE_DIR}/src/stdexcept.cpp"
 "${LIBCXX_SOURCE_DIR}/src/string.cpp"
@@ -49,7 +54,9 @@ set(SRCS
 add_library(cxx ${SRCS})
 set_target_properties(cxx PROPERTIES FOLDER "contrib/libcxx-cmake")
 
-target_include_directories(cxx SYSTEM BEFORE PUBLIC $<BUILD_INTERFACE:${LIBCXX_SOURCE_DIR}/include>)
+target_include_directories(cxx SYSTEM BEFORE PUBLIC
+        $<BUILD_INTERFACE:${LIBCXX_SOURCE_DIR}/include>
+        $<BUILD_INTERFACE:${LIBCXX_SOURCE_DIR}>/src)
 target_compile_definitions(cxx PRIVATE -D_LIBCPP_BUILDING_LIBRARY -DLIBCXX_BUILDING_LIBCXXABI)
 
 # Enable capturing stack traces for all exceptions.
@@ -71,6 +78,9 @@ target_compile_options(cxx PUBLIC $<$<COMPILE_LANGUAGE:CXX>:-nostdinc++>)
 # Third party library may have substandard code.
 target_compile_options(cxx PRIVATE -w)
 
+# Enable support for Clang-Thread-Safety-Analysis in libcxx
+target_compile_definitions(cxx PUBLIC -D_LIBCPP_ENABLE_THREAD_SAFETY_ANNOTATIONS)
+
 target_link_libraries(cxx PUBLIC cxxabi)
 
 # For __udivmodti4, __divmodti4.
diff --git a/src/Access/Common/AccessType.h b/src/Access/Common/AccessType.h
index 43a6e0cf74..dad84dd855 100644
--- a/src/Access/Common/AccessType.h
+++ b/src/Access/Common/AccessType.h
@@ -167,6 +167,7 @@ enum class AccessType
     M(SYSTEM_SYNC_REPLICA, "SYNC REPLICA", TABLE, SYSTEM) \
     M(SYSTEM_RESTART_REPLICA, "RESTART REPLICA", TABLE, SYSTEM) \
     M(SYSTEM_RESTORE_REPLICA, "RESTORE REPLICA", TABLE, SYSTEM) \
+    M(SYSTEM_SYNC_TRANSACTION_LOG, "SYNC TRANSACTION LOG", GLOBAL, SYSTEM) \
     M(SYSTEM_FLUSH_DISTRIBUTED, "FLUSH DISTRIBUTED", TABLE, SYSTEM_FLUSH) \
     M(SYSTEM_FLUSH_LOGS, "FLUSH LOGS", GLOBAL, SYSTEM_FLUSH) \
     M(SYSTEM_FLUSH, "", GROUP, SYSTEM) \
diff --git a/src/Client/ClientBase.cpp b/src/Client/ClientBase.cpp
index c187222bb1..99534ae701 100644
--- a/src/Client/ClientBase.cpp
+++ b/src/Client/ClientBase.cpp
@@ -220,7 +220,7 @@ static void incrementProfileEventsBlock(Block & dst, const Block & src)
 }
 
 
-std::atomic_flag exit_on_signal = ATOMIC_FLAG_INIT;
+std::atomic_flag exit_on_signal;
 
 class QueryInterruptHandler : private boost::noncopyable
 {
@@ -1182,6 +1182,7 @@ void ClientBase::sendDataFrom(ReadBuffer & buf, Block & sample, const ColumnsDes
 }
 
 void ClientBase::sendDataFromPipe(Pipe&& pipe, ASTPtr parsed_query)
+try
 {
     QueryPipeline pipeline(std::move(pipe));
     PullingAsyncPipelineExecutor executor(pipeline);
@@ -1213,7 +1214,12 @@ void ClientBase::sendDataFromPipe(Pipe&& pipe, ASTPtr parsed_query)
 
     connection->sendData({}, "", false);
 }
-
+catch(...)
+{
+    connection->sendCancel();
+    receiveEndOfQuery();
+    throw;
+}
 
 /// Process Log packets, used when inserting data by blocks
 void ClientBase::receiveLogs(ASTPtr parsed_query)
diff --git a/src/Common/ErrorCodes.cpp b/src/Common/ErrorCodes.cpp
index 25b46bec80..3a4af17cfc 100644
--- a/src/Common/ErrorCodes.cpp
+++ b/src/Common/ErrorCodes.cpp
@@ -623,7 +623,7 @@
     M(648, UNKNOWN_CONNECTION) \
     M(649, INVALID_TRANSACTION) \
     M(650, SERIALIZATION_ERROR)  \
-    \
+    M(659, UNKNOWN_STATUS_OF_TRANSACTION) \
     M(999, KEEPER_EXCEPTION) \
     M(1000, POCO_EXCEPTION) \
     M(1001, STD_EXCEPTION) \
diff --git a/src/Common/ErrorCodes.h b/src/Common/ErrorCodes.h
index 4d5fa632e4..8879779a5e 100644
--- a/src/Common/ErrorCodes.h
+++ b/src/Common/ErrorCodes.h
@@ -6,6 +6,7 @@
 #include <mutex>
 #include <string_view>
 #include <vector>
+#include <base/defines.h>
 #include <base/types.h>
 
 /** Allows to count number of simultaneously happening error codes.
@@ -57,7 +58,7 @@ namespace ErrorCodes
         void increment(bool remote, const std::string & message, const FramePointers & trace);
 
     private:
-        ErrorPair value;
+        ErrorPair value TSA_GUARDED_BY(mutex);
         std::mutex mutex;
     };
 
diff --git a/src/Common/Exception.cpp b/src/Common/Exception.cpp
index 8ba9ac782c..976a099175 100644
--- a/src/Common/Exception.cpp
+++ b/src/Common/Exception.cpp
@@ -35,6 +35,18 @@ namespace ErrorCodes
     extern const int CANNOT_MREMAP;
 }
 
+void abortOnFailedAssertion(const String & description)
+{
+    LOG_FATAL(&Poco::Logger::root(), "Logical error: '{}'.", description);
+
+    /// This is to suppress -Wmissing-noreturn
+    volatile bool always_false = false;
+    if (always_false)
+        return;
+
+    abort();
+}
+
 /// - Aborts the process if error code is LOGICAL_ERROR.
 /// - Increments error codes statistics.
 void handle_error_code([[maybe_unused]] const std::string & msg, int code, bool remote, const Exception::FramePointers & trace)
@@ -44,8 +56,7 @@ void handle_error_code([[maybe_unused]] const std::string & msg, int code, bool
 #ifdef ABORT_ON_LOGICAL_ERROR
     if (code == ErrorCodes::LOGICAL_ERROR)
     {
-        LOG_FATAL(&Poco::Logger::root(), "Logical error: '{}'.", msg);
-        abort();
+        abortOnFailedAssertion(msg);
     }
 #endif
 
diff --git a/src/Common/Exception.h b/src/Common/Exception.h
index 0bf89e7a44..5d7bc02b59 100644
--- a/src/Common/Exception.h
+++ b/src/Common/Exception.h
@@ -21,6 +21,8 @@ namespace Poco { class Logger; }
 namespace DB
 {
 
+void abortOnFailedAssertion(const String & description);
+
 class Exception : public Poco::Exception
 {
 public:
diff --git a/src/Common/GetPriorityForLoadBalancing.cpp b/src/Common/GetPriorityForLoadBalancing.cpp
new file mode 100644
index 0000000000..d8e7566e89
--- /dev/null
+++ b/src/Common/GetPriorityForLoadBalancing.cpp
@@ -0,0 +1,49 @@
+#include <Common/GetPriorityForLoadBalancing.h>
+
+namespace DB
+{
+
+namespace ErrorCodes
+{
+    extern const int LOGICAL_ERROR;
+}
+
+std::function<size_t(size_t index)> GetPriorityForLoadBalancing::getPriorityFunc(LoadBalancing load_balance, size_t offset, size_t pool_size) const
+{
+    std::function<size_t(size_t index)> get_priority;
+    switch (load_balance)
+    {
+        case LoadBalancing::NEAREST_HOSTNAME:
+            if (hostname_differences.empty())
+                throw Exception(ErrorCodes::LOGICAL_ERROR, "It's a bug: hostname_differences is not initialized");
+            get_priority = [&](size_t i) { return hostname_differences[i]; };
+            break;
+        case LoadBalancing::IN_ORDER:
+            get_priority = [](size_t i) { return i; };
+            break;
+        case LoadBalancing::RANDOM:
+            break;
+        case LoadBalancing::FIRST_OR_RANDOM:
+            get_priority = [offset](size_t i) -> size_t { return i != offset; };
+            break;
+        case LoadBalancing::ROUND_ROBIN:
+            if (last_used >= pool_size)
+                last_used = 0;
+            ++last_used;
+            /* Consider pool_size equals to 5
+             * last_used = 1 -> get_priority: 0 1 2 3 4
+             * last_used = 2 -> get_priority: 4 0 1 2 3
+             * last_used = 3 -> get_priority: 4 3 0 1 2
+             * ...
+             * */
+            get_priority = [&](size_t i)
+            {
+                ++i;
+                return i < last_used ? pool_size - i : i - last_used;
+            };
+            break;
+    }
+    return get_priority;
+}
+
+}
diff --git a/src/Common/GetPriorityForLoadBalancing.h b/src/Common/GetPriorityForLoadBalancing.h
new file mode 100644
index 0000000000..e57b02b5e9
--- /dev/null
+++ b/src/Common/GetPriorityForLoadBalancing.h
@@ -0,0 +1,34 @@
+#pragma once
+
+#include <Core/SettingsEnums.h>
+
+namespace DB
+{
+
+class GetPriorityForLoadBalancing
+{
+public:
+    GetPriorityForLoadBalancing(LoadBalancing load_balancing_) : load_balancing(load_balancing_) {}
+    GetPriorityForLoadBalancing(){}
+
+    bool operator == (const GetPriorityForLoadBalancing & other) const
+    {
+        return load_balancing == other.load_balancing && hostname_differences == other.hostname_differences;
+    }
+
+    bool operator != (const GetPriorityForLoadBalancing & other) const
+    {
+        return !(*this == other);
+    }
+
+    std::function<size_t(size_t index)> getPriorityFunc(LoadBalancing load_balance, size_t offset, size_t pool_size) const;
+
+    std::vector<size_t> hostname_differences; /// Distances from name of this host to the names of hosts of pools.
+
+    LoadBalancing load_balancing = LoadBalancing::RANDOM;
+
+private:
+    mutable size_t last_used = 0; /// Last used for round_robin policy.
+};
+
+}
diff --git a/src/Common/ProfileEvents.cpp b/src/Common/ProfileEvents.cpp
index b2db06abc1..eea90c165e 100644
--- a/src/Common/ProfileEvents.cpp
+++ b/src/Common/ProfileEvents.cpp
@@ -120,6 +120,7 @@
     M(ZooKeeperSet, "") \
     M(ZooKeeperMulti, "") \
     M(ZooKeeperCheck, "") \
+    M(ZooKeeperSync, "") \
     M(ZooKeeperClose, "") \
     M(ZooKeeperWatchResponse, "") \
     M(ZooKeeperUserExceptions, "") \
diff --git a/src/Common/ZooKeeper/IKeeper.cpp b/src/Common/ZooKeeper/IKeeper.cpp
index 70fe33b3f6..23d29ed301 100644
--- a/src/Common/ZooKeeper/IKeeper.cpp
+++ b/src/Common/ZooKeeper/IKeeper.cpp
@@ -144,6 +144,7 @@ void ListRequest::addRootPath(const String & root_path) { Coordination::addRootP
 void CheckRequest::addRootPath(const String & root_path) { Coordination::addRootPath(path, root_path); }
 void SetACLRequest::addRootPath(const String & root_path) { Coordination::addRootPath(path, root_path); }
 void GetACLRequest::addRootPath(const String & root_path) { Coordination::addRootPath(path, root_path); }
+void SyncRequest::addRootPath(const String & root_path) { Coordination::addRootPath(path, root_path); }
 
 void MultiRequest::addRootPath(const String & root_path)
 {
diff --git a/src/Common/ZooKeeper/IKeeper.h b/src/Common/ZooKeeper/IKeeper.h
index 1e6239a7fa..c6aa954688 100644
--- a/src/Common/ZooKeeper/IKeeper.h
+++ b/src/Common/ZooKeeper/IKeeper.h
@@ -2,6 +2,7 @@
 
 #include <base/types.h>
 #include <Common/Exception.h>
+#include <Coordination/KeeperConstants.h>
 
 #include <vector>
 #include <memory>
@@ -34,23 +35,31 @@ struct ACL
     int32_t permissions;
     String scheme;
     String id;
+
+    bool operator<(const ACL & other) const
+    {
+        return std::tuple(permissions, scheme, id)
+            < std::tuple(other.permissions, other.scheme, other.id);
+    }
 };
 
 using ACLs = std::vector<ACL>;
 
 struct Stat
 {
-    int64_t czxid;
-    int64_t mzxid;
-    int64_t ctime;
-    int64_t mtime;
-    int32_t version;
-    int32_t cversion;
-    int32_t aversion;
-    int64_t ephemeralOwner; /// NOLINT
-    int32_t dataLength; /// NOLINT
-    int32_t numChildren; /// NOLINT
-    int64_t pzxid;
+    int64_t czxid{0};
+    int64_t mzxid{0};
+    int64_t ctime{0};
+    int64_t mtime{0};
+    int32_t version{0};
+    int32_t cversion{0};
+    int32_t aversion{0};
+    int64_t ephemeralOwner{0}; /// NOLINT
+    int32_t dataLength{0}; /// NOLINT
+    int32_t numChildren{0}; /// NOLINT
+    int64_t pzxid{0};
+
+    bool operator==(const Stat &) const = default;
 };
 
 enum class Error : int32_t
@@ -103,7 +112,6 @@ bool isUserError(Error code);
 
 const char * errorMessage(Error code);
 
-
 struct Request;
 using RequestPtr = std::shared_ptr<Request>;
 using Requests = std::vector<RequestPtr>;
@@ -275,6 +283,13 @@ struct SetResponse : virtual Response
     size_t bytesSize() const override { return sizeof(stat); }
 };
 
+enum class ListRequestType : uint8_t
+{
+    ALL,
+    PERSISTENT_ONLY,
+    EPHEMERAL_ONLY
+};
+
 struct ListRequest : virtual Request
 {
     String path;
@@ -314,6 +329,23 @@ struct CheckResponse : virtual Response
 {
 };
 
+struct SyncRequest : virtual Request
+{
+    String path;
+
+    void addRootPath(const String & root_path) override;
+    String getPath() const override { return path; }
+
+    size_t bytesSize() const override { return path.size(); }
+};
+
+struct SyncResponse : virtual Response
+{
+    String path;
+
+    size_t bytesSize() const override { return path.size(); }
+};
+
 struct MultiRequest : virtual Request
 {
     Requests requests;
@@ -358,6 +390,7 @@ using GetCallback = std::function<void(const GetResponse &)>;
 using SetCallback = std::function<void(const SetResponse &)>;
 using ListCallback = std::function<void(const ListResponse &)>;
 using CheckCallback = std::function<void(const CheckResponse &)>;
+using SyncCallback = std::function<void(const SyncResponse &)>;
 using MultiCallback = std::function<void(const MultiResponse &)>;
 
 
@@ -395,8 +428,8 @@ public:
     Exception(const Error code_, const std::string & path); /// NOLINT
     Exception(const Exception & exc);
 
-    const char * name() const throw() override { return "Coordination::Exception"; }
-    const char * className() const throw() override { return "Coordination::Exception"; }
+    const char * name() const noexcept override { return "Coordination::Exception"; }
+    const char * className() const noexcept override { return "Coordination::Exception"; }
     Exception * clone() const override { return new Exception(*this); }
 
     const Error code;
@@ -468,6 +501,7 @@ public:
 
     virtual void list(
         const String & path,
+        ListRequestType list_request_type,
         ListCallback callback,
         WatchCallback watch) = 0;
 
@@ -476,10 +510,16 @@ public:
         int32_t version,
         CheckCallback callback) = 0;
 
+    virtual void sync(
+        const String & path,
+        SyncCallback callback) = 0;
+
     virtual void multi(
         const Requests & requests,
         MultiCallback callback) = 0;
 
+    virtual DB::KeeperApiVersion getApiVersion() = 0;
+
     /// Expire session and finish all pending requests
     virtual void finalize(const String & reason) = 0;
 };
diff --git a/src/Common/ZooKeeper/KeeperException.h b/src/Common/ZooKeeper/KeeperException.h
index 6498aca809..4442c41a19 100644
--- a/src/Common/ZooKeeper/KeeperException.h
+++ b/src/Common/ZooKeeper/KeeperException.h
@@ -24,9 +24,7 @@ public:
     static void check(Coordination::Error code, const Coordination::Requests & requests, const Coordination::Responses & responses);
 
     KeeperMultiException(Coordination::Error code, const Coordination::Requests & requests, const Coordination::Responses & responses);
-
-private:
-    static size_t getFailedOpIndex(Coordination::Error code, const Coordination::Responses & responses);
 };
 
+size_t getFailedOpIndex(Coordination::Error code, const Coordination::Responses & responses);
 }
diff --git a/src/Common/ZooKeeper/TestKeeper.cpp b/src/Common/ZooKeeper/TestKeeper.cpp
index 065b1cf65b..3af5dfcc17 100644
--- a/src/Common/ZooKeeper/TestKeeper.cpp
+++ b/src/Common/ZooKeeper/TestKeeper.cpp
@@ -1,3 +1,4 @@
+#include "Common/ZooKeeper/IKeeper.h"
 #include <Common/ZooKeeper/TestKeeper.h>
 #include <Common/setThreadName.h>
 #include <Common/StringUtils/StringUtils.h>
@@ -119,12 +120,17 @@ struct TestKeeperSetRequest final : SetRequest, TestKeeperRequest
     }
 };
 
-struct TestKeeperListRequest final : ListRequest, TestKeeperRequest
+struct TestKeeperListRequest : ListRequest, TestKeeperRequest
 {
     ResponsePtr createResponse() const override;
     std::pair<ResponsePtr, Undo> process(TestKeeper::Container & container, int64_t zxid) const override;
 };
 
+struct TestKeeperFilteredListRequest final : TestKeeperListRequest
+{
+    ListRequestType list_request_type;
+};
+
 struct TestKeeperCheckRequest final : CheckRequest, TestKeeperRequest
 {
     TestKeeperCheckRequest() = default;
@@ -133,6 +139,14 @@ struct TestKeeperCheckRequest final : CheckRequest, TestKeeperRequest
     std::pair<ResponsePtr, Undo> process(TestKeeper::Container & container, int64_t zxid) const override;
 };
 
+struct TestKeeperSyncRequest final : SyncRequest, TestKeeperRequest
+{
+    TestKeeperSyncRequest() = default;
+    explicit TestKeeperSyncRequest(const SyncRequest & base) : SyncRequest(base) {}
+    ResponsePtr createResponse() const override;
+    std::pair<ResponsePtr, Undo> process(TestKeeper::Container & container, int64_t zxid) const override;
+};
+
 struct TestKeeperMultiRequest final : MultiRequest, TestKeeperRequest
 {
     explicit TestKeeperMultiRequest(const Requests & generic_requests)
@@ -179,7 +193,7 @@ std::pair<ResponsePtr, Undo> TestKeeperCreateRequest::process(TestKeeper::Contai
     CreateResponse response;
     Undo undo;
 
-    if (container.count(path))
+    if (container.contains(path))
     {
         response.error = Error::ZNODEEXISTS;
     }
@@ -382,8 +396,18 @@ std::pair<ResponsePtr, Undo> TestKeeperListRequest::process(TestKeeper::Containe
              child_it != container.end() && startsWith(child_it->first, path_prefix);
             ++child_it)
         {
+            using enum ListRequestType;
             if (parentPath(child_it->first) == path)
-                response.names.emplace_back(baseName(child_it->first));
+            {
+                ListRequestType list_request_type = ALL;
+                if (const auto * filtered_list = dynamic_cast<const TestKeeperFilteredListRequest *>(this))
+                    list_request_type = filtered_list->list_request_type;
+
+                const auto is_ephemeral = child_it->second.stat.ephemeralOwner != 0;
+                if (list_request_type == ALL || (is_ephemeral && list_request_type == EPHEMERAL_ONLY)
+                    || (!is_ephemeral && list_request_type == PERSISTENT_ONLY))
+                    response.names.emplace_back(baseName(child_it->first));
+            }
         }
 
         response.stat = it->second.stat;
@@ -413,6 +437,14 @@ std::pair<ResponsePtr, Undo> TestKeeperCheckRequest::process(TestKeeper::Contain
     return { std::make_shared<CheckResponse>(response), {} };
 }
 
+std::pair<ResponsePtr, Undo> TestKeeperSyncRequest::process(TestKeeper::Container & /*container*/, int64_t) const
+{
+    SyncResponse response;
+    response.path = path;
+
+    return { std::make_shared<SyncResponse>(std::move(response)), {} };
+}
+
 std::pair<ResponsePtr, Undo> TestKeeperMultiRequest::process(TestKeeper::Container & container, int64_t zxid) const
 {
     MultiResponse response;
@@ -471,6 +503,7 @@ ResponsePtr TestKeeperGetRequest::createResponse() const { return std::make_shar
 ResponsePtr TestKeeperSetRequest::createResponse() const { return std::make_shared<SetResponse>(); }
 ResponsePtr TestKeeperListRequest::createResponse() const { return std::make_shared<ListResponse>(); }
 ResponsePtr TestKeeperCheckRequest::createResponse() const { return std::make_shared<CheckResponse>(); }
+ResponsePtr TestKeeperSyncRequest::createResponse() const { return std::make_shared<SyncResponse>(); }
 ResponsePtr TestKeeperMultiRequest::createResponse() const { return std::make_shared<MultiResponse>(); }
 
 
@@ -514,7 +547,7 @@ void TestKeeper::processingThread()
         {
             RequestInfo info;
 
-            UInt64 max_wait = UInt64(operation_timeout.totalMilliseconds());
+            UInt64 max_wait = static_cast<UInt64>(operation_timeout.totalMilliseconds());
             if (requests_queue.tryPop(info, max_wait))
             {
                 if (expired)
@@ -751,11 +784,13 @@ void TestKeeper::set(
 
 void TestKeeper::list(
         const String & path,
+        ListRequestType list_request_type,
         ListCallback callback,
         WatchCallback watch)
 {
-    TestKeeperListRequest request;
+    TestKeeperFilteredListRequest request;
     request.path = path;
+    request.list_request_type = list_request_type;
 
     RequestInfo request_info;
     request_info.request = std::make_shared<TestKeeperListRequest>(std::move(request));
@@ -779,6 +814,19 @@ void TestKeeper::check(
     pushRequest(std::move(request_info));
 }
 
+void TestKeeper::sync(
+        const String & path,
+        SyncCallback callback)
+{
+    TestKeeperSyncRequest request;
+    request.path = path;
+
+    RequestInfo request_info;
+    request_info.request = std::make_shared<TestKeeperSyncRequest>(std::move(request));
+    request_info.callback = [callback](const Response & response) { callback(dynamic_cast<const SyncResponse &>(response)); };
+    pushRequest(std::move(request_info));
+}
+
 void TestKeeper::multi(
         const Requests & requests,
         MultiCallback callback)
diff --git a/src/Common/ZooKeeper/TestKeeper.h b/src/Common/ZooKeeper/TestKeeper.h
index e57471341e..5fcd00b01b 100644
--- a/src/Common/ZooKeeper/TestKeeper.h
+++ b/src/Common/ZooKeeper/TestKeeper.h
@@ -71,6 +71,7 @@ public:
 
     void list(
             const String & path,
+            ListRequestType list_request_type,
             ListCallback callback,
             WatchCallback watch) override;
 
@@ -79,12 +80,21 @@ public:
             int32_t version,
             CheckCallback callback) override;
 
+    void sync(
+            const String & path,
+            SyncCallback callback) override;
+
     void multi(
             const Requests & requests,
             MultiCallback callback) override;
 
     void finalize(const String & reason) override;
 
+    DB::KeeperApiVersion getApiVersion() override
+    {
+        return KeeperApiVersion::ZOOKEEPER_COMPATIBLE;
+    }
+
     struct Node
     {
         String data;
diff --git a/src/Common/ZooKeeper/ZooKeeper.cpp b/src/Common/ZooKeeper/ZooKeeper.cpp
index 394938194e..2374df16b6 100644
--- a/src/Common/ZooKeeper/ZooKeeper.cpp
+++ b/src/Common/ZooKeeper/ZooKeeper.cpp
@@ -5,15 +5,17 @@
 
 #include <functional>
 #include <filesystem>
-#include <pcg-random/pcg_random.hpp>
 
-#include <base/logger_useful.h>
 #include <base/find_symbols.h>
-#include <Common/randomSeed.h>
+#include <base/sort.h>
+#include <base/getFQDNOrHostName.h>
+#include "Common/ZooKeeper/IKeeper.h"
 #include <Common/StringUtils/StringUtils.h>
 #include <Common/Exception.h>
+#include <Common/isLocalAddress.h>
 
 #include <Poco/Net/NetException.h>
+#include <Poco/Net/DNS.h>
 
 
 #define ZOOKEEPER_CONNECTION_TIMEOUT_MS 1000
@@ -48,7 +50,7 @@ static void check(Coordination::Error code, const std::string & path)
 
 
 void ZooKeeper::init(const std::string & implementation_, const Strings & hosts_, const std::string & identity_,
-                     int32_t session_timeout_ms_, int32_t operation_timeout_ms_, const std::string & chroot_)
+                     int32_t session_timeout_ms_, int32_t operation_timeout_ms_, const std::string & chroot_, const GetPriorityForLoadBalancing & get_priority_load_balancing_)
 {
     log = &Poco::Logger::get("ZooKeeper");
     hosts = hosts_;
@@ -57,6 +59,7 @@ void ZooKeeper::init(const std::string & implementation_, const Strings & hosts_
     operation_timeout_ms = operation_timeout_ms_;
     chroot = chroot_;
     implementation = implementation_;
+    get_priority_load_balancing = get_priority_load_balancing_;
 
     if (implementation == "zookeeper")
     {
@@ -66,21 +69,21 @@ void ZooKeeper::init(const std::string & implementation_, const Strings & hosts_
         Coordination::ZooKeeper::Nodes nodes;
         nodes.reserve(hosts.size());
 
-        Strings shuffled_hosts = hosts;
         /// Shuffle the hosts to distribute the load among ZooKeeper nodes.
-        pcg64 generator(randomSeed());
-        std::shuffle(shuffled_hosts.begin(), shuffled_hosts.end(), generator);
+        std::vector<ShuffleHost> shuffled_hosts = shuffleHosts();
 
         bool dns_error = false;
-        for (auto & host_string : shuffled_hosts)
+        for (auto & host : shuffled_hosts)
         {
+            auto & host_string = host.host;
             try
             {
-                bool secure = bool(startsWith(host_string, "secure://"));
+                bool secure = startsWith(host_string, "secure://");
 
                 if (secure)
                     host_string.erase(0, strlen("secure://"));
 
+                LOG_TEST(log, "Adding ZooKeeper host {} ({})", host_string, Poco::Net::SocketAddress{host_string}.toString());
                 nodes.emplace_back(Coordination::ZooKeeper::Node{Poco::Net::SocketAddress{host_string}, secure});
             }
             catch (const Poco::Net::HostNotFoundException & e)
@@ -154,23 +157,47 @@ void ZooKeeper::init(const std::string & implementation_, const Strings & hosts_
     }
 }
 
+std::vector<ShuffleHost> ZooKeeper::shuffleHosts() const
+{
+    std::function<size_t(size_t index)> get_priority = get_priority_load_balancing.getPriorityFunc(get_priority_load_balancing.load_balancing, 0, hosts.size());
+    std::vector<ShuffleHost> shuffle_hosts;
+    for (size_t i = 0; i < hosts.size(); ++i)
+    {
+        ShuffleHost shuffle_host;
+        shuffle_host.host = hosts[i];
+        if (get_priority)
+            shuffle_host.priority = get_priority(i);
+        shuffle_host.randomize();
+        shuffle_hosts.emplace_back(shuffle_host);
+    }
+
+    ::sort(
+        shuffle_hosts.begin(), shuffle_hosts.end(),
+        [](const ShuffleHost & lhs, const ShuffleHost & rhs)
+        {
+            return ShuffleHost::compare(lhs, rhs);
+        });
+
+    return shuffle_hosts;
+}
+
 ZooKeeper::ZooKeeper(const std::string & hosts_string, const std::string & identity_, int32_t session_timeout_ms_,
                      int32_t operation_timeout_ms_, const std::string & chroot_, const std::string & implementation_,
-                     std::shared_ptr<DB::ZooKeeperLog> zk_log_)
+                     std::shared_ptr<DB::ZooKeeperLog> zk_log_, const GetPriorityForLoadBalancing & get_priority_load_balancing_)
 {
     zk_log = std::move(zk_log_);
     Strings hosts_strings;
     splitInto<','>(hosts_strings, hosts_string);
 
-    init(implementation_, hosts_strings, identity_, session_timeout_ms_, operation_timeout_ms_, chroot_);
+    init(implementation_, hosts_strings, identity_, session_timeout_ms_, operation_timeout_ms_, chroot_, get_priority_load_balancing_);
 }
 
 ZooKeeper::ZooKeeper(const Strings & hosts_, const std::string & identity_, int32_t session_timeout_ms_,
                      int32_t operation_timeout_ms_, const std::string & chroot_, const std::string & implementation_,
-                     std::shared_ptr<DB::ZooKeeperLog> zk_log_)
+                     std::shared_ptr<DB::ZooKeeperLog> zk_log_, const GetPriorityForLoadBalancing & get_priority_load_balancing_)
 {
     zk_log = std::move(zk_log_);
-    init(implementation_, hosts_, identity_, session_timeout_ms_, operation_timeout_ms_, chroot_);
+    init(implementation_, hosts_, identity_, session_timeout_ms_, operation_timeout_ms_, chroot_, get_priority_load_balancing_);
 }
 
 struct ZooKeeperArgs
@@ -188,9 +215,9 @@ struct ZooKeeperArgs
             if (startsWith(key, "node"))
             {
                 hosts.push_back(
-                        (config.getBool(config_name + "." + key + ".secure", false) ? "secure://" : "") +
-                        config.getString(config_name + "." + key + ".host") + ":"
-                        + config.getString(config_name + "." + key + ".port", "2181")
+                    (config.getBool(config_name + "." + key + ".secure", false) ? "secure://" : "") +
+                    config.getString(config_name + "." + key + ".host") + ":"
+                    + config.getString(config_name + "." + key + ".port", "2181")
                 );
             }
             else if (key == "session_timeout_ms")
@@ -213,6 +240,15 @@ struct ZooKeeperArgs
             {
                 implementation = config.getString(config_name + "." + key);
             }
+            else if (key == "zookeeper_load_balancing")
+            {
+                String load_balancing_str = config.getString(config_name + "." + key);
+                /// Use magic_enum to avoid dependency from dbms (`SettingFieldLoadBalancingTraits::fromString(...)`)
+                auto load_balancing = magic_enum::enum_cast<DB::LoadBalancing>(Poco::toUpper(load_balancing_str));
+                if (!load_balancing)
+                    throw DB::Exception(DB::ErrorCodes::BAD_ARGUMENTS, "Unknown load balancing: {}", load_balancing_str);
+                get_priority_load_balancing.load_balancing = *load_balancing;
+            }
             else
                 throw KeeperException(std::string("Unknown key ") + key + " in config file", Coordination::Error::ZBADARGUMENTS);
         }
@@ -224,6 +260,15 @@ struct ZooKeeperArgs
             if (chroot.back() == '/')
                 chroot.pop_back();
         }
+
+        /// init get_priority_load_balancing
+        get_priority_load_balancing.hostname_differences.resize(hosts.size());
+        const String & local_hostname = getFQDNOrHostName();
+        for (size_t i = 0; i < hosts.size(); ++i)
+        {
+            const String & node_host = hosts[i].substr(0, hosts[i].find_last_of(':'));
+            get_priority_load_balancing.hostname_differences[i] = DB::getHostNameDifference(local_hostname, node_host);
+        }
     }
 
     Strings hosts;
@@ -232,13 +277,14 @@ struct ZooKeeperArgs
     int operation_timeout_ms;
     std::string chroot;
     std::string implementation;
+    GetPriorityForLoadBalancing get_priority_load_balancing;
 };
 
 ZooKeeper::ZooKeeper(const Poco::Util::AbstractConfiguration & config, const std::string & config_name, std::shared_ptr<DB::ZooKeeperLog> zk_log_)
     : zk_log(std::move(zk_log_))
 {
     ZooKeeperArgs args(config, config_name);
-    init(args.implementation, args.hosts, args.identity, args.session_timeout_ms, args.operation_timeout_ms, args.chroot);
+    init(args.implementation, args.hosts, args.identity, args.session_timeout_ms, args.operation_timeout_ms, args.chroot, args.get_priority_load_balancing);
 }
 
 bool ZooKeeper::configChanged(const Poco::Util::AbstractConfiguration & config, const std::string & config_name) const
@@ -249,8 +295,11 @@ bool ZooKeeper::configChanged(const Poco::Util::AbstractConfiguration & config,
     if (args.implementation == implementation && implementation == "testkeeper")
         return false;
 
-    return std::tie(args.implementation, args.hosts, args.identity, args.session_timeout_ms, args.operation_timeout_ms, args.chroot)
-        != std::tie(implementation, hosts, identity, session_timeout_ms, operation_timeout_ms, chroot);
+    if (args.get_priority_load_balancing != get_priority_load_balancing)
+        return true;
+
+    return std::tie(args.implementation, args.hosts, args.identity, args.session_timeout_ms, args.operation_timeout_ms, args.chroot, args.get_priority_load_balancing)
+        != std::tie(implementation, hosts, identity, session_timeout_ms, operation_timeout_ms, chroot, args.get_priority_load_balancing);
 }
 
 
@@ -263,10 +312,11 @@ static Coordination::WatchCallback callbackForEvent(const EventPtr & watch)
 
 
 Coordination::Error ZooKeeper::getChildrenImpl(const std::string & path, Strings & res,
-                                   Coordination::Stat * stat,
-                                   Coordination::WatchCallback watch_callback)
+                                               Coordination::Stat * stat,
+                                               Coordination::WatchCallback watch_callback,
+                                               Coordination::ListRequestType list_request_type)
 {
-    auto future_result = asyncTryGetChildrenNoThrow(path, watch_callback);
+    auto future_result = asyncTryGetChildrenNoThrow(path, watch_callback, list_request_type);
 
     if (future_result.wait_for(std::chrono::milliseconds(operation_timeout_ms)) != std::future_status::ready)
     {
@@ -287,26 +337,28 @@ Coordination::Error ZooKeeper::getChildrenImpl(const std::string & path, Strings
     }
 }
 
-Strings ZooKeeper::getChildren(
-        const std::string & path, Coordination::Stat * stat, const EventPtr & watch)
+Strings ZooKeeper::getChildren(const std::string & path, Coordination::Stat * stat, const EventPtr & watch, Coordination::ListRequestType list_request_type)
 {
     Strings res;
-    check(tryGetChildren(path, res, stat, watch), path);
+    check(tryGetChildren(path, res, stat, watch, list_request_type), path);
     return res;
 }
 
-Strings ZooKeeper::getChildrenWatch(
-        const std::string & path, Coordination::Stat * stat, Coordination::WatchCallback watch_callback)
+Strings ZooKeeper::getChildrenWatch(const std::string & path, Coordination::Stat * stat, Coordination::WatchCallback watch_callback, Coordination::ListRequestType list_request_type)
 {
     Strings res;
-    check(tryGetChildrenWatch(path, res, stat, watch_callback), path);
+    check(tryGetChildrenWatch(path, res, stat, watch_callback, list_request_type), path);
     return res;
 }
 
-Coordination::Error ZooKeeper::tryGetChildren(const std::string & path, Strings & res,
-                                  Coordination::Stat * stat, const EventPtr & watch)
+Coordination::Error ZooKeeper::tryGetChildren(
+    const std::string & path,
+    Strings & res,
+    Coordination::Stat * stat,
+    const EventPtr & watch,
+    Coordination::ListRequestType list_request_type)
 {
-    Coordination::Error code = getChildrenImpl(path, res, stat, callbackForEvent(watch));
+    Coordination::Error code = getChildrenImpl(path, res, stat, callbackForEvent(watch), list_request_type);
 
     if (!(code == Coordination::Error::ZOK || code == Coordination::Error::ZNONODE))
         throw KeeperException(code, path);
@@ -314,10 +366,14 @@ Coordination::Error ZooKeeper::tryGetChildren(const std::string & path, Strings
     return code;
 }
 
-Coordination::Error ZooKeeper::tryGetChildrenWatch(const std::string & path, Strings & res,
-                                       Coordination::Stat * stat, Coordination::WatchCallback watch_callback)
+Coordination::Error ZooKeeper::tryGetChildrenWatch(
+    const std::string & path,
+    Strings & res,
+    Coordination::Stat * stat,
+    Coordination::WatchCallback watch_callback,
+    Coordination::ListRequestType list_request_type)
 {
-    Coordination::Error code = getChildrenImpl(path, res, stat, watch_callback);
+    Coordination::Error code = getChildrenImpl(path, res, stat, watch_callback, list_request_type);
 
     if (!(code == Coordination::Error::ZOK || code == Coordination::Error::ZNONODE))
         throw KeeperException(code, path);
@@ -484,7 +540,6 @@ Coordination::Error ZooKeeper::getImpl(const std::string & path, std::string & r
     }
 }
 
-
 std::string ZooKeeper::get(const std::string & path, Coordination::Stat * stat, const EventPtr & watch)
 {
     Coordination::Error code = Coordination::Error::ZOK;
@@ -534,7 +589,7 @@ bool ZooKeeper::tryGetWatch(
 }
 
 Coordination::Error ZooKeeper::setImpl(const std::string & path, const std::string & data,
-                           int32_t version, Coordination::Stat * stat)
+                                       int32_t version, Coordination::Stat * stat)
 {
     auto future_result = asyncTrySetNoThrow(path, data, version);
 
@@ -571,7 +626,7 @@ void ZooKeeper::createOrUpdate(const std::string & path, const std::string & dat
 }
 
 Coordination::Error ZooKeeper::trySet(const std::string & path, const std::string & data,
-                          int32_t version, Coordination::Stat * stat)
+                                      int32_t version, Coordination::Stat * stat)
 {
     Coordination::Error code = setImpl(path, data, version, stat);
 
@@ -620,6 +675,34 @@ Coordination::Error ZooKeeper::tryMulti(const Coordination::Requests & requests,
     return code;
 }
 
+Coordination::Error ZooKeeper::syncImpl(const std::string & path, std::string & returned_path)
+{
+    auto future_result = asyncTrySyncNoThrow(path);
+
+    if (future_result.wait_for(std::chrono::milliseconds(operation_timeout_ms)) != std::future_status::ready)
+    {
+        impl->finalize(fmt::format("Operation timeout on {} {}", toString(Coordination::OpNum::Sync), path));
+        return Coordination::Error::ZOPERATIONTIMEOUT;
+    }
+    else
+    {
+        auto response = future_result.get();
+        Coordination::Error code = response.error;
+        returned_path = std::move(response.path);
+        return code;
+    }
+}
+std::string ZooKeeper::sync(const std::string & path)
+{
+    std::string returned_path;
+    check(syncImpl(path, returned_path), path);
+    return returned_path;
+}
+
+Coordination::Error ZooKeeper::trySync(const std::string & path, std::string & returned_path)
+{
+    return syncImpl(path, returned_path);
+}
 
 void ZooKeeper::removeChildren(const std::string & path)
 {
@@ -654,24 +737,34 @@ void ZooKeeper::removeChildrenRecursive(const std::string & path, const String &
     }
 }
 
-void ZooKeeper::tryRemoveChildrenRecursive(const std::string & path, const String & keep_child_node)
+bool ZooKeeper::tryRemoveChildrenRecursive(const std::string & path, bool probably_flat, const String & keep_child_node)
 {
     Strings children;
     if (tryGetChildren(path, children) != Coordination::Error::ZOK)
-        return;
+        return false;
+
+    bool removed_as_expected = true;
     while (!children.empty())
     {
         Coordination::Requests ops;
         Strings batch;
+        ops.reserve(MULTI_BATCH_SIZE);
+        batch.reserve(MULTI_BATCH_SIZE);
         for (size_t i = 0; i < MULTI_BATCH_SIZE && !children.empty(); ++i)
         {
             String child_path = fs::path(path) / children.back();
-            tryRemoveChildrenRecursive(child_path);
+
+            /// Will try to avoid recursive getChildren calls if child_path probably has no children.
+            /// It may be extremely slow when path contain a lot of leaf children.
+            if (!probably_flat)
+                tryRemoveChildrenRecursive(child_path);
+
             if (likely(keep_child_node.empty() || keep_child_node != children.back()))
             {
                 batch.push_back(child_path);
                 ops.emplace_back(zkutil::makeRemoveRequest(child_path, -1));
             }
+
             children.pop_back();
         }
 
@@ -679,10 +772,39 @@ void ZooKeeper::tryRemoveChildrenRecursive(const std::string & path, const Strin
         /// this means someone is concurrently removing these children and we will have
         /// to remove them one by one.
         Coordination::Responses responses;
-        if (tryMulti(ops, responses) != Coordination::Error::ZOK)
-            for (const std::string & child : batch)
-                tryRemove(child);
+        if (tryMulti(ops, responses) == Coordination::Error::ZOK)
+            continue;
+
+        removed_as_expected = false;
+
+        std::vector<zkutil::ZooKeeper::FutureRemove> futures;
+        futures.reserve(batch.size());
+        for (const std::string & child : batch)
+            futures.push_back(asyncTryRemoveNoThrow(child, -1));
+
+        for (size_t i = 0; i < batch.size(); ++i)
+        {
+            auto res = futures[i].get();
+            if (res.error == Coordination::Error::ZOK)
+                continue;
+            if (res.error == Coordination::Error::ZNONODE)
+                continue;
+
+            if (res.error == Coordination::Error::ZNOTEMPTY)
+            {
+                if (probably_flat)
+                {
+                    /// It actually has children, let's remove them
+                    tryRemoveChildrenRecursive(batch[i]);
+                    tryRemove(batch[i]);
+                }
+                continue;
+            }
+
+            throw KeeperException(res.error, batch[i]);
+        }
     }
+    return removed_as_expected;
 }
 
 void ZooKeeper::removeRecursive(const std::string & path)
@@ -715,7 +837,7 @@ bool ZooKeeper::waitForDisappear(const std::string & path, const WaitCondition &
 
     auto callback = [state](const Coordination::GetResponse & response)
     {
-        state->code = int32_t(response.error);
+        state->code = static_cast<int32_t>(response.error);
         if (state->code)
             state->event.set();
     };
@@ -724,7 +846,7 @@ bool ZooKeeper::waitForDisappear(const std::string & path, const WaitCondition &
     {
         if (!state->code)
         {
-            state->code = int32_t(response.error);
+            state->code = static_cast<int32_t>(response.error);
             if (!state->code)
                 state->event_type = response.type;
             state->event.set();
@@ -742,7 +864,7 @@ bool ZooKeeper::waitForDisappear(const std::string & path, const WaitCondition &
         if (!state->event.tryWait(1000))
             continue;
 
-        if (state->code == int32_t(Coordination::Error::ZNONODE))
+        if (state->code == static_cast<int32_t>(Coordination::Error::ZNONODE))
             return true;
 
         if (state->code)
@@ -755,9 +877,24 @@ bool ZooKeeper::waitForDisappear(const std::string & path, const WaitCondition &
     return false;
 }
 
+void ZooKeeper::waitForEphemeralToDisappearIfAny(const std::string & path)
+{
+    zkutil::EventPtr eph_node_disappeared = std::make_shared<Poco::Event>();
+    String content;
+    if (!tryGet(path, content, nullptr, eph_node_disappeared))
+        return;
+
+    int32_t timeout_ms = 3 * session_timeout_ms;
+    if (!eph_node_disappeared->tryWait(timeout_ms))
+        throw DB::Exception(DB::ErrorCodes::LOGICAL_ERROR,
+                            "Ephemeral node {} still exists after {}s, probably it's owned by someone else. "
+                            "Either session_timeout_ms in client's config is different from server's config or it's a bug. "
+                            "Node data: '{}'", path, timeout_ms / 1000, content);
+}
+
 ZooKeeperPtr ZooKeeper::startNewSession() const
 {
-    return std::make_shared<ZooKeeper>(hosts, identity, session_timeout_ms, operation_timeout_ms, chroot, implementation, zk_log);
+    return std::make_shared<ZooKeeper>(hosts, identity, session_timeout_ms, operation_timeout_ms, chroot, implementation, zk_log, get_priority_load_balancing);
 }
 
 
@@ -766,6 +903,11 @@ bool ZooKeeper::expired()
     return impl->isExpired();
 }
 
+DB::KeeperApiVersion ZooKeeper::getApiVersion()
+{
+    return impl->getApiVersion();
+}
+
 Int64 ZooKeeper::getClientID()
 {
     return impl->getSessionID();
@@ -916,7 +1058,8 @@ std::future<Coordination::SetResponse> ZooKeeper::asyncTrySetNoThrow(const std::
     return future;
 }
 
-std::future<Coordination::ListResponse> ZooKeeper::asyncGetChildren(const std::string & path, Coordination::WatchCallback watch_callback)
+std::future<Coordination::ListResponse> ZooKeeper::asyncGetChildren(
+    const std::string & path, Coordination::WatchCallback watch_callback, Coordination::ListRequestType list_request_type)
 {
     auto promise = std::make_shared<std::promise<Coordination::ListResponse>>();
     auto future = promise->get_future();
@@ -929,11 +1072,12 @@ std::future<Coordination::ListResponse> ZooKeeper::asyncGetChildren(const std::s
             promise->set_value(response);
     };
 
-    impl->list(path, std::move(callback), watch_callback);
+    impl->list(path, list_request_type, std::move(callback), watch_callback);
     return future;
 }
 
-std::future<Coordination::ListResponse> ZooKeeper::asyncTryGetChildrenNoThrow(const std::string & path, Coordination::WatchCallback watch_callback)
+std::future<Coordination::ListResponse> ZooKeeper::asyncTryGetChildrenNoThrow(
+    const std::string & path, Coordination::WatchCallback watch_callback, Coordination::ListRequestType list_request_type)
 {
     auto promise = std::make_shared<std::promise<Coordination::ListResponse>>();
     auto future = promise->get_future();
@@ -943,7 +1087,7 @@ std::future<Coordination::ListResponse> ZooKeeper::asyncTryGetChildrenNoThrow(co
         promise->set_value(response);
     };
 
-    impl->list(path, std::move(callback), watch_callback);
+    impl->list(path, list_request_type, std::move(callback), watch_callback);
     return future;
 }
 
@@ -1043,6 +1187,37 @@ Coordination::Error ZooKeeper::tryMultiNoThrow(const Coordination::Requests & re
     }
 }
 
+std::future<Coordination::SyncResponse> ZooKeeper::asyncTrySyncNoThrow(const std::string & path)
+{
+    auto promise = std::make_shared<std::promise<Coordination::SyncResponse>>();
+    auto future = promise->get_future();
+
+    auto callback = [promise](const Coordination::SyncResponse & response) mutable
+    {
+        promise->set_value(response);
+    };
+
+    impl->sync(path, std::move(callback));
+    return future;
+}
+
+std::future<Coordination::SyncResponse> ZooKeeper::asyncSync(const std::string & path)
+{
+    auto promise = std::make_shared<std::promise<Coordination::SyncResponse>>();
+    auto future = promise->get_future();
+
+    auto callback = [promise](const Coordination::SyncResponse & response) mutable
+    {
+        if (response.error != Coordination::Error::ZOK)
+            promise->set_exception(std::make_exception_ptr(KeeperException(response.error)));
+        else
+            promise->set_value(response);
+    };
+
+    impl->sync(path, std::move(callback));
+    return future;
+}
+
 void ZooKeeper::finalize(const String & reason)
 {
     impl->finalize(reason);
@@ -1056,7 +1231,7 @@ void ZooKeeper::setZooKeeperLog(std::shared_ptr<DB::ZooKeeperLog> zk_log_)
 }
 
 
-size_t KeeperMultiException::getFailedOpIndex(Coordination::Error exception_code, const Coordination::Responses & responses)
+size_t getFailedOpIndex(Coordination::Error exception_code, const Coordination::Responses & responses)
 {
     if (responses.empty())
         throw DB::Exception("Responses for multi transaction is empty", DB::ErrorCodes::LOGICAL_ERROR);
@@ -1074,8 +1249,8 @@ size_t KeeperMultiException::getFailedOpIndex(Coordination::Error exception_code
 
 
 KeeperMultiException::KeeperMultiException(Coordination::Error exception_code, const Coordination::Requests & requests_, const Coordination::Responses & responses_)
-        : KeeperException("Transaction failed", exception_code),
-          requests(requests_), responses(responses_), failed_op_index(getFailedOpIndex(exception_code, responses))
+    : KeeperException("Transaction failed", exception_code),
+    requests(requests_), responses(responses_), failed_op_index(getFailedOpIndex(exception_code, responses))
 {
     addMessage("Op #" + std::to_string(failed_op_index) + ", path: " + getPathForFirstFailedOp());
 }
diff --git a/src/Common/ZooKeeper/ZooKeeper.h b/src/Common/ZooKeeper/ZooKeeper.h
index 258afb2021..a49e83d949 100644
--- a/src/Common/ZooKeeper/ZooKeeper.h
+++ b/src/Common/ZooKeeper/ZooKeeper.h
@@ -13,7 +13,10 @@
 #include <Common/Stopwatch.h>
 #include <Common/ZooKeeper/IKeeper.h>
 #include <Common/ZooKeeper/ZooKeeperConstants.h>
+#include <Common/GetPriorityForLoadBalancing.h>
+#include <Common/thread_local_rng.h>
 #include <unistd.h>
+#include <random>
 
 
 namespace ProfileEvents
@@ -37,6 +40,25 @@ namespace zkutil
 /// Preferred size of multi() command (in number of ops)
 constexpr size_t MULTI_BATCH_SIZE = 100;
 
+struct ShuffleHost
+{
+    String host;
+    Int64 priority = 0;
+    UInt32 random = 0;
+
+    void randomize()
+    {
+        random = thread_local_rng();
+    }
+
+    static bool compare(const ShuffleHost & lhs, const ShuffleHost & rhs)
+    {
+        return std::forward_as_tuple(lhs.priority, lhs.random)
+               < std::forward_as_tuple(rhs.priority, rhs.random);
+    }
+};
+
+using GetPriorityForLoadBalancing = DB::GetPriorityForLoadBalancing;
 
 /// ZooKeeper session. The interface is substantially different from the usual libzookeeper API.
 ///
@@ -58,14 +80,16 @@ public:
               int32_t operation_timeout_ms_ = Coordination::DEFAULT_OPERATION_TIMEOUT_MS,
               const std::string & chroot_ = "",
               const std::string & implementation_ = "zookeeper",
-              std::shared_ptr<DB::ZooKeeperLog> zk_log_ = nullptr);
+              std::shared_ptr<DB::ZooKeeperLog> zk_log_ = nullptr,
+              const GetPriorityForLoadBalancing & get_priority_load_balancing_ = {});
 
     explicit ZooKeeper(const Strings & hosts_, const std::string & identity_ = "",
               int32_t session_timeout_ms_ = Coordination::DEFAULT_SESSION_TIMEOUT_MS,
               int32_t operation_timeout_ms_ = Coordination::DEFAULT_OPERATION_TIMEOUT_MS,
               const std::string & chroot_ = "",
               const std::string & implementation_ = "zookeeper",
-              std::shared_ptr<DB::ZooKeeperLog> zk_log_ = nullptr);
+              std::shared_ptr<DB::ZooKeeperLog> zk_log_ = nullptr,
+              const GetPriorityForLoadBalancing & get_priority_load_balancing_ = {});
 
     /** Config of the form:
         <zookeeper>
@@ -91,6 +115,8 @@ public:
     */
     ZooKeeper(const Poco::Util::AbstractConfiguration & config, const std::string & config_name, std::shared_ptr<DB::ZooKeeperLog> zk_log_);
 
+    std::vector<ShuffleHost> shuffleHosts() const;
+
     /// Creates a new session with the same parameters. This method can be used for reconnecting
     /// after the session has expired.
     /// This object remains unchanged, and the new session is returned.
@@ -101,6 +127,8 @@ public:
     /// Returns true, if the session has expired.
     bool expired();
 
+    DB::KeeperApiVersion getApiVersion();
+
     /// Create a znode.
     /// Throw an exception if something went wrong.
     std::string create(const std::string & path, const std::string & data, int32_t mode);
@@ -158,21 +186,25 @@ public:
 
     Strings getChildren(const std::string & path,
                         Coordination::Stat * stat = nullptr,
-                        const EventPtr & watch = nullptr);
+                        const EventPtr & watch = nullptr,
+                        Coordination::ListRequestType list_request_type = Coordination::ListRequestType::ALL);
 
     Strings getChildrenWatch(const std::string & path,
                              Coordination::Stat * stat,
-                             Coordination::WatchCallback watch_callback);
+                             Coordination::WatchCallback watch_callback,
+                             Coordination::ListRequestType list_request_type = Coordination::ListRequestType::ALL);
 
     /// Doesn't not throw in the following cases:
     /// * The node doesn't exist.
     Coordination::Error tryGetChildren(const std::string & path, Strings & res,
                            Coordination::Stat * stat = nullptr,
-                           const EventPtr & watch = nullptr);
+                           const EventPtr & watch = nullptr,
+                           Coordination::ListRequestType list_request_type = Coordination::ListRequestType::ALL);
 
     Coordination::Error tryGetChildrenWatch(const std::string & path, Strings & res,
                                 Coordination::Stat * stat,
-                                Coordination::WatchCallback watch_callback);
+                                Coordination::WatchCallback watch_callback,
+                                Coordination::ListRequestType list_request_type = Coordination::ListRequestType::ALL);
 
     /// Performs several operations in a transaction.
     /// Throws on every error.
@@ -183,6 +215,10 @@ public:
     /// Throws nothing (even session expired errors)
     Coordination::Error tryMultiNoThrow(const Coordination::Requests & requests, Coordination::Responses & responses);
 
+    std::string sync(const std::string & path);
+
+    Coordination::Error trySync(const std::string & path, std::string & returned_path);
+
     Int64 getClientID();
 
     /// Remove the node with the subtree. If someone concurrently adds or removes a node
@@ -199,7 +235,10 @@ public:
     /// If keep_child_node is not empty, this method will not remove path/keep_child_node (but will remove its subtree).
     /// It can be useful to keep some child node as a flag which indicates that path is currently removing.
     void removeChildrenRecursive(const std::string & path, const String & keep_child_node = {});
-    void tryRemoveChildrenRecursive(const std::string & path, const String & keep_child_node = {});
+    /// If probably_flat is true, this method will optimistically try to remove children non-recursive
+    /// and will fall back to recursive removal if it gets ZNOTEMPTY for some child.
+    /// Returns true if no kind of fallback happened.
+    bool tryRemoveChildrenRecursive(const std::string & path, bool probably_flat = false, const String & keep_child_node = {});
 
     /// Remove all children nodes (non recursive).
     void removeChildren(const std::string & path);
@@ -211,6 +250,10 @@ public:
     /// The function returns true if waited and false if waiting was interrupted by condition.
     bool waitForDisappear(const std::string & path, const WaitCondition & condition = {});
 
+    /// Wait for the ephemeral node created in previous session to disappear.
+    /// Throws LOGICAL_ERROR if node still exists after 2x session_timeout.
+    void waitForEphemeralToDisappearIfAny(const std::string & path);
+
     /// Async interface (a small subset of operations is implemented).
     ///
     /// Usage:
@@ -242,9 +285,15 @@ public:
     FutureExists asyncTryExistsNoThrow(const std::string & path, Coordination::WatchCallback watch_callback = {});
 
     using FutureGetChildren = std::future<Coordination::ListResponse>;
-    FutureGetChildren asyncGetChildren(const std::string & path, Coordination::WatchCallback watch_callback = {});
+    FutureGetChildren asyncGetChildren(
+        const std::string & path,
+        Coordination::WatchCallback watch_callback = {},
+        Coordination::ListRequestType list_request_type = Coordination::ListRequestType::ALL);
     /// Like the previous one but don't throw any exceptions on future.get()
-    FutureGetChildren asyncTryGetChildrenNoThrow(const std::string & path, Coordination::WatchCallback watch_callback = {});
+    FutureGetChildren asyncTryGetChildrenNoThrow(
+        const std::string & path,
+        Coordination::WatchCallback watch_callback = {},
+        Coordination::ListRequestType list_request_type = Coordination::ListRequestType::ALL);
 
     using FutureSet = std::future<Coordination::SetResponse>;
     FutureSet asyncSet(const std::string & path, const std::string & data, int32_t version = -1);
@@ -261,6 +310,11 @@ public:
     /// Like the previous one but don't throw any exceptions on future.get()
     FutureMulti asyncTryMultiNoThrow(const Coordination::Requests & ops);
 
+    using FutureSync = std::future<Coordination::SyncResponse>;
+    FutureSync asyncSync(const std::string & path);
+    /// Like the previous one but don't throw any exceptions on future.get()
+    FutureSync asyncTrySyncNoThrow(const std::string & path);
+
     /// Very specific methods introduced without following general style. Implements
     /// some custom throw/no throw logic on future.get().
     ///
@@ -284,7 +338,7 @@ private:
     friend class EphemeralNodeHolder;
 
     void init(const std::string & implementation_, const Strings & hosts_, const std::string & identity_,
-              int32_t session_timeout_ms_, int32_t operation_timeout_ms_, const std::string & chroot_);
+              int32_t session_timeout_ms_, int32_t operation_timeout_ms_, const std::string & chroot_, const GetPriorityForLoadBalancing & get_priority_load_balancing_);
 
     /// The following methods don't any throw exceptions but return error codes.
     Coordination::Error createImpl(const std::string & path, const std::string & data, int32_t mode, std::string & path_created);
@@ -293,9 +347,14 @@ private:
         const std::string & path, std::string & res, Coordination::Stat * stat, Coordination::WatchCallback watch_callback);
     Coordination::Error setImpl(const std::string & path, const std::string & data, int32_t version, Coordination::Stat * stat);
     Coordination::Error getChildrenImpl(
-        const std::string & path, Strings & res, Coordination::Stat * stat, Coordination::WatchCallback watch_callback);
+        const std::string & path,
+        Strings & res,
+        Coordination::Stat * stat,
+        Coordination::WatchCallback watch_callback,
+        Coordination::ListRequestType list_request_type);
     Coordination::Error multiImpl(const Coordination::Requests & requests, Coordination::Responses & responses);
     Coordination::Error existsImpl(const std::string & path, Coordination::Stat * stat_, Coordination::WatchCallback watch_callback);
+    Coordination::Error syncImpl(const std::string & path, std::string & returned_path);
 
     std::unique_ptr<Coordination::IKeeper> impl;
 
@@ -311,6 +370,8 @@ private:
     Poco::Logger * log = nullptr;
     std::shared_ptr<DB::ZooKeeperLog> zk_log;
 
+    GetPriorityForLoadBalancing get_priority_load_balancing;
+
     AtomicStopwatch session_uptime;
 };
 
diff --git a/src/Common/ZooKeeper/ZooKeeperCommon.cpp b/src/Common/ZooKeeper/ZooKeeperCommon.cpp
index f6c9a3d3ca..2578543381 100644
--- a/src/Common/ZooKeeper/ZooKeeperCommon.cpp
+++ b/src/Common/ZooKeeper/ZooKeeperCommon.cpp
@@ -5,6 +5,7 @@
 #include <IO/WriteBufferFromString.h>
 #include <IO/Operators.h>
 #include <IO/ReadHelpers.h>
+#include <fmt/format.h>
 #include <base/logger_useful.h>
 #include <array>
 
@@ -27,6 +28,17 @@ void ZooKeeperResponse::write(WriteBuffer & out) const
     out.next();
 }
 
+std::string ZooKeeperRequest::toString() const
+{
+    return fmt::format(
+        "XID = {}\n"
+        "OpNum = {}\n"
+        "Additional info:\n{}",
+        xid,
+        getOpNum(),
+        toStringImpl());
+}
+
 void ZooKeeperRequest::write(WriteBuffer & out) const
 {
     /// Excessive copy to calculate length.
@@ -48,6 +60,11 @@ void ZooKeeperSyncRequest::readImpl(ReadBuffer & in)
     Coordination::read(path, in);
 }
 
+std::string ZooKeeperSyncRequest::toStringImpl() const
+{
+    return fmt::format("path = {}", path);
+}
+
 void ZooKeeperSyncResponse::readImpl(ReadBuffer & in)
 {
     Coordination::read(path, in);
@@ -93,6 +110,15 @@ void ZooKeeperAuthRequest::readImpl(ReadBuffer & in)
     Coordination::read(data, in);
 }
 
+std::string ZooKeeperAuthRequest::toStringImpl() const
+{
+    return fmt::format(
+        "type = {}\n"
+        "scheme = {}",
+        type,
+        scheme);
+}
+
 void ZooKeeperCreateRequest::writeImpl(WriteBuffer & out) const
 {
     Coordination::write(path, out);
@@ -124,6 +150,17 @@ void ZooKeeperCreateRequest::readImpl(ReadBuffer & in)
         is_sequential = true;
 }
 
+std::string ZooKeeperCreateRequest::toStringImpl() const
+{
+    return fmt::format(
+        "path = {}\n"
+        "is_ephemeral = {}\n"
+        "is_sequential = {}",
+        path,
+        is_ephemeral,
+        is_sequential);
+}
+
 void ZooKeeperCreateResponse::readImpl(ReadBuffer & in)
 {
     Coordination::read(path_created, in);
@@ -140,6 +177,15 @@ void ZooKeeperRemoveRequest::writeImpl(WriteBuffer & out) const
     Coordination::write(version, out);
 }
 
+std::string ZooKeeperRemoveRequest::toStringImpl() const
+{
+    return fmt::format(
+        "path = {}\n"
+        "version = {}",
+        path,
+        version);
+}
+
 void ZooKeeperRemoveRequest::readImpl(ReadBuffer & in)
 {
     Coordination::read(path, in);
@@ -158,6 +204,11 @@ void ZooKeeperExistsRequest::readImpl(ReadBuffer & in)
     Coordination::read(has_watch, in);
 }
 
+std::string ZooKeeperExistsRequest::toStringImpl() const
+{
+    return fmt::format("path = {}", path);
+}
+
 void ZooKeeperExistsResponse::readImpl(ReadBuffer & in)
 {
     Coordination::read(stat, in);
@@ -180,6 +231,11 @@ void ZooKeeperGetRequest::readImpl(ReadBuffer & in)
     Coordination::read(has_watch, in);
 }
 
+std::string ZooKeeperGetRequest::toStringImpl() const
+{
+    return fmt::format("path = {}", path);
+}
+
 void ZooKeeperGetResponse::readImpl(ReadBuffer & in)
 {
     Coordination::read(data, in);
@@ -206,6 +262,15 @@ void ZooKeeperSetRequest::readImpl(ReadBuffer & in)
     Coordination::read(version, in);
 }
 
+std::string ZooKeeperSetRequest::toStringImpl() const
+{
+    return fmt::format(
+        "path = {}\n"
+        "version = {}",
+        path,
+        version);
+}
+
 void ZooKeeperSetResponse::readImpl(ReadBuffer & in)
 {
     Coordination::read(stat, in);
@@ -228,6 +293,37 @@ void ZooKeeperListRequest::readImpl(ReadBuffer & in)
     Coordination::read(has_watch, in);
 }
 
+std::string ZooKeeperListRequest::toStringImpl() const
+{
+    return fmt::format("path = {}", path);
+}
+
+void ZooKeeperFilteredListRequest::writeImpl(WriteBuffer & out) const
+{
+    Coordination::write(path, out);
+    Coordination::write(has_watch, out);
+    Coordination::write(static_cast<uint8_t>(list_request_type), out);
+}
+
+void ZooKeeperFilteredListRequest::readImpl(ReadBuffer & in)
+{
+    Coordination::read(path, in);
+    Coordination::read(has_watch, in);
+
+    uint8_t read_request_type{0};
+    Coordination::read(read_request_type, in);
+    list_request_type = static_cast<ListRequestType>(read_request_type);
+}
+
+std::string ZooKeeperFilteredListRequest::toStringImpl() const
+{
+    return fmt::format(
+            "path = {}\n"
+            "list_request_type = {}",
+            path,
+            list_request_type);
+}
+
 void ZooKeeperListResponse::readImpl(ReadBuffer & in)
 {
     Coordination::read(names, in);
@@ -255,6 +351,11 @@ void ZooKeeperSetACLRequest::readImpl(ReadBuffer & in)
     Coordination::read(version, in);
 }
 
+std::string ZooKeeperSetACLRequest::toStringImpl() const
+{
+    return fmt::format("path = {}\n", "version = {}", path, version);
+}
+
 void ZooKeeperSetACLResponse::writeImpl(WriteBuffer & out) const
 {
     Coordination::write(stat, out);
@@ -275,6 +376,11 @@ void ZooKeeperGetACLRequest::writeImpl(WriteBuffer & out) const
     Coordination::write(path, out);
 }
 
+std::string ZooKeeperGetACLRequest::toStringImpl() const
+{
+    return fmt::format("path = {}", path);
+}
+
 void ZooKeeperGetACLResponse::writeImpl(WriteBuffer & out) const
 {
     Coordination::write(acl, out);
@@ -299,6 +405,11 @@ void ZooKeeperCheckRequest::readImpl(ReadBuffer & in)
     Coordination::read(version, in);
 }
 
+std::string ZooKeeperCheckRequest::toStringImpl() const
+{
+    return fmt::format("path = {}\n", "version = {}", path, version);
+}
+
 void ZooKeeperErrorResponse::readImpl(ReadBuffer & in)
 {
     Coordination::Error read_error;
@@ -401,6 +512,17 @@ void ZooKeeperMultiRequest::readImpl(ReadBuffer & in)
     }
 }
 
+std::string ZooKeeperMultiRequest::toStringImpl() const
+{
+    auto out = fmt::memory_buffer();
+    for (const auto & request : requests)
+    {
+        const auto & zk_request = dynamic_cast<const ZooKeeperRequest &>(*request);
+        format_to(std::back_inserter(out), "SubRequest\n{}\n", zk_request.toString());
+    }
+    return {out.data(), out.size()};
+}
+
 bool ZooKeeperMultiRequest::isReadRequest() const
 {
     /// Possibly we can do better
@@ -601,7 +723,10 @@ void ZooKeeperResponse::fillLogElements(LogElements & elems, size_t idx) const
     assert(!elem.xid || elem.xid == xid);
     elem.xid = xid;
     int32_t response_op = tryGetOpNum();
-    assert(!elem.op_num || elem.op_num == response_op || response_op < 0);
+
+    [[maybe_unused]] const bool is_filtered_list = elem.op_num == static_cast<int32_t>(Coordination::OpNum::FilteredList)
+        && response_op == static_cast<int32_t>(Coordination::OpNum::List);
+    assert(!elem.op_num || elem.op_num == response_op || is_filtered_list || response_op < 0);
     elem.op_num = response_op;
 
     elem.zxid = zxid;
@@ -769,6 +894,7 @@ ZooKeeperRequestFactory::ZooKeeperRequestFactory()
     registerZooKeeperRequest<OpNum::SessionID, ZooKeeperSessionIDRequest>(*this);
     registerZooKeeperRequest<OpNum::GetACL, ZooKeeperGetACLRequest>(*this);
     registerZooKeeperRequest<OpNum::SetACL, ZooKeeperSetACLRequest>(*this);
+    registerZooKeeperRequest<OpNum::FilteredList, ZooKeeperFilteredListRequest>(*this);
 }
 
 }
diff --git a/src/Common/ZooKeeper/ZooKeeperCommon.h b/src/Common/ZooKeeper/ZooKeeperCommon.h
index 80e38dd74d..53fabf651f 100644
--- a/src/Common/ZooKeeper/ZooKeeperCommon.h
+++ b/src/Common/ZooKeeper/ZooKeeperCommon.h
@@ -45,7 +45,7 @@ struct ZooKeeperResponse : virtual Response
 
 using ZooKeeperResponsePtr = std::shared_ptr<ZooKeeperResponse>;
 
-/// Exposed in header file for Yandex.Metrica code.
+/// Exposed in header file for some external code.
 struct ZooKeeperRequest : virtual Request
 {
     XID xid = 0;
@@ -57,6 +57,8 @@ struct ZooKeeperRequest : virtual Request
     bool restored_from_zookeeper_log = false;
 
     UInt64 request_created_time_ns = 0;
+    UInt64 thread_id = 0;
+    String query_id;
 
     ZooKeeperRequest() = default;
     ZooKeeperRequest(const ZooKeeperRequest &) = default;
@@ -66,10 +68,13 @@ struct ZooKeeperRequest : virtual Request
 
     /// Writes length, xid, op_num, then the rest.
     void write(WriteBuffer & out) const;
+    std::string toString() const;
 
     virtual void writeImpl(WriteBuffer &) const = 0;
     virtual void readImpl(ReadBuffer &) = 0;
 
+    virtual std::string toStringImpl() const { return ""; }
+
     static std::shared_ptr<ZooKeeperRequest> read(ReadBuffer & in);
 
     virtual ZooKeeperResponsePtr makeResponse() const = 0;
@@ -98,20 +103,18 @@ struct ZooKeeperSyncRequest final : ZooKeeperRequest
     OpNum getOpNum() const override { return OpNum::Sync; }
     void writeImpl(WriteBuffer & out) const override;
     void readImpl(ReadBuffer & in) override;
+    std::string toStringImpl() const override;
     ZooKeeperResponsePtr makeResponse() const override;
     bool isReadRequest() const override { return false; }
 
     size_t bytesSize() const override { return ZooKeeperRequest::bytesSize() + path.size(); }
 };
 
-struct ZooKeeperSyncResponse final : ZooKeeperResponse
+struct ZooKeeperSyncResponse final : SyncResponse, ZooKeeperResponse
 {
-    String path;
     void readImpl(ReadBuffer & in) override;
     void writeImpl(WriteBuffer & out) const override;
     OpNum getOpNum() const override { return OpNum::Sync; }
-
-    size_t bytesSize() const override { return path.size(); }
 };
 
 struct ZooKeeperHeartbeatResponse final : ZooKeeperResponse
@@ -131,6 +134,7 @@ struct ZooKeeperWatchResponse final : WatchResponse, ZooKeeperResponse
 
     OpNum getOpNum() const override
     {
+        chassert(false);
         throw Exception("OpNum for watch response doesn't exist", Error::ZRUNTIMEINCONSISTENCY);
     }
 
@@ -148,6 +152,7 @@ struct ZooKeeperAuthRequest final : ZooKeeperRequest
     OpNum getOpNum() const override { return OpNum::Auth; }
     void writeImpl(WriteBuffer & out) const override;
     void readImpl(ReadBuffer & in) override;
+    std::string toStringImpl() const override;
 
     ZooKeeperResponsePtr makeResponse() const override;
     bool isReadRequest() const override { return false; }
@@ -200,6 +205,7 @@ struct ZooKeeperCreateRequest final : public CreateRequest, ZooKeeperRequest
     OpNum getOpNum() const override { return OpNum::Create; }
     void writeImpl(WriteBuffer & out) const override;
     void readImpl(ReadBuffer & in) override;
+    std::string toStringImpl() const override;
 
     ZooKeeperResponsePtr makeResponse() const override;
     bool isReadRequest() const override { return false; }
@@ -230,6 +236,7 @@ struct ZooKeeperRemoveRequest final : RemoveRequest, ZooKeeperRequest
     OpNum getOpNum() const override { return OpNum::Remove; }
     void writeImpl(WriteBuffer & out) const override;
     void readImpl(ReadBuffer & in) override;
+    std::string toStringImpl() const override;
 
     ZooKeeperResponsePtr makeResponse() const override;
     bool isReadRequest() const override { return false; }
@@ -253,6 +260,7 @@ struct ZooKeeperExistsRequest final : ExistsRequest, ZooKeeperRequest
     OpNum getOpNum() const override { return OpNum::Exists; }
     void writeImpl(WriteBuffer & out) const override;
     void readImpl(ReadBuffer & in) override;
+    std::string toStringImpl() const override;
 
     ZooKeeperResponsePtr makeResponse() const override;
     bool isReadRequest() const override { return true; }
@@ -276,6 +284,7 @@ struct ZooKeeperGetRequest final : GetRequest, ZooKeeperRequest
     OpNum getOpNum() const override { return OpNum::Get; }
     void writeImpl(WriteBuffer & out) const override;
     void readImpl(ReadBuffer & in) override;
+    std::string toStringImpl() const override;
 
     ZooKeeperResponsePtr makeResponse() const override;
     bool isReadRequest() const override { return true; }
@@ -302,6 +311,7 @@ struct ZooKeeperSetRequest final : SetRequest, ZooKeeperRequest
     OpNum getOpNum() const override { return OpNum::Set; }
     void writeImpl(WriteBuffer & out) const override;
     void readImpl(ReadBuffer & in) override;
+    std::string toStringImpl() const override;
     ZooKeeperResponsePtr makeResponse() const override;
     bool isReadRequest() const override { return false; }
 
@@ -326,6 +336,7 @@ struct ZooKeeperListRequest : ListRequest, ZooKeeperRequest
     OpNum getOpNum() const override { return OpNum::List; }
     void writeImpl(WriteBuffer & out) const override;
     void readImpl(ReadBuffer & in) override;
+    std::string toStringImpl() const override;
     ZooKeeperResponsePtr makeResponse() const override;
     bool isReadRequest() const override { return true; }
 
@@ -337,6 +348,18 @@ struct ZooKeeperSimpleListRequest final : ZooKeeperListRequest
     OpNum getOpNum() const override { return OpNum::SimpleList; }
 };
 
+struct ZooKeeperFilteredListRequest final : ZooKeeperListRequest
+{
+    ListRequestType list_request_type{ListRequestType::ALL};
+
+    OpNum getOpNum() const override { return OpNum::FilteredList; }
+    void writeImpl(WriteBuffer & out) const override;
+    void readImpl(ReadBuffer & in) override;
+    std::string toStringImpl() const override;
+
+    size_t bytesSize() const override { return ZooKeeperListRequest::bytesSize() + sizeof(list_request_type); }
+};
+
 struct ZooKeeperListResponse : ListResponse, ZooKeeperResponse
 {
     void readImpl(ReadBuffer & in) override;
@@ -361,6 +384,7 @@ struct ZooKeeperCheckRequest final : CheckRequest, ZooKeeperRequest
     OpNum getOpNum() const override { return OpNum::Check; }
     void writeImpl(WriteBuffer & out) const override;
     void readImpl(ReadBuffer & in) override;
+    std::string toStringImpl() const override;
 
     ZooKeeperResponsePtr makeResponse() const override;
     bool isReadRequest() const override { return true; }
@@ -395,6 +419,7 @@ struct ZooKeeperSetACLRequest final : SetACLRequest, ZooKeeperRequest
     OpNum getOpNum() const override { return OpNum::SetACL; }
     void writeImpl(WriteBuffer & out) const override;
     void readImpl(ReadBuffer & in) override;
+    std::string toStringImpl() const override;
     ZooKeeperResponsePtr makeResponse() const override;
     bool isReadRequest() const override { return false; }
 
@@ -415,6 +440,7 @@ struct ZooKeeperGetACLRequest final : GetACLRequest, ZooKeeperRequest
     OpNum getOpNum() const override { return OpNum::GetACL; }
     void writeImpl(WriteBuffer & out) const override;
     void readImpl(ReadBuffer & in) override;
+    std::string toStringImpl() const override;
     ZooKeeperResponsePtr makeResponse() const override;
     bool isReadRequest() const override { return true; }
 
@@ -439,6 +465,7 @@ struct ZooKeeperMultiRequest final : MultiRequest, ZooKeeperRequest
 
     void writeImpl(WriteBuffer & out) const override;
     void readImpl(ReadBuffer & in) override;
+    std::string toStringImpl() const override;
 
     ZooKeeperResponsePtr makeResponse() const override;
     bool isReadRequest() const override;
diff --git a/src/Common/ZooKeeper/ZooKeeperConstants.cpp b/src/Common/ZooKeeper/ZooKeeperConstants.cpp
index 3f480fb6b2..ba7a9b9f0c 100644
--- a/src/Common/ZooKeeper/ZooKeeperConstants.cpp
+++ b/src/Common/ZooKeeper/ZooKeeperConstants.cpp
@@ -24,6 +24,7 @@ static const std::unordered_set<int32_t> VALID_OPERATIONS =
     static_cast<int32_t>(OpNum::SessionID),
     static_cast<int32_t>(OpNum::SetACL),
     static_cast<int32_t>(OpNum::GetACL),
+    static_cast<int32_t>(OpNum::FilteredList),
 };
 
 std::string toString(OpNum op_num)
@@ -64,6 +65,8 @@ std::string toString(OpNum op_num)
             return "SetACL";
         case OpNum::GetACL:
             return "GetACL";
+        case OpNum::FilteredList:
+            return "FilteredList";
     }
     int32_t raw_op = static_cast<int32_t>(op_num);
     throw Exception("Operation " + std::to_string(raw_op) + " is unknown", Error::ZUNIMPLEMENTED);
@@ -71,7 +74,7 @@ std::string toString(OpNum op_num)
 
 OpNum getOpNum(int32_t raw_op_num)
 {
-    if (!VALID_OPERATIONS.count(raw_op_num))
+    if (!VALID_OPERATIONS.contains(raw_op_num))
         throw Exception("Operation " + std::to_string(raw_op_num) + " is unknown", Error::ZUNIMPLEMENTED);
     return static_cast<OpNum>(raw_op_num);
 }
diff --git a/src/Common/ZooKeeper/ZooKeeperConstants.h b/src/Common/ZooKeeper/ZooKeeperConstants.h
index 1ed2c442f6..44f8437f12 100644
--- a/src/Common/ZooKeeper/ZooKeeperConstants.h
+++ b/src/Common/ZooKeeper/ZooKeeperConstants.h
@@ -32,6 +32,10 @@ enum class OpNum : int32_t
     Check = 13,
     Multi = 14,
     Auth = 100,
+
+    // CH Keeper specific operations
+    FilteredList = 500,
+
     SessionID = 997, /// Special internal request
 };
 
diff --git a/src/Common/ZooKeeper/ZooKeeperIO.cpp b/src/Common/ZooKeeper/ZooKeeperIO.cpp
index 0e0a034c63..c84a8624d7 100644
--- a/src/Common/ZooKeeper/ZooKeeperIO.cpp
+++ b/src/Common/ZooKeeper/ZooKeeperIO.cpp
@@ -9,7 +9,7 @@ void write(size_t x, WriteBuffer & out)
     writeBinary(x, out);
 }
 
-#ifdef __APPLE__
+#ifdef OS_DARWIN
 void write(uint64_t x, WriteBuffer & out)
 {
     x = __builtin_bswap64(x);
@@ -28,6 +28,11 @@ void write(int32_t x, WriteBuffer & out)
     writeBinary(x, out);
 }
 
+void write(uint8_t x, WriteBuffer & out)
+{
+    writeBinary(x, out);
+}
+
 void write(OpNum x, WriteBuffer & out)
 {
     write(static_cast<int32_t>(x), out);
@@ -40,7 +45,7 @@ void write(bool x, WriteBuffer & out)
 
 void write(const std::string & s, WriteBuffer & out)
 {
-    write(int32_t(s.size()), out);
+    write(static_cast<int32_t>(s.size()), out);
     out.write(s.data(), s.size());
 }
 
@@ -71,7 +76,7 @@ void write(const Error & x, WriteBuffer & out)
     write(static_cast<int32_t>(x), out);
 }
 
-#ifdef __APPLE__
+#ifdef OS_DARWIN
 void read(uint64_t & x, ReadBuffer & in)
 {
     readBinary(x, in);
@@ -91,6 +96,11 @@ void read(int64_t & x, ReadBuffer & in)
     x = __builtin_bswap64(x);
 }
 
+void read(uint8_t & x, ReadBuffer & in)
+{
+    readBinary(x, in);
+}
+
 void read(int32_t & x, ReadBuffer & in)
 {
     readBinary(x, in);
diff --git a/src/Common/ZooKeeper/ZooKeeperIO.h b/src/Common/ZooKeeper/ZooKeeperIO.h
index 1fcb96315a..ec77b46f3d 100644
--- a/src/Common/ZooKeeper/ZooKeeperIO.h
+++ b/src/Common/ZooKeeper/ZooKeeperIO.h
@@ -16,12 +16,13 @@ using namespace DB;
 void write(size_t x, WriteBuffer & out);
 
 /// uint64_t != size_t on darwin
-#ifdef __APPLE__
+#ifdef OS_DARWIN
 void write(uint64_t x, WriteBuffer & out);
 #endif
 
 void write(int64_t x, WriteBuffer & out);
 void write(int32_t x, WriteBuffer & out);
+void write(uint8_t x, WriteBuffer & out);
 void write(OpNum x, WriteBuffer & out);
 void write(bool x, WriteBuffer & out);
 void write(const std::string & s, WriteBuffer & out);
@@ -45,11 +46,12 @@ void write(const std::vector<T> & arr, WriteBuffer & out)
 }
 
 void read(size_t & x, ReadBuffer & in);
-#ifdef __APPLE__
+#ifdef OS_DARWIN
 void read(uint64_t & x, ReadBuffer & in);
 #endif
 void read(int64_t & x, ReadBuffer & in);
 void read(int32_t & x, ReadBuffer & in);
+void read(uint8_t & x, ReadBuffer & in);
 void read(OpNum & x, ReadBuffer & in);
 void read(bool & x, ReadBuffer & in);
 void read(int8_t & x, ReadBuffer & in);
diff --git a/src/Common/ZooKeeper/ZooKeeperImpl.cpp b/src/Common/ZooKeeper/ZooKeeperImpl.cpp
index 0627a70193..8b9977b2ef 100644
--- a/src/Common/ZooKeeper/ZooKeeperImpl.cpp
+++ b/src/Common/ZooKeeper/ZooKeeperImpl.cpp
@@ -1,3 +1,4 @@
+#include <Common/ZooKeeper/ZooKeeperCommon.h>
 #include <Common/ZooKeeper/ZooKeeperImpl.h>
 #include <Common/Exception.h>
 #include <Common/ProfileEvents.h>
@@ -5,9 +6,11 @@
 #include <Common/ZooKeeper/ZooKeeperIO.h>
 #include <IO/WriteHelpers.h>
 #include <IO/ReadHelpers.h>
+#include <IO/ReadBufferFromString.h>
 #include <IO/Operators.h>
 #include <IO/WriteBufferFromString.h>
 #include <base/logger_useful.h>
+#include <base/getThreadId.h>
 
 #include <Common/config.h>
 
@@ -16,7 +19,7 @@
 #endif
 
 #include <array>
-
+#include <future>
 
 namespace ProfileEvents
 {
@@ -30,6 +33,7 @@ namespace ProfileEvents
     extern const Event ZooKeeperSet;
     extern const Event ZooKeeperList;
     extern const Event ZooKeeperCheck;
+    extern const Event ZooKeeperSync;
     extern const Event ZooKeeperClose;
     extern const Event ZooKeeperWaitMicroseconds;
     extern const Event ZooKeeperBytesSent;
@@ -349,6 +353,8 @@ ZooKeeper::ZooKeeper(
     send_thread = ThreadFromGlobalPool([this] { sendThread(); });
     receive_thread = ThreadFromGlobalPool([this] { receiveThread(); });
 
+    initApiVersion();
+
     ProfileEvents::increment(ProfileEvents::ZooKeeperInit);
 }
 
@@ -451,7 +457,7 @@ void ZooKeeper::connect(
     }
     else
     {
-        LOG_TEST(log, "Connected to ZooKeeper at {} with session_id {}", socket.peerAddress().toString(), session_id);
+        LOG_TEST(log, "Connected to ZooKeeper at {} with session_id {}{}", socket.peerAddress().toString(), session_id, fail_reasons.str());
     }
 }
 
@@ -538,7 +544,7 @@ void ZooKeeper::sendAuth(const String & scheme, const String & data)
             Error::ZMARSHALLINGERROR);
 
     if (err != Error::ZOK)
-        throw Exception("Error received in reply to auth request. Code: " + DB::toString(int32_t(err)) + ". Message: " + String(errorMessage(err)),
+        throw Exception("Error received in reply to auth request. Code: " + DB::toString(static_cast<int32_t>(err)) + ". Message: " + String(errorMessage(err)),
             Error::ZMARSHALLINGERROR);
 }
 
@@ -562,8 +568,8 @@ void ZooKeeper::sendThread()
             {
                 /// Wait for the next request in queue. No more than operation timeout. No more than until next heartbeat time.
                 UInt64 max_wait = std::min(
-                    UInt64(std::chrono::duration_cast<std::chrono::milliseconds>(next_heartbeat_time - now).count()),
-                    UInt64(operation_timeout.totalMilliseconds()));
+                    static_cast<UInt64>(std::chrono::duration_cast<std::chrono::milliseconds>(next_heartbeat_time - now).count()),
+                    static_cast<UInt64>(operation_timeout.totalMilliseconds()));
 
                 RequestInfo info;
                 if (requests_queue.tryPop(info, max_wait))
@@ -695,6 +701,7 @@ void ZooKeeper::receiveEvent()
 
     RequestInfo request_info;
     ZooKeeperResponsePtr response;
+    UInt64 elapsed_ms = 0;
 
     if (xid == PING_XID)
     {
@@ -755,8 +762,8 @@ void ZooKeeper::receiveEvent()
             CurrentMetrics::sub(CurrentMetrics::ZooKeeperRequest);
         }
 
-        auto elapsed_microseconds = std::chrono::duration_cast<std::chrono::microseconds>(clock::now() - request_info.time).count();
-        ProfileEvents::increment(ProfileEvents::ZooKeeperWaitMicroseconds, elapsed_microseconds);
+        elapsed_ms = std::chrono::duration_cast<std::chrono::microseconds>(clock::now() - request_info.time).count();
+        ProfileEvents::increment(ProfileEvents::ZooKeeperWaitMicroseconds, elapsed_ms);
     }
 
     try
@@ -806,7 +813,7 @@ void ZooKeeper::receiveEvent()
         if (length != actual_length)
             throw Exception("Response length doesn't match. Expected: " + DB::toString(length) + ", actual: " + DB::toString(actual_length), Error::ZMARSHALLINGERROR);
 
-        logOperationIfNeeded(request_info.request, response);   //-V614
+        logOperationIfNeeded(request_info.request, response, /* finalize= */ false, elapsed_ms);   //-V614
     }
     catch (...)
     {
@@ -825,7 +832,7 @@ void ZooKeeper::receiveEvent()
             if (request_info.callback)
                 request_info.callback(*response);
 
-            logOperationIfNeeded(request_info.request, response);
+            logOperationIfNeeded(request_info.request, response, /* finalize= */ false, elapsed_ms);
         }
         catch (...)
         {
@@ -846,7 +853,7 @@ void ZooKeeper::receiveEvent()
 void ZooKeeper::finalize(bool error_send, bool error_receive, const String & reason)
 {
     /// If some thread (send/receive) already finalizing session don't try to do it
-    bool already_started = finalization_started.exchange(true);
+    bool already_started = finalization_started.test_and_set();
 
     LOG_TEST(log, "Finalizing session {}: finalization_started={}, queue_finished={}, reason={}",
              session_id, already_started, requests_queue.isFinished(), reason);
@@ -913,13 +920,14 @@ void ZooKeeper::finalize(bool error_send, bool error_receive, const String & rea
                     ? Error::ZCONNECTIONLOSS
                     : Error::ZSESSIONEXPIRED;
                 response->xid = request_info.request->xid;
+                UInt64 elapsed_ms = std::chrono::duration_cast<std::chrono::microseconds>(clock::now() - request_info.time).count();
 
                 if (request_info.callback)
                 {
                     try
                     {
                         request_info.callback(*response);
-                        logOperationIfNeeded(request_info.request, response, true);
+                        logOperationIfNeeded(request_info.request, response, true, elapsed_ms);
                     }
                     catch (...)
                     {
@@ -979,7 +987,8 @@ void ZooKeeper::finalize(bool error_send, bool error_receive, const String & rea
                     try
                     {
                         info.callback(*response);
-                        logOperationIfNeeded(info.request, response, true);
+                        UInt64 elapsed_ms = std::chrono::duration_cast<std::chrono::microseconds>(clock::now() - info.time).count();
+                        logOperationIfNeeded(info.request, response, true, elapsed_ms);
                     }
                     catch (...)
                     {
@@ -1016,6 +1025,11 @@ void ZooKeeper::pushRequest(RequestInfo && info)
     try
     {
         info.time = clock::now();
+        if (zk_log)
+        {
+            info.request->thread_id = getThreadId();
+            info.request->query_id = String(CurrentThread::getQueryId());
+        }
 
         if (!info.request->xid)
         {
@@ -1049,6 +1063,44 @@ void ZooKeeper::pushRequest(RequestInfo && info)
     ProfileEvents::increment(ProfileEvents::ZooKeeperTransactions);
 }
 
+KeeperApiVersion ZooKeeper::getApiVersion()
+{
+    return keeper_api_version;
+}
+
+void ZooKeeper::initApiVersion()
+{
+    auto promise = std::make_shared<std::promise<Coordination::GetResponse>>();
+    auto future = promise->get_future();
+
+    auto callback = [promise](const Coordination::GetResponse & response) mutable
+    {
+        promise->set_value(response);
+    };
+
+    get(keeper_api_version_path, std::move(callback), {});
+    if (future.wait_for(std::chrono::milliseconds(operation_timeout.totalMilliseconds())) != std::future_status::ready)
+    {
+        LOG_TRACE(log, "Failed to get API version: timeout");
+        return;
+    }
+
+    auto response = future.get();
+
+    if (response.error != Coordination::Error::ZOK)
+    {
+        LOG_TRACE(log, "Failed to get API version");
+        return;
+    }
+
+    uint8_t keeper_version{0};
+    DB::ReadBufferFromOwnString buf(response.data);
+    DB::readIntText(keeper_version, buf);
+    keeper_api_version = static_cast<DB::KeeperApiVersion>(keeper_version);
+    LOG_TRACE(log, "Detected server's API version: {}", keeper_api_version);
+}
+
+
 void ZooKeeper::executeGenericRequest(
     const ZooKeeperRequestPtr & request,
     ResponseCallback callback)
@@ -1160,16 +1212,31 @@ void ZooKeeper::set(
 
 void ZooKeeper::list(
     const String & path,
+    ListRequestType list_request_type,
     ListCallback callback,
     WatchCallback watch)
 {
-    ZooKeeperListRequest request;
-    request.path = path;
+    std::shared_ptr<ZooKeeperListRequest> request{nullptr};
+    if (keeper_api_version < Coordination::KeeperApiVersion::WITH_FILTERED_LIST)
+    {
+        if (list_request_type != ListRequestType::ALL)
+            throw Exception("Filtered list request type cannot be used because it's not supported by the server", Error::ZBADARGUMENTS);
+
+        request = std::make_shared<ZooKeeperListRequest>();
+    }
+    else
+    {
+        auto filtered_list_request = std::make_shared<ZooKeeperFilteredListRequest>();
+        filtered_list_request->list_request_type = list_request_type;
+        request = std::move(filtered_list_request);
+    }
+
+    request->path = path;
 
     RequestInfo request_info;
-    request_info.request = std::make_shared<ZooKeeperListRequest>(std::move(request));
     request_info.callback = [callback](const Response & response) { callback(dynamic_cast<const ListResponse &>(response)); };
     request_info.watch = watch;
+    request_info.request = std::move(request);
 
     pushRequest(std::move(request_info));
     ProfileEvents::increment(ProfileEvents::ZooKeeperList);
@@ -1193,6 +1260,21 @@ void ZooKeeper::check(
     ProfileEvents::increment(ProfileEvents::ZooKeeperCheck);
 }
 
+void ZooKeeper::sync(
+     const String & path,
+     SyncCallback callback)
+{
+    ZooKeeperSyncRequest request;
+    request.path = path;
+
+    RequestInfo request_info;
+    request_info.request = std::make_shared<ZooKeeperSyncRequest>(std::move(request));
+    request_info.callback = [callback](const Response & response) { callback(dynamic_cast<const SyncResponse &>(response)); };
+
+    pushRequest(std::move(request_info));
+    ProfileEvents::increment(ProfileEvents::ZooKeeperSync);
+}
+
 
 void ZooKeeper::multi(
     const Requests & requests,
@@ -1231,7 +1313,7 @@ void ZooKeeper::setZooKeeperLog(std::shared_ptr<DB::ZooKeeperLog> zk_log_)
 }
 
 #ifdef ZOOKEEPER_LOG
-void ZooKeeper::logOperationIfNeeded(const ZooKeeperRequestPtr & request, const ZooKeeperResponsePtr & response, bool finalize)
+void ZooKeeper::logOperationIfNeeded(const ZooKeeperRequestPtr & request, const ZooKeeperResponsePtr & response, bool finalize, UInt64 elapsed_ms)
 {
     auto maybe_zk_log = std::atomic_load(&zk_log);
     if (!maybe_zk_log)
@@ -1269,11 +1351,17 @@ void ZooKeeper::logOperationIfNeeded(const ZooKeeperRequestPtr & request, const
         elem.event_time = event_time;
         elem.address = socket_address;
         elem.session_id = session_id;
+        elem.duration_ms = elapsed_ms;
+        if (request)
+        {
+            elem.thread_id = request->thread_id;
+            elem.query_id = request->query_id;
+        }
         maybe_zk_log->add(elem);
     }
 }
 #else
-void ZooKeeper::logOperationIfNeeded(const ZooKeeperRequestPtr &, const ZooKeeperResponsePtr &, bool)
+void ZooKeeper::logOperationIfNeeded(const ZooKeeperRequestPtr &, const ZooKeeperResponsePtr &, bool, UInt64)
 {}
 #endif
 
diff --git a/src/Common/ZooKeeper/ZooKeeperImpl.h b/src/Common/ZooKeeper/ZooKeeperImpl.h
index b87469bd33..e00250c151 100644
--- a/src/Common/ZooKeeper/ZooKeeperImpl.h
+++ b/src/Common/ZooKeeper/ZooKeeperImpl.h
@@ -1,11 +1,13 @@
 #pragma once
 
+#include <base/defines.h>
 #include <base/types.h>
 #include <Common/ConcurrentBoundedQueue.h>
 #include <Common/CurrentMetrics.h>
 #include <Common/ThreadPool.h>
 #include <Common/ZooKeeper/IKeeper.h>
 #include <Common/ZooKeeper/ZooKeeperCommon.h>
+#include <Coordination/KeeperConstants.h>
 
 #include <IO/ReadBuffer.h>
 #include <IO/WriteBuffer.h>
@@ -163,6 +165,7 @@ public:
 
     void list(
         const String & path,
+        ListRequestType list_request_type,
         ListCallback callback,
         WatchCallback watch) override;
 
@@ -171,10 +174,16 @@ public:
         int32_t version,
         CheckCallback callback) override;
 
+    void sync(
+         const String & path,
+         SyncCallback callback) override;
+
     void multi(
         const Requests & requests,
         MultiCallback callback) override;
 
+    DB::KeeperApiVersion getApiVersion() override;
+
     /// Without forcefully invalidating (finalizing) ZooKeeper session before
     /// establishing a new one, there was a possibility that server is using
     /// two ZooKeeper sessions simultaneously in different parts of code.
@@ -209,7 +218,7 @@ private:
     std::atomic<XID> next_xid {1};
     /// Mark session finalization start. Used to avoid simultaneous
     /// finalization from different threads. One-shot flag.
-    std::atomic<bool> finalization_started {false};
+    std::atomic_flag finalization_started;
 
     using clock = std::chrono::steady_clock;
 
@@ -228,13 +237,13 @@ private:
 
     using Operations = std::map<XID, RequestInfo>;
 
-    Operations operations;
+    Operations operations TSA_GUARDED_BY(operations_mutex);
     std::mutex operations_mutex;
 
     using WatchCallbacks = std::vector<WatchCallback>;
     using Watches = std::map<String /* path, relative of root_path */, WatchCallbacks>;
 
-    Watches watches;
+    Watches watches TSA_GUARDED_BY(watches_mutex);
     std::mutex watches_mutex;
 
     ThreadFromGlobalPool send_thread;
@@ -267,10 +276,14 @@ private:
     template <typename T>
     void read(T &);
 
-    void logOperationIfNeeded(const ZooKeeperRequestPtr & request, const ZooKeeperResponsePtr & response = nullptr, bool finalize = false);
+    void logOperationIfNeeded(const ZooKeeperRequestPtr & request, const ZooKeeperResponsePtr & response = nullptr, bool finalize = false, UInt64 elapsed_ms = 0);
+
+    void initApiVersion();
 
     CurrentMetrics::Increment active_session_metric_increment{CurrentMetrics::ZooKeeperSession};
     std::shared_ptr<ZooKeeperLog> zk_log;
+
+    DB::KeeperApiVersion keeper_api_version{DB::KeeperApiVersion::ZOOKEEPER_COMPATIBLE};
 };
 
 }
diff --git a/src/Common/noexcept_scope.h b/src/Common/noexcept_scope.h
new file mode 100644
index 0000000000..bdd7a98925
--- /dev/null
+++ b/src/Common/noexcept_scope.h
@@ -0,0 +1,28 @@
+#pragma once
+#include <Common/Exception.h>
+#include <Common/LockMemoryExceptionInThread.h>
+
+/// It can be used in critical places to exit on unexpected exceptions.
+/// SIGABRT is usually better that broken in-memory state with unpredictable consequences.
+/// It also temporarily disables exception from memory tracker in current thread.
+/// Strict version does not take into account nested exception (i.e. it aborts even when we're in catch block).
+
+#define NOEXCEPT_SCOPE_IMPL(...) do {                          \
+    LockMemoryExceptionInThread                                \
+        noexcept_lock_memory_tracker(VariableContext::Global); \
+    try                                                        \
+    {                                                          \
+        __VA_ARGS__;                                           \
+    }                                                          \
+    catch (...)                                                \
+    {                                                          \
+        DB::tryLogCurrentException(__PRETTY_FUNCTION__);       \
+        std::terminate();                                      \
+    }                                                          \
+} while (0) /* to allow leading semi-colon */
+
+#define NOEXCEPT_SCOPE_STRICT(...)                    \
+    if (std::uncaught_exceptions()) std::terminate(); \
+    NOEXCEPT_SCOPE_IMPL(__VA_ARGS__)
+
+#define NOEXCEPT_SCOPE(...) NOEXCEPT_SCOPE_IMPL(__VA_ARGS__)
diff --git a/src/Coordination/KeeperConstants.h b/src/Coordination/KeeperConstants.h
new file mode 100644
index 0000000000..eb75fda454
--- /dev/null
+++ b/src/Coordination/KeeperConstants.h
@@ -0,0 +1,25 @@
+#pragma once
+
+#include <IO/WriteHelpers.h>
+
+namespace DB
+{
+
+enum class KeeperApiVersion : uint8_t
+{
+    ZOOKEEPER_COMPATIBLE = 0,
+    WITH_FILTERED_LIST
+};
+
+inline constexpr auto current_keeper_api_version = KeeperApiVersion::WITH_FILTERED_LIST;
+
+const std::string keeper_system_path = "/keeper";
+const std::string keeper_api_version_path = keeper_system_path + "/api_version";
+
+using PathWithData = std::pair<std::string_view, std::string>;
+const std::vector<PathWithData> child_system_paths_with_data
+{
+    {keeper_api_version_path, toString(static_cast<uint8_t>(current_keeper_api_version))}
+};
+
+}
diff --git a/src/Coordination/KeeperContext.h b/src/Coordination/KeeperContext.h
new file mode 100644
index 0000000000..64fa8cea6e
--- /dev/null
+++ b/src/Coordination/KeeperContext.h
@@ -0,0 +1,23 @@
+#pragma once
+
+namespace DB
+{
+
+struct KeeperContext
+{
+    enum class Phase : uint8_t
+    {
+        INIT,
+        RUNNING,
+        SHUTDOWN
+    };
+
+    Phase server_state{Phase::INIT};
+
+    bool ignore_system_path_on_startup{false};
+    bool digest_enabled{true};
+};
+
+using KeeperContextPtr = std::shared_ptr<KeeperContext>;
+
+}
diff --git a/src/Core/Settings.h b/src/Core/Settings.h
index 28aee915f3..a5019c39f9 100644
--- a/src/Core/Settings.h
+++ b/src/Core/Settings.h
@@ -1154,8 +1154,10 @@ class IColumn;
     M(Bool, allow_experimental_nlp_functions, false, "Enable experimental functions for natural language processing.", 0) \
     M(Bool, allow_experimental_object_type, false, "Allow Object and JSON data types", 0) \
     M(String, insert_deduplication_token, "", "If not empty, used for duplicate detection instead of data digest", 0)                    \
-    M(Bool, throw_on_unsupported_query_inside_transaction, true, "Throw exception if unsupported query is used inside transaction", 0) \
-// End of COMMON_SETTINGS
+    M(Bool, throw_on_unsupported_query_inside_transaction, true, "Throw exception if unsupported query is used inside transaction", 0)   \
+    M(TransactionsWaitCSNMode, wait_changes_become_visible_after_commit_mode, TransactionsWaitCSNMode::WAIT_UNKNOWN, "Wait for committed changes to become actually visible in the latest snapshot", 0) \
+    M(Bool, implicit_transaction, false, "If enabled and not already inside a transaction, wraps the query inside a full transaction (begin + commit or rollback)", 0) \
+    // End of COMMON_SETTINGS
 // Please add settings related to formats into the FORMAT_FACTORY_SETTINGS and move obsolete settings to OBSOLETE_SETTINGS.
 
 #define MAKE_OBSOLETE(M, TYPE, NAME, DEFAULT) \
diff --git a/src/Core/SettingsEnums.cpp b/src/Core/SettingsEnums.cpp
index ddd1c29785..d1d225ba89 100644
--- a/src/Core/SettingsEnums.cpp
+++ b/src/Core/SettingsEnums.cpp
@@ -130,6 +130,11 @@ IMPLEMENT_SETTING_ENUM(ShortCircuitFunctionEvaluation, ErrorCodes::BAD_ARGUMENTS
      {"force_enable",    ShortCircuitFunctionEvaluation::FORCE_ENABLE},
      {"disable",         ShortCircuitFunctionEvaluation::DISABLE}})
 
+IMPLEMENT_SETTING_ENUM(TransactionsWaitCSNMode, ErrorCodes::BAD_ARGUMENTS,
+    {{"async",          TransactionsWaitCSNMode::ASYNC},
+     {"wait",           TransactionsWaitCSNMode::WAIT},
+     {"wait_unknown",   TransactionsWaitCSNMode::WAIT_UNKNOWN}})
+
 IMPLEMENT_SETTING_ENUM(EnumComparingMode, ErrorCodes::BAD_ARGUMENTS,
     {{"by_names",   FormatSettings::EnumComparingMode::BY_NAMES},
      {"by_values",  FormatSettings::EnumComparingMode::BY_VALUES},
diff --git a/src/Core/SettingsEnums.h b/src/Core/SettingsEnums.h
index 47bd4b9a92..026df53abf 100644
--- a/src/Core/SettingsEnums.h
+++ b/src/Core/SettingsEnums.h
@@ -182,6 +182,15 @@ enum class ShortCircuitFunctionEvaluation
 
 DECLARE_SETTING_ENUM(ShortCircuitFunctionEvaluation)
 
+enum class TransactionsWaitCSNMode
+{
+    ASYNC,
+    WAIT,
+    WAIT_UNKNOWN,
+};
+
+DECLARE_SETTING_ENUM(TransactionsWaitCSNMode)
+
 DECLARE_SETTING_ENUM_WITH_RENAME(EnumComparingMode, FormatSettings::EnumComparingMode)
 
 DECLARE_SETTING_ENUM_WITH_RENAME(EscapingRule, FormatSettings::EscapingRule)
diff --git a/src/Functions/FunctionsTransactionCounters.cpp b/src/Functions/FunctionsTransactionCounters.cpp
index f2e9d3aa84..f28cfb60df 100644
--- a/src/Functions/FunctionsTransactionCounters.cpp
+++ b/src/Functions/FunctionsTransactionCounters.cpp
@@ -23,7 +23,7 @@ public:
         if (txn)
             res = {txn->tid.start_csn, txn->tid.local_tid, txn->tid.host_id};
         else
-            res = {UInt64(0), UInt64(0), UUIDHelpers::Nil};
+            res = {static_cast<UInt64>(0), static_cast<UInt64>(0), UUIDHelpers::Nil};
         return res;
     }
 
diff --git a/src/IO/ReadBufferFromString.h b/src/IO/ReadBufferFromString.h
index 09646e9b41..7ea6afc354 100644
--- a/src/IO/ReadBufferFromString.h
+++ b/src/IO/ReadBufferFromString.h
@@ -15,4 +15,11 @@ public:
 
     explicit ReadBufferFromString(std::string_view s) : ReadBufferFromMemory(s.data(), s.size()) {}
 };
+
+class ReadBufferFromOwnString : public String, public ReadBufferFromString
+{
+public:
+    explicit ReadBufferFromOwnString(const String & s_): String(s_), ReadBufferFromString(*this) {}
+};
+
 }
diff --git a/src/IO/ReadHelpers.cpp b/src/IO/ReadHelpers.cpp
index dcf5f8be78..e086f16be5 100644
--- a/src/IO/ReadHelpers.cpp
+++ b/src/IO/ReadHelpers.cpp
@@ -26,7 +26,6 @@ namespace ErrorCodes
     extern const int CANNOT_PARSE_DATETIME;
     extern const int CANNOT_PARSE_DATE;
     extern const int INCORRECT_DATA;
-    extern const int ATTEMPT_TO_READ_AFTER_EOF;
 }
 
 template <typename IteratorSrc, typename IteratorDst>
@@ -138,12 +137,6 @@ void assertEOF(ReadBuffer & buf)
         throwAtAssertionFailed("eof", buf);
 }
 
-void assertNotEOF(ReadBuffer & buf)
-{
-    if (buf.eof())
-        throw Exception("Attempt to read after EOF", ErrorCodes::ATTEMPT_TO_READ_AFTER_EOF);
-}
-
 
 void assertStringCaseInsensitive(const char * s, ReadBuffer & buf)
 {
diff --git a/src/IO/ReadHelpers.h b/src/IO/ReadHelpers.h
index 71045c7c73..9396e1d32f 100644
--- a/src/IO/ReadHelpers.h
+++ b/src/IO/ReadHelpers.h
@@ -163,7 +163,6 @@ void readVectorBinary(std::vector<T> & v, ReadBuffer & buf, size_t MAX_VECTOR_SI
 
 void assertString(const char * s, ReadBuffer & buf);
 void assertEOF(ReadBuffer & buf);
-void assertNotEOF(ReadBuffer & buf);
 
 [[noreturn]] void throwAtAssertionFailed(const char * s, ReadBuffer & buf);
 
diff --git a/src/Interpreters/InterpreterSystemQuery.cpp b/src/Interpreters/InterpreterSystemQuery.cpp
index cce11ac983..703b813ca7 100644
--- a/src/Interpreters/InterpreterSystemQuery.cpp
+++ b/src/Interpreters/InterpreterSystemQuery.cpp
@@ -31,6 +31,7 @@
 #include <Interpreters/ZooKeeperLog.h>
 #include <Interpreters/TransactionsInfoLog.h>
 #include <Interpreters/JIT/CompiledExpressionCache.h>
+#include <Interpreters/TransactionLog.h>
 #include <Access/ContextAccess.h>
 #include <Access/Common/AllowedClientHosts.h>
 #include <Databases/IDatabase.h>
@@ -415,6 +416,9 @@ BlockIO InterpreterSystemQuery::execute()
         case Type::SYNC_REPLICA:
             syncReplica(query);
             break;
+        case Type::SYNC_TRANSACTION_LOG:
+            syncTransactionLog();
+            break;
         case Type::FLUSH_DISTRIBUTED:
             flushDistributed(query);
             break;
@@ -713,6 +717,13 @@ void InterpreterSystemQuery::syncReplica(ASTSystemQuery &)
         throw Exception(ErrorCodes::BAD_ARGUMENTS, table_is_not_replicated.data(), table_id.getNameForLogs());
 }
 
+void InterpreterSystemQuery::syncTransactionLog()
+{
+    getContext()->checkTransactionsAreAllowed(/* explicit_tcl_query */ true);
+    TransactionLog::instance().sync();
+}
+
+
 void InterpreterSystemQuery::flushDistributed(ASTSystemQuery &)
 {
     getContext()->checkAccess(AccessType::SYSTEM_FLUSH_DISTRIBUTED, table_id);
@@ -881,6 +892,11 @@ AccessRightsElements InterpreterSystemQuery::getRequiredAccessForDDLOnCluster()
             required_access.emplace_back(AccessType::SYSTEM_RESTART_REPLICA);
             break;
         }
+        case Type::SYNC_TRANSACTION_LOG:
+        {
+            required_access.emplace_back(AccessType::SYSTEM_SYNC_TRANSACTION_LOG);
+            break;
+        }
         case Type::FLUSH_DISTRIBUTED:
         {
             required_access.emplace_back(AccessType::SYSTEM_FLUSH_DISTRIBUTED, query.getDatabase(), query.getTable());
diff --git a/src/Interpreters/InterpreterSystemQuery.h b/src/Interpreters/InterpreterSystemQuery.h
index e8e16f18d0..a9ce5e95d0 100644
--- a/src/Interpreters/InterpreterSystemQuery.h
+++ b/src/Interpreters/InterpreterSystemQuery.h
@@ -51,6 +51,8 @@ private:
     void restartReplicas(ContextMutablePtr system_context);
     void syncReplica(ASTSystemQuery & query);
 
+    void syncTransactionLog();
+
     void restoreReplica();
 
     void dropReplica(ASTSystemQuery & query);
diff --git a/src/Interpreters/InterpreterTransactionControlQuery.cpp b/src/Interpreters/InterpreterTransactionControlQuery.cpp
index 61b2a4e865..bdb523de88 100644
--- a/src/Interpreters/InterpreterTransactionControlQuery.cpp
+++ b/src/Interpreters/InterpreterTransactionControlQuery.cpp
@@ -10,6 +10,7 @@ namespace ErrorCodes
 {
     extern const int LOGICAL_ERROR;
     extern const int INVALID_TRANSACTION;
+    extern const int UNKNOWN_STATUS_OF_TRANSACTION;
 }
 
 BlockIO InterpreterTransactionControlQuery::execute()
@@ -55,7 +56,53 @@ BlockIO InterpreterTransactionControlQuery::executeCommit(ContextMutablePtr sess
     if (txn->getState() != MergeTreeTransaction::RUNNING)
         throw Exception(ErrorCodes::INVALID_TRANSACTION, "Transaction is not in RUNNING state");
 
-    TransactionLog::instance().commitTransaction(txn);
+    TransactionsWaitCSNMode mode = query_context->getSettingsRef().wait_changes_become_visible_after_commit_mode;
+    CSN csn;
+    try
+    {
+        csn = TransactionLog::instance().commitTransaction(txn, /* throw_on_unknown_status */ mode != TransactionsWaitCSNMode::WAIT_UNKNOWN);
+    }
+    catch (const Exception & e)
+    {
+        if (e.code() == ErrorCodes::UNKNOWN_STATUS_OF_TRANSACTION)
+        {
+            /// Detach transaction from current context if connection was lost and its status is unknown
+            /// (so it will be possible to start new one)
+            session_context->setCurrentTransaction(NO_TRANSACTION_PTR);
+        }
+        throw;
+    }
+
+    if (csn == Tx::CommittingCSN)
+    {
+        chassert(mode == TransactionsWaitCSNMode::WAIT_UNKNOWN);
+
+        /// Try to wait for connection to be restored and its status to be loaded.
+        /// It's useful for testing. It allows to enable fault injection (after commit) without breaking tests.
+        txn->waitStateChange(Tx::CommittingCSN);
+
+        CSN csn_changed_state = txn->getCSN();
+        if (csn_changed_state == Tx::UnknownCSN)
+        {
+            /// CommittingCSN -> UnknownCSN -> RolledBackCSN
+            /// It's possible if connection was lost before commit
+            /// (maybe we should get rid of intermediate UnknownCSN in this transition)
+            txn->waitStateChange(Tx::UnknownCSN);
+            chassert(txn->getCSN() == Tx::RolledBackCSN);
+        }
+
+        if (txn->getState() == MergeTreeTransaction::ROLLED_BACK)
+            throw Exception(ErrorCodes::INVALID_TRANSACTION, "Transaction {} was rolled back", txn->tid);
+        if (txn->getState() != MergeTreeTransaction::COMMITTED)
+            throw Exception(ErrorCodes::LOGICAL_ERROR, "Transaction {} has invalid state {}", txn->tid, txn->getState());
+
+        csn = txn->getCSN();
+    }
+
+    /// Wait for committed changes to become actually visible, so the next transaction in this session will see the changes
+    if (mode != TransactionsWaitCSNMode::ASYNC)
+        TransactionLog::instance().waitForCSNLoaded(csn);
+
     session_context->setCurrentTransaction(NO_TRANSACTION_PTR);
     return {};
 }
@@ -67,6 +114,8 @@ BlockIO InterpreterTransactionControlQuery::executeRollback(ContextMutablePtr se
         throw Exception(ErrorCodes::INVALID_TRANSACTION, "There is no current transaction");
     if (txn->getState() == MergeTreeTransaction::COMMITTED)
         throw Exception(ErrorCodes::LOGICAL_ERROR, "Transaction is in COMMITTED state");
+    if (txn->getState() == MergeTreeTransaction::COMMITTING)
+        throw Exception(ErrorCodes::LOGICAL_ERROR, "Transaction is in COMMITTING state");
 
     if (txn->getState() == MergeTreeTransaction::RUNNING)
         TransactionLog::instance().rollbackTransaction(txn);
diff --git a/src/Interpreters/InterpreterTransactionControlQuery.h b/src/Interpreters/InterpreterTransactionControlQuery.h
index 05d3068e09..a66a740ce0 100644
--- a/src/Interpreters/InterpreterTransactionControlQuery.h
+++ b/src/Interpreters/InterpreterTransactionControlQuery.h
@@ -20,9 +20,8 @@ public:
     bool ignoreLimits() const override { return true; }
     bool supportsTransactions() const override { return true; }
 
-private:
     BlockIO executeBegin(ContextMutablePtr session_context);
-    static BlockIO executeCommit(ContextMutablePtr session_context);
+    BlockIO executeCommit(ContextMutablePtr session_context);
     static BlockIO executeRollback(ContextMutablePtr session_context);
     static BlockIO executeSetSnapshot(ContextMutablePtr session_context, UInt64 snapshot);
 
diff --git a/src/Interpreters/MergeTreeTransaction.cpp b/src/Interpreters/MergeTreeTransaction.cpp
index 7c1feb579e..ea1decb579 100644
--- a/src/Interpreters/MergeTreeTransaction.cpp
+++ b/src/Interpreters/MergeTreeTransaction.cpp
@@ -4,6 +4,7 @@
 #include <Interpreters/TransactionLog.h>
 #include <Interpreters/TransactionsInfoLog.h>
 
+
 namespace DB
 {
 
@@ -11,40 +12,54 @@ namespace ErrorCodes
 {
     extern const int INVALID_TRANSACTION;
     extern const int LOGICAL_ERROR;
+    extern const int NOT_IMPLEMENTED;
 }
 
-static TableLockHolder getLockForOrdinary(const StoragePtr & storage)
+static void checkNotOrdinaryDatabase(const StoragePtr & storage)
 {
     if (storage->getStorageID().uuid != UUIDHelpers::Nil)
-        return {};
+        return;
 
-    /// Maybe we should just throw an exception and do not support Ordinary database?
-    auto default_timeout = std::chrono::milliseconds(10 * 1000);
-    return storage->lockForShare(RWLockImpl::NO_QUERY, default_timeout);
+    throw Exception(ErrorCodes::NOT_IMPLEMENTED, "Table {} belongs to database with Ordinary engine. "
+                    "This engine is deprecated and is not supported in transactions.", storage->getStorageID().getNameForLogs());
 }
 
-MergeTreeTransaction::MergeTreeTransaction(CSN snapshot_, LocalTID local_tid_, UUID host_id)
+MergeTreeTransaction::MergeTreeTransaction(CSN snapshot_, LocalTID local_tid_, UUID host_id, std::list<CSN>::iterator snapshot_it_)
     : tid({snapshot_, local_tid_, host_id})
     , snapshot(snapshot_)
+    , snapshot_in_use_it(snapshot_it_)
     , csn(Tx::UnknownCSN)
 {
 }
 
 void MergeTreeTransaction::setSnapshot(CSN new_snapshot)
 {
-    snapshot = new_snapshot;
+    snapshot.store(new_snapshot, std::memory_order_relaxed);
 }
 
 MergeTreeTransaction::State MergeTreeTransaction::getState() const
 {
     CSN c = csn.load();
-    if (c == Tx::UnknownCSN || c == Tx::CommittingCSN)
+    if (c == Tx::UnknownCSN)
         return RUNNING;
+    if (c == Tx::CommittingCSN)
+        return COMMITTING;
     if (c == Tx::RolledBackCSN)
         return ROLLED_BACK;
     return COMMITTED;
 }
 
+bool MergeTreeTransaction::waitStateChange(CSN current_state_csn) const
+{
+    CSN current_value = current_state_csn;
+    while (current_value == current_state_csn && !TransactionLog::instance().isShuttingDown())
+    {
+        csn.wait(current_value);
+        current_value = csn.load();
+    }
+    return current_value != current_state_csn;
+}
+
 void MergeTreeTransaction::checkIsNotCancelled() const
 {
     CSN c = csn.load();
@@ -116,29 +131,26 @@ void MergeTreeTransaction::addNewPartAndRemoveCovered(const StoragePtr & storage
 
 void MergeTreeTransaction::addNewPart(const StoragePtr & storage, const DataPartPtr & new_part)
 {
-    auto maybe_lock = getLockForOrdinary(storage);
+    checkNotOrdinaryDatabase(storage);
     std::lock_guard lock{mutex};
     checkIsNotCancelled();
     storages.insert(storage);
-    if (maybe_lock)
-        table_read_locks_for_ordinary_db.emplace_back(std::move(maybe_lock));
     creating_parts.push_back(new_part);
 }
 
 void MergeTreeTransaction::removeOldPart(const StoragePtr & storage, const DataPartPtr & part_to_remove, const TransactionInfoContext & context)
 {
-    auto maybe_lock = getLockForOrdinary(storage);
+    checkNotOrdinaryDatabase(storage);
 
     {
         std::lock_guard lock{mutex};
         checkIsNotCancelled();
 
-        LockMemoryExceptionInThread lock_memory_tracker(VariableContext::Global);
         part_to_remove->version.lockRemovalTID(tid, context);
-        storages.insert(storage);
-        if (maybe_lock)
-            table_read_locks_for_ordinary_db.emplace_back(std::move(maybe_lock));
-        removing_parts.push_back(part_to_remove);
+        NOEXCEPT_SCOPE({
+            storages.insert(storage);
+            removing_parts.push_back(part_to_remove);
+        });
     }
 
     part_to_remove->appendRemovalTIDToVersionMetadata();
@@ -146,19 +158,17 @@ void MergeTreeTransaction::removeOldPart(const StoragePtr & storage, const DataP
 
 void MergeTreeTransaction::addMutation(const StoragePtr & table, const String & mutation_id)
 {
-    auto maybe_lock = getLockForOrdinary(table);
+    checkNotOrdinaryDatabase(table);
     std::lock_guard lock{mutex};
     checkIsNotCancelled();
     storages.insert(table);
-    if (maybe_lock)
-        table_read_locks_for_ordinary_db.emplace_back(std::move(maybe_lock));
     mutations.emplace_back(table, mutation_id);
 }
 
 bool MergeTreeTransaction::isReadOnly() const
 {
     std::lock_guard lock{mutex};
-    assert((creating_parts.empty() && removing_parts.empty() && mutations.empty()) == storages.empty());
+    chassert((creating_parts.empty() && removing_parts.empty() && mutations.empty()) == storages.empty());
     return storages.empty();
 }
 
@@ -200,29 +210,43 @@ scope_guard MergeTreeTransaction::beforeCommit()
 
 void MergeTreeTransaction::afterCommit(CSN assigned_csn) noexcept
 {
+    LockMemoryExceptionInThread memory_tracker_lock(VariableContext::Global);
     /// Write allocated CSN into version metadata, so we will know CSN without reading it from transaction log
     /// and we will be able to remove old entries from transaction log in ZK.
     /// It's not a problem if server crash before CSN is written, because we already have TID in data part and entry in the log.
     [[maybe_unused]] CSN prev_value = csn.exchange(assigned_csn);
-    assert(prev_value == Tx::CommittingCSN);
-    for (const auto & part : creating_parts)
+    chassert(prev_value == Tx::CommittingCSN);
+
+    DataPartsVector created_parts;
+    DataPartsVector removed_parts;
+    RunningMutationsList committed_mutations;
+    {
+        /// We don't really need mutex here, because no concurrent modifications of transaction object may happen after commit.
+        std::lock_guard lock{mutex};
+        created_parts = creating_parts;
+        removed_parts = removing_parts;
+        committed_mutations = mutations;
+    }
+
+    for (const auto & part : created_parts)
     {
         part->version.creation_csn.store(csn);
         part->appendCSNToVersionMetadata(VersionMetadata::WhichCSN::CREATION);
     }
 
-    for (const auto & part : removing_parts)
+    for (const auto & part : removed_parts)
     {
         part->version.removal_csn.store(csn);
         part->appendCSNToVersionMetadata(VersionMetadata::WhichCSN::REMOVAL);
     }
 
-    for (const auto & storage_and_mutation : mutations)
+    for (const auto & storage_and_mutation : committed_mutations)
         storage_and_mutation.first->setMutationCSN(storage_and_mutation.second, csn);
 }
 
 bool MergeTreeTransaction::rollback() noexcept
 {
+    LockMemoryExceptionInThread memory_tracker_lock(VariableContext::Global);
     CSN expected = Tx::UnknownCSN;
     bool need_rollback = csn.compare_exchange_strong(expected, Tx::RolledBackCSN);
 
@@ -250,21 +274,6 @@ bool MergeTreeTransaction::rollback() noexcept
 
     /// Discard changes in active parts set
     /// Remove parts that were created, restore parts that were removed (except parts that were created by this transaction too)
-    for (const auto & part : parts_to_remove)
-    {
-        if (part->version.isRemovalTIDLocked())
-        {
-            /// Don't need to remove part from working set if it was created and removed by this transaction
-            assert(part->version.removal_tid_lock == tid.getHash());
-            continue;
-        }
-        /// FIXME do not lock removal_tid when rolling back part creation, it's ugly
-        const_cast<MergeTreeData &>(part->storage).removePartsFromWorkingSet(NO_TRANSACTION_RAW, {part}, true);
-    }
-
-    for (const auto & part : parts_to_activate)
-        if (part->version.getCreationTID() != tid)
-            const_cast<MergeTreeData &>(part->storage).restoreAndActivatePart(part);
 
     /// Kind of optimization: cleanup thread can remove these parts immediately
     for (const auto & part : parts_to_remove)
@@ -274,6 +283,18 @@ bool MergeTreeTransaction::rollback() noexcept
         part->appendCSNToVersionMetadata(VersionMetadata::CREATION);
     }
 
+    for (const auto & part : parts_to_remove)
+    {
+        /// NOTE It's possible that part is already removed from working set in the same transaction
+        /// (or, even worse, in a separate non-transactional query with PrehistoricTID),
+        /// but it's not a problem: removePartsFromWorkingSet(...) will do nothing in this case.
+        const_cast<MergeTreeData &>(part->storage).removePartsFromWorkingSet(NO_TRANSACTION_RAW, {part}, true);
+    }
+
+    for (const auto & part : parts_to_activate)
+        if (part->version.getCreationTID() != tid)
+            const_cast<MergeTreeData &>(part->storage).restoreAndActivatePart(part);
+
     for (const auto & part : parts_to_activate)
     {
         /// Clear removal_tid from version metadata file, so we will not need to distinguish TIDs that were not committed
@@ -302,7 +323,7 @@ void MergeTreeTransaction::onException()
 
 String MergeTreeTransaction::dumpDescription() const
 {
-    String res = fmt::format("{} state: {}, snapshot: {}", tid, getState(), snapshot);
+    String res = fmt::format("{} state: {}, snapshot: {}", tid, getState(), getSnapshot());
 
     if (isReadOnly())
     {
@@ -324,7 +345,7 @@ String MergeTreeTransaction::dumpDescription() const
     {
         String info = fmt::format("{} (created by {}, {})", part->name, part->version.getCreationTID(), part->version.creation_csn);
         std::get<1>(storage_to_changes[&(part->storage)]).push_back(std::move(info));
-        assert(!part->version.creation_csn || part->version.creation_csn <= snapshot);
+        chassert(!part->version.creation_csn || part->version.creation_csn <= getSnapshot());
     }
 
     for (const auto & mutation : mutations)
diff --git a/src/Interpreters/MergeTreeTransaction.h b/src/Interpreters/MergeTreeTransaction.h
index 7ebea450dd..0577ef2912 100644
--- a/src/Interpreters/MergeTreeTransaction.h
+++ b/src/Interpreters/MergeTreeTransaction.h
@@ -5,6 +5,8 @@
 #include <Storages/TableLockHolder.h>
 #include <Common/Stopwatch.h>
 #include <base/scope_guard.h>
+#include <Common/noexcept_scope.h>
+#include <base/defines.h>
 
 #include <list>
 #include <unordered_set>
@@ -18,7 +20,7 @@ using DataPartsVector = std::vector<DataPartPtr>;
 
 /// This object is responsible for tracking all changes that some transaction is making in MergeTree tables.
 /// It collects all changes that queries of current transaction made in data part sets of all MergeTree tables
-/// to ether make them visible when transaction commits or undo when transaction rolls back.
+/// to either make them visible when transaction commits or undo when transaction rolls back.
 class MergeTreeTransaction : public std::enable_shared_from_this<MergeTreeTransaction>, private boost::noncopyable
 {
     friend class TransactionLog;
@@ -26,17 +28,18 @@ public:
     enum State
     {
         RUNNING,
+        COMMITTING,
         COMMITTED,
         ROLLED_BACK,
     };
 
-    CSN getSnapshot() const { return snapshot; }
+    CSN getSnapshot() const { return snapshot.load(std::memory_order_relaxed); }
     void setSnapshot(CSN new_snapshot);
     State getState() const;
 
     const TransactionID tid;
 
-    MergeTreeTransaction(CSN snapshot_, LocalTID local_tid_, UUID host_id);
+    MergeTreeTransaction(CSN snapshot_, LocalTID local_tid_, UUID host_id, std::list<CSN>::iterator snapshot_it_);
 
     void addNewPart(const StoragePtr & storage, const DataPartPtr & new_part);
     void removeOldPart(const StoragePtr & storage, const DataPartPtr & part_to_remove, const TransactionInfoContext & context);
@@ -55,6 +58,11 @@ public:
 
     Float64 elapsedSeconds() const { return elapsed.elapsedSeconds(); }
 
+    /// Waits for transaction state to become not equal to the state corresponding to current_state_csn
+    bool waitStateChange(CSN current_state_csn) const;
+
+    CSN getCSN() const { return csn; }
+
 private:
     scope_guard beforeCommit();
     void afterCommit(CSN assigned_csn) noexcept;
@@ -65,16 +73,15 @@ private:
     Stopwatch elapsed;
 
     /// Usually it's equal to tid.start_csn, but can be changed by SET SNAPSHOT query (for introspection purposes and time-traveling)
-    CSN snapshot;
-    std::list<CSN>::iterator snapshot_in_use_it;
+    std::atomic<CSN> snapshot;
+    const std::list<CSN>::iterator snapshot_in_use_it;
 
     /// Lists of changes made by transaction
-    std::unordered_set<StoragePtr> storages;
-    std::vector<TableLockHolder> table_read_locks_for_ordinary_db;
-    DataPartsVector creating_parts;
-    DataPartsVector removing_parts;
+    std::unordered_set<StoragePtr> storages TSA_GUARDED_BY(mutex);
+    DataPartsVector creating_parts TSA_GUARDED_BY(mutex);
+    DataPartsVector removing_parts TSA_GUARDED_BY(mutex);
     using RunningMutationsList = std::vector<std::pair<StoragePtr, String>>;
-    RunningMutationsList mutations;
+    RunningMutationsList mutations TSA_GUARDED_BY(mutex);
 
     std::atomic<CSN> csn;
 };
diff --git a/src/Interpreters/MergeTreeTransactionHolder.cpp b/src/Interpreters/MergeTreeTransactionHolder.cpp
index bf63a47128..2944fb78b7 100644
--- a/src/Interpreters/MergeTreeTransactionHolder.cpp
+++ b/src/Interpreters/MergeTreeTransactionHolder.cpp
@@ -53,7 +53,7 @@ void MergeTreeTransactionHolder::onDestroy() noexcept
     {
         try
         {
-            TransactionLog::instance().commitTransaction(txn);
+            TransactionLog::instance().commitTransaction(txn, /* throw_on_unknown_status */ false);
             return;
         }
         catch (...)
diff --git a/src/Interpreters/TransactionLog.cpp b/src/Interpreters/TransactionLog.cpp
index 393a8aa848..ef78768d2c 100644
--- a/src/Interpreters/TransactionLog.cpp
+++ b/src/Interpreters/TransactionLog.cpp
@@ -9,18 +9,16 @@
 #include <Common/ZooKeeper/KeeperException.h>
 #include <Core/ServerUUID.h>
 #include <base/logger_useful.h>
+#include <Common/noexcept_scope.h>
 
 
-/// It's used in critical places to exit on unexpected exceptions.
-/// SIGABRT is usually better that broken state in memory with unpredictable consequences.
-#define NOEXCEPT_SCOPE SCOPE_EXIT({ if (std::uncaught_exceptions()) { tryLogCurrentException("NOEXCEPT_SCOPE"); abort(); } })
-
 namespace DB
 {
 
 namespace ErrorCodes
 {
     extern const int LOGICAL_ERROR;
+    extern const int UNKNOWN_STATUS_OF_TRANSACTION;
 }
 
 static void tryWriteEventToSystemLog(Poco::Logger * log, ContextPtr context,
@@ -45,14 +43,13 @@ catch (...)
 
 
 TransactionLog::TransactionLog()
-    : log(&Poco::Logger::get("TransactionLog"))
+    : global_context(Context::getGlobalContextInstance())
+    , log(&Poco::Logger::get("TransactionLog"))
+    , zookeeper_path(global_context->getConfigRef().getString("transaction_log.zookeeper_path", "/clickhouse/txn"))
+    , zookeeper_path_log(zookeeper_path + "/log")
+    , fault_probability_before_commit(global_context->getConfigRef().getDouble("transaction_log.fault_probability_before_commit", 0))
+    , fault_probability_after_commit(global_context->getConfigRef().getDouble("transaction_log.fault_probability_after_commit", 0))
 {
-    global_context = Context::getGlobalContextInstance();
-    global_context->checkTransactionsAreAllowed();
-
-    zookeeper_path = global_context->getConfigRef().getString("transaction_log.zookeeper_path", "/clickhouse/txn");
-    zookeeper_path_log = zookeeper_path + "/log";
-
     loadLogFromZooKeeper();
 
     updating_thread = ThreadFromGlobalPool(&TransactionLog::runUpdatingThread, this);
@@ -128,7 +125,7 @@ void TransactionLog::loadEntries(Strings::const_iterator beg, Strings::const_ite
     LOG_TRACE(log, "Loading {} entries from {}: {}..{}", entries_count, zookeeper_path_log, *beg, last_entry);
     futures.reserve(entries_count);
     for (auto it = beg; it != end; ++it)
-        futures.emplace_back(zookeeper->asyncGet(fs::path(zookeeper_path_log) / *it));
+        futures.emplace_back(TSA_READ_ONE_THREAD(zookeeper)->asyncGet(fs::path(zookeeper_path_log) / *it));
 
     std::vector<std::pair<TIDHash, CSNEntry>> loaded;
     loaded.reserve(entries_count);
@@ -143,26 +140,30 @@ void TransactionLog::loadEntries(Strings::const_iterator beg, Strings::const_ite
     }
     futures.clear();
 
-    NOEXCEPT_SCOPE;
-    LockMemoryExceptionInThread lock_memory_tracker(VariableContext::Global);
-    std::lock_guard lock{mutex};
-    for (const auto & entry : loaded)
-    {
-        if (entry.first == Tx::EmptyTID.getHash())
-            continue;
+    NOEXCEPT_SCOPE_STRICT({
+        std::lock_guard lock{mutex};
+        for (const auto & entry : loaded)
+        {
+            if (entry.first == Tx::EmptyTID.getHash())
+                continue;
+
+            tid_to_csn.emplace(entry.first, entry.second);
+        }
+        last_loaded_entry = last_entry;
+    });
 
-        tid_to_csn.emplace(entry.first, entry.second);
+    {
+        std::lock_guard lock{running_list_mutex};
+        latest_snapshot = loaded.back().second.csn;
+        local_tid_counter = Tx::MaxReservedLocalTID;
     }
-    last_loaded_entry = last_entry;
-    latest_snapshot = loaded.back().second.csn;
-    local_tid_counter = Tx::MaxReservedLocalTID;
 }
 
 void TransactionLog::loadLogFromZooKeeper()
 {
-    assert(!zookeeper);
-    assert(tid_to_csn.empty());
-    assert(last_loaded_entry.empty());
+    chassert(!zookeeper);
+    chassert(tid_to_csn.empty());
+    chassert(last_loaded_entry.empty());
     zookeeper = global_context->getZooKeeper();
 
     /// We do not write local_tid_counter to disk or zk and maintain it only in memory.
@@ -172,7 +173,7 @@ void TransactionLog::loadLogFromZooKeeper()
     if (code != Coordination::Error::ZOK)
     {
         /// Log probably does not exist, create it
-        assert(code == Coordination::Error::ZNONODE);
+        chassert(code == Coordination::Error::ZNONODE);
         zookeeper->createAncestors(zookeeper_path_log);
         Coordination::Requests ops;
         ops.emplace_back(zkutil::makeCreateRequest(zookeeper_path + "/tail_ptr", serializeCSN(Tx::MaxReservedCSN), zkutil::CreateMode::Persistent));
@@ -192,11 +193,11 @@ void TransactionLog::loadLogFromZooKeeper()
     /// 2. simplify log rotation
     /// 3. support 64-bit CSNs on top of Apache ZooKeeper (it uses Int32 for sequential numbers)
     Strings entries_list = zookeeper->getChildren(zookeeper_path_log, nullptr, log_updated_event);
-    assert(!entries_list.empty());
-    std::sort(entries_list.begin(), entries_list.end());
+    chassert(!entries_list.empty());
+    ::sort(entries_list.begin(), entries_list.end());
     loadEntries(entries_list.begin(), entries_list.end());
-    assert(!last_loaded_entry.empty());
-    assert(latest_snapshot == deserializeCSN(last_loaded_entry));
+    chassert(!last_loaded_entry.empty());
+    chassert(latest_snapshot == deserializeCSN(last_loaded_entry));
     local_tid_counter = Tx::MaxReservedLocalTID;
 
     tail_ptr = deserializeCSN(zookeeper->get(zookeeper_path + "/tail_ptr"));
@@ -208,30 +209,36 @@ void TransactionLog::runUpdatingThread()
     {
         try
         {
-            log_updated_event->wait();
+            /// Do not wait if we have some transactions to finalize
+            if (TSA_READ_ONE_THREAD(unknown_state_list_loaded).empty())
+                log_updated_event->wait();
+
             if (stop_flag.load())
                 return;
 
-            if (!zookeeper)
+            bool connection_loss = getZooKeeper()->expired();
+            if (connection_loss)
             {
                 auto new_zookeeper = global_context->getZooKeeper();
-                std::lock_guard lock{mutex};
-                zookeeper = new_zookeeper;
+                {
+                    std::lock_guard lock{mutex};
+                    zookeeper = new_zookeeper;
+                }
+
+                /// It's possible that we connected to different [Zoo]Keeper instance
+                /// so we may read a bit stale state.
+                TSA_READ_ONE_THREAD(zookeeper)->sync(zookeeper_path_log);
             }
 
             loadNewEntries();
             removeOldEntries();
+            tryFinalizeUnknownStateTransactions();
         }
-        catch (const Coordination::Exception & e)
+        catch (const Coordination::Exception &)
         {
             tryLogCurrentException(log);
             /// TODO better backoff
             std::this_thread::sleep_for(std::chrono::milliseconds(1000));
-            if (Coordination::isHardwareError(e.code))
-            {
-                std::lock_guard lock{mutex};
-                zookeeper.reset();
-            }
             log_updated_event->set();
         }
         catch (...)
@@ -245,13 +252,13 @@ void TransactionLog::runUpdatingThread()
 
 void TransactionLog::loadNewEntries()
 {
-    Strings entries_list = zookeeper->getChildren(zookeeper_path_log, nullptr, log_updated_event);
-    assert(!entries_list.empty());
-    std::sort(entries_list.begin(), entries_list.end());
-    auto it = std::upper_bound(entries_list.begin(), entries_list.end(), last_loaded_entry);
+    Strings entries_list = TSA_READ_ONE_THREAD(zookeeper)->getChildren(zookeeper_path_log, nullptr, log_updated_event);
+    chassert(!entries_list.empty());
+    ::sort(entries_list.begin(), entries_list.end());
+    auto it = std::upper_bound(entries_list.begin(), entries_list.end(), TSA_READ_ONE_THREAD(last_loaded_entry));
     loadEntries(it, entries_list.end());
-    assert(last_loaded_entry == entries_list.back());
-    assert(latest_snapshot == deserializeCSN(last_loaded_entry));
+    chassert(TSA_READ_ONE_THREAD(last_loaded_entry) == entries_list.back());
+    chassert(latest_snapshot == deserializeCSN(TSA_READ_ONE_THREAD(last_loaded_entry)));
     latest_snapshot.notify_all();
 }
 
@@ -271,7 +278,7 @@ void TransactionLog::removeOldEntries()
 
     /// TODO we will need a bit more complex logic for multiple hosts
     Coordination::Stat stat;
-    CSN old_tail_ptr = deserializeCSN(zookeeper->get(zookeeper_path + "/tail_ptr", &stat));
+    CSN old_tail_ptr = deserializeCSN(TSA_READ_ONE_THREAD(zookeeper)->get(zookeeper_path + "/tail_ptr", &stat));
     CSN new_tail_ptr = getOldestSnapshot();
     if (new_tail_ptr < old_tail_ptr)
         throw Exception(ErrorCodes::LOGICAL_ERROR, "Got unexpected tail_ptr {}, oldest snapshot is {}, it's a bug", old_tail_ptr, new_tail_ptr);
@@ -280,7 +287,7 @@ void TransactionLog::removeOldEntries()
 
     /// (it's not supposed to fail with ZBADVERSION while there is only one host)
     LOG_TRACE(log, "Updating tail_ptr from {} to {}", old_tail_ptr, new_tail_ptr);
-    zookeeper->set(zookeeper_path + "/tail_ptr", serializeCSN(new_tail_ptr), stat.version);
+    TSA_READ_ONE_THREAD(zookeeper)->set(zookeeper_path + "/tail_ptr", serializeCSN(new_tail_ptr), stat.version);
     tail_ptr.store(new_tail_ptr);
 
     /// Now we can find and remove old entries
@@ -304,7 +311,7 @@ void TransactionLog::removeOldEntries()
             continue;
 
         LOG_TEST(log, "Removing entry {} -> {}", elem.second.tid, elem.second.csn);
-        auto code = zookeeper->tryRemove(zookeeper_path_log + "/" + serializeCSN(elem.second.csn));
+        auto code = TSA_READ_ONE_THREAD(zookeeper)->tryRemove(zookeeper_path_log + "/" + serializeCSN(elem.second.csn));
         if (code == Coordination::Error::ZOK || code == Coordination::Error::ZNONODE)
             removed_entries.push_back(elem.first);
     }
@@ -314,6 +321,46 @@ void TransactionLog::removeOldEntries()
         tid_to_csn.erase(tid_hash);
 }
 
+void TransactionLog::tryFinalizeUnknownStateTransactions()
+{
+    /// We just recovered connection to [Zoo]Keeper.
+    /// Check if transactions in unknown state were actually committed or not and finalize or rollback them.
+    UnknownStateList list;
+    {
+        /// We must be sure that the corresponding CSN entry is loaded from ZK.
+        /// Otherwise we may accidentally rollback committed transaction in case of race condition like this:
+        ///   - runUpdatingThread: loaded some entries, ready to call tryFinalizeUnknownStateTransactions()
+        ///   - commitTransaction: creates CSN entry in the log (txn is committed)
+        ///   - [session expires]
+        ///   - commitTransaction: catches Coordination::Exception (maybe due to fault injection), appends txn to unknown_state_list
+        ///   - runUpdatingThread: calls tryFinalizeUnknownStateTransactions(), fails to find CSN for this txn, rolls it back
+        /// So all CSN entries that might exist at the moment of appending txn to unknown_state_list
+        /// must be loaded from ZK before we start finalize that txn.
+        /// That's why we use two lists here:
+        ///    1. At first we put txn into unknown_state_list
+        ///    2. We move it to unknown_state_list_loaded when runUpdatingThread done at least one iteration
+        ///    3. Then we can safely finalize txns from unknown_state_list_loaded, because all required entries are loaded
+        std::lock_guard lock{running_list_mutex};
+        std::swap(list, unknown_state_list);
+        std::swap(list, unknown_state_list_loaded);
+    }
+
+    for (auto & [txn, state_guard] : list)
+    {
+        /// CSNs must be already loaded, only need to check if the corresponding mapping exists.
+        if (auto csn = getCSN(txn->tid))
+        {
+            finalizeCommittedTransaction(txn, csn, state_guard);
+        }
+        else
+        {
+            assertTIDIsNotOutdated(txn->tid);
+            state_guard = {};
+            rollbackTransaction(txn->shared_from_this());
+        }
+    }
+}
+
 CSN TransactionLog::getLatestSnapshot() const
 {
     return latest_snapshot.load();
@@ -326,11 +373,11 @@ MergeTreeTransactionPtr TransactionLog::beginTransaction()
         std::lock_guard lock{running_list_mutex};
         CSN snapshot = latest_snapshot.load();
         LocalTID ltid = 1 + local_tid_counter.fetch_add(1);
-        txn = std::make_shared<MergeTreeTransaction>(snapshot, ltid, ServerUUID::get());
+        auto snapshot_lock = snapshots_in_use.insert(snapshots_in_use.end(), snapshot);
+        txn = std::make_shared<MergeTreeTransaction>(snapshot, ltid, ServerUUID::get(), snapshot_lock);
         bool inserted = running_list.try_emplace(txn->tid.getHash(), txn).second;
         if (!inserted)
             throw Exception(ErrorCodes::LOGICAL_ERROR, "I's a bug: TID {} {} exists", txn->tid.getHash(), txn->tid);
-        txn->snapshot_in_use_it = snapshots_in_use.insert(snapshots_in_use.end(), snapshot);
     }
 
     LOG_TEST(log, "Beginning transaction {} ({})", txn->tid, txn->tid.getHash());
@@ -339,69 +386,131 @@ MergeTreeTransactionPtr TransactionLog::beginTransaction()
     return txn;
 }
 
-CSN TransactionLog::commitTransaction(const MergeTreeTransactionPtr & txn)
+CSN TransactionLog::commitTransaction(const MergeTreeTransactionPtr & txn, bool throw_on_unknown_status)
 {
     /// Some precommit checks, may throw
-    auto committing_lock = txn->beforeCommit();
+    auto state_guard = txn->beforeCommit();
 
-    CSN new_csn;
+    CSN allocated_csn = Tx::UnknownCSN;
     if (txn->isReadOnly())
     {
         /// Don't need to allocate CSN in ZK for readonly transactions, it's safe to use snapshot/start_csn as "commit" timestamp
         LOG_TEST(log, "Closing readonly transaction {}", txn->tid);
-        new_csn = txn->snapshot;
-        tryWriteEventToSystemLog(log, global_context, TransactionsInfoLogElement::COMMIT, txn->tid, new_csn);
     }
     else
     {
         LOG_TEST(log, "Committing transaction {}", txn->dumpDescription());
-        /// TODO handle connection loss
         /// TODO support batching
         auto current_zookeeper = getZooKeeper();
-        String path_created = current_zookeeper->create(zookeeper_path_log + "/csn-", serializeTID(txn->tid), zkutil::CreateMode::PersistentSequential);    /// Commit point
-        NOEXCEPT_SCOPE;
-
-        /// FIXME Transactions: Sequential node numbers in ZooKeeper are Int32, but 31 bit is not enough for production use
-        /// (overflow is possible in a several weeks/months of active usage)
-        new_csn = deserializeCSN(path_created.substr(zookeeper_path_log.size() + 1));
+        String csn_path_created;
+        try
+        {
+            if (unlikely(fault_probability_before_commit))
+            {
+                std::bernoulli_distribution fault(fault_probability_before_commit);
+                if (fault(thread_local_rng))
+                    throw Coordination::Exception("Fault injected (before commit)", Coordination::Error::ZCONNECTIONLOSS);
+            }
 
-        LOG_INFO(log, "Transaction {} committed with CSN={}", txn->tid, new_csn);
-        tryWriteEventToSystemLog(log, global_context, TransactionsInfoLogElement::COMMIT, txn->tid, new_csn);
+            /// Commit point
+            csn_path_created = current_zookeeper->create(zookeeper_path_log + "/csn-", serializeTID(txn->tid), zkutil::CreateMode::PersistentSequential);
 
-        /// Wait for committed changes to become actually visible, so the next transaction in this session will see the changes
-        /// TODO it's optional, add a setting for this
-        auto current_latest_snapshot = latest_snapshot.load();
-        while (current_latest_snapshot < new_csn && !stop_flag)
+            if (unlikely(fault_probability_after_commit))
+            {
+                std::bernoulli_distribution fault(fault_probability_after_commit);
+                if (fault(thread_local_rng))
+                    throw Coordination::Exception("Fault injected (after commit)", Coordination::Error::ZCONNECTIONLOSS);
+            }
+        }
+        catch (const Coordination::Exception & e)
         {
-            latest_snapshot.wait(current_latest_snapshot);
-            current_latest_snapshot = latest_snapshot.load();
+            if (!Coordination::isHardwareError(e.code))
+                throw;
+
+            /// We don't know if transaction has been actually committed or not.
+            /// The only thing we can do is to postpone its finalization.
+            {
+                std::lock_guard lock{running_list_mutex};
+                unknown_state_list.emplace_back(txn.get(), std::move(state_guard));
+            }
+            log_updated_event->set();
+            if (throw_on_unknown_status)
+                throw Exception(ErrorCodes::UNKNOWN_STATUS_OF_TRANSACTION,
+                                "Connection lost on attempt to commit transaction {}, will finalize it later: {}",
+                                txn->tid, e.message());
+
+            LOG_INFO(log, "Connection lost on attempt to commit transaction {}, will finalize it later: {}", txn->tid, e.message());
+            return Tx::CommittingCSN;
         }
+
+        /// Do not allow exceptions between commit point and the and of transaction finalization
+        /// (otherwise it may stuck in COMMITTING state holding snapshot).
+        NOEXCEPT_SCOPE_STRICT({
+            /// FIXME Transactions: Sequential node numbers in ZooKeeper are Int32, but 31 bit is not enough for production use
+            /// (overflow is possible in a several weeks/months of active usage)
+            allocated_csn = deserializeCSN(csn_path_created.substr(zookeeper_path_log.size() + 1));
+        });
+    }
+
+    return finalizeCommittedTransaction(txn.get(), allocated_csn, state_guard);
+}
+
+CSN TransactionLog::finalizeCommittedTransaction(MergeTreeTransaction * txn, CSN allocated_csn, scope_guard & state_guard) noexcept
+{
+    LockMemoryExceptionInThread memory_tracker_lock(VariableContext::Global);
+    chassert(!allocated_csn == txn->isReadOnly());
+    if (allocated_csn)
+    {
+        LOG_INFO(log, "Transaction {} committed with CSN={}", txn->tid, allocated_csn);
+        tryWriteEventToSystemLog(log, global_context, TransactionsInfoLogElement::COMMIT, txn->tid, allocated_csn);
+    }
+    else
+    {
+        /// Transaction was readonly
+        allocated_csn = txn->snapshot;
+        tryWriteEventToSystemLog(log, global_context, TransactionsInfoLogElement::COMMIT, txn->tid, allocated_csn);
     }
 
     /// Write allocated CSN, so we will be able to cleanup log in ZK. This method is noexcept.
-    txn->afterCommit(new_csn);
+    txn->afterCommit(allocated_csn);
+    state_guard = {};
 
     {
         /// Finally we can remove transaction from the list and release the snapshot
         std::lock_guard lock{running_list_mutex};
+        snapshots_in_use.erase(txn->snapshot_in_use_it);
         bool removed = running_list.erase(txn->tid.getHash());
         if (!removed)
-            throw Exception(ErrorCodes::LOGICAL_ERROR, "I's a bug: TID {} {} doesn't exist", txn->tid.getHash(), txn->tid);
-        snapshots_in_use.erase(txn->snapshot_in_use_it);
+        {
+            LOG_ERROR(log , "I's a bug: TID {} {} doesn't exist", txn->tid.getHash(), txn->tid);
+            abort();
+        }
     }
 
-    return new_csn;
+    return allocated_csn;
+}
+
+bool TransactionLog::waitForCSNLoaded(CSN csn) const
+{
+    auto current_latest_snapshot = latest_snapshot.load();
+    while (current_latest_snapshot < csn && !stop_flag)
+    {
+        latest_snapshot.wait(current_latest_snapshot);
+        current_latest_snapshot = latest_snapshot.load();
+    }
+    return csn <= current_latest_snapshot;
 }
 
 void TransactionLog::rollbackTransaction(const MergeTreeTransactionPtr & txn) noexcept
 {
+    LockMemoryExceptionInThread memory_tracker_lock(VariableContext::Global);
     LOG_TRACE(log, "Rolling back transaction {}{}", txn->tid,
               std::uncaught_exceptions() ? fmt::format(" due to uncaught exception (code: {})", getCurrentExceptionCode()) : "");
 
     if (!txn->rollback())
     {
-        /// Transaction was cancelled concurrently, it's already rolled back.
-        assert(txn->csn == Tx::RolledBackCSN);
+        /// Transaction was cancelled or committed concurrently
+        chassert(txn->csn != Tx::UnknownCSN);
         return;
     }
 
@@ -443,8 +552,8 @@ CSN TransactionLog::getCSN(const TIDHash & tid)
 
 CSN TransactionLog::getCSNImpl(const TIDHash & tid_hash) const
 {
-    assert(tid_hash);
-    assert(tid_hash != Tx::EmptyTID.getHash());
+    chassert(tid_hash);
+    chassert(tid_hash != Tx::EmptyTID.getHash());
 
     std::lock_guard lock{mutex};
     auto it = tid_to_csn.find(tid_hash);
@@ -472,6 +581,8 @@ CSN TransactionLog::getOldestSnapshot() const
     std::lock_guard lock{running_list_mutex};
     if (snapshots_in_use.empty())
         return getLatestSnapshot();
+    chassert(running_list.size() == snapshots_in_use.size());
+    chassert(snapshots_in_use.size() < 2 || snapshots_in_use.front() <= *++snapshots_in_use.begin());
     return snapshots_in_use.front();
 }
 
@@ -481,4 +592,14 @@ TransactionLog::TransactionsList TransactionLog::getTransactionsList() const
     return running_list;
 }
 
+
+void TransactionLog::sync() const
+{
+    Strings entries_list = getZooKeeper()->getChildren(zookeeper_path_log);
+    chassert(!entries_list.empty());
+    ::sort(entries_list.begin(), entries_list.end());
+    CSN newest_csn = deserializeCSN(entries_list.back());
+    waitForCSNLoaded(newest_csn);
+}
+
 }
diff --git a/src/Interpreters/TransactionLog.h b/src/Interpreters/TransactionLog.h
index 86584a74c6..c646d1dcda 100644
--- a/src/Interpreters/TransactionLog.h
+++ b/src/Interpreters/TransactionLog.h
@@ -3,6 +3,7 @@
 #include <Interpreters/MergeTreeTransactionHolder.h>
 #include <Common/ZooKeeper/ZooKeeper.h>
 #include <Common/ThreadPool.h>
+#include <base/defines.h>
 #include <boost/noncopyable.hpp>
 #include <mutex>
 #include <unordered_map>
@@ -97,7 +98,8 @@ public:
     /// Tries to commit transaction. Returns Commit Sequence Number.
     /// Throw if transaction was concurrently killed or if some precommit check failed.
     /// May throw if ZK connection is lost. Transaction status is unknown in this case.
-    CSN commitTransaction(const MergeTreeTransactionPtr & txn);
+    /// Returns CommittingCSN if throw_on_unknown_status is false and connection was lost.
+    CSN commitTransaction(const MergeTreeTransactionPtr & txn, bool throw_on_unknown_status);
 
     /// Releases locks that that were acquired by transaction, releases snapshot, removes transaction from the list of active transactions.
     /// Normally it should not throw, but if it does for some reason (global memory limit exceeded, disk failure, etc)
@@ -119,14 +121,26 @@ public:
     /// Returns copy of list of running transactions.
     TransactionsList getTransactionsList() const;
 
+    /// Waits for provided CSN (and all previous ones) to be loaded from the log.
+    /// Returns false if waiting was interrupted (e.g. by shutdown)
+    bool waitForCSNLoaded(CSN csn) const;
+
+    bool isShuttingDown() const { return stop_flag.load(); }
+
+    void sync() const;
+
 private:
-    void loadLogFromZooKeeper();
+    void loadLogFromZooKeeper() TSA_REQUIRES(mutex);
     void runUpdatingThread();
 
     void loadEntries(Strings::const_iterator beg, Strings::const_iterator end);
     void loadNewEntries();
     void removeOldEntries();
 
+    CSN finalizeCommittedTransaction(MergeTreeTransaction * txn, CSN allocated_csn, scope_guard & state_guard) noexcept;
+
+    void tryFinalizeUnknownStateTransactions();
+
     static UInt64 deserializeCSN(const String & csn_node_name);
     static String serializeCSN(CSN csn);
     static TransactionID deserializeTID(const String & csn_node_content);
@@ -136,8 +150,8 @@ private:
 
     CSN getCSNImpl(const TIDHash & tid_hash) const;
 
-    ContextPtr global_context;
-    Poco::Logger * log;
+    const ContextPtr global_context;
+    Poco::Logger * const log;
 
     /// The newest snapshot available for reading
     std::atomic<CSN> latest_snapshot;
@@ -154,20 +168,24 @@ private:
         TransactionID tid;
     };
     using TIDMap = std::unordered_map<TIDHash, CSNEntry>;
-    TIDMap tid_to_csn;
+    TIDMap tid_to_csn TSA_GUARDED_BY(mutex);
 
     mutable std::mutex running_list_mutex;
     /// Transactions that are currently processed
-    TransactionsList running_list;
+    TransactionsList running_list TSA_GUARDED_BY(running_list_mutex);
+    /// If we lost connection on attempt to create csn- node then we don't know transaction's state.
+    using UnknownStateList = std::vector<std::pair<MergeTreeTransaction *, scope_guard>>;
+    UnknownStateList unknown_state_list TSA_GUARDED_BY(running_list_mutex);
+    UnknownStateList unknown_state_list_loaded TSA_GUARDED_BY(running_list_mutex);
     /// Ordered list of snapshots that are currently used by some transactions. Needed for background cleanup.
-    std::list<CSN> snapshots_in_use;
+    std::list<CSN> snapshots_in_use TSA_GUARDED_BY(running_list_mutex);
 
-    ZooKeeperPtr zookeeper;
-    String zookeeper_path;
+    ZooKeeperPtr zookeeper TSA_GUARDED_BY(mutex);
+    const String zookeeper_path;
 
-    String zookeeper_path_log;
+    const String zookeeper_path_log;
     /// Name of the newest entry that was loaded from log in ZK
-    String last_loaded_entry;
+    String last_loaded_entry TSA_GUARDED_BY(mutex);
     /// The oldest CSN such that we store in log entries with TransactionIDs containing this CSN.
     std::atomic<CSN> tail_ptr = Tx::UnknownCSN;
 
@@ -175,6 +193,9 @@ private:
 
     std::atomic_bool stop_flag = false;
     ThreadFromGlobalPool updating_thread;
+
+    const Float64 fault_probability_before_commit = 0;
+    const Float64 fault_probability_after_commit = 0;
 };
 
 template <typename Derived>
diff --git a/src/Interpreters/TransactionVersionMetadata.cpp b/src/Interpreters/TransactionVersionMetadata.cpp
index ac02f29661..286d741ffa 100644
--- a/src/Interpreters/TransactionVersionMetadata.cpp
+++ b/src/Interpreters/TransactionVersionMetadata.cpp
@@ -88,19 +88,15 @@ void VersionMetadata::lockRemovalTID(const TransactionID & tid, const Transactio
 
 bool VersionMetadata::tryLockRemovalTID(const TransactionID & tid, const TransactionInfoContext & context, TIDHash * locked_by_id)
 {
-    assert(!tid.isEmpty());
-    assert(!creation_tid.isEmpty());
+    chassert(!tid.isEmpty());
+    chassert(!creation_tid.isEmpty());
     TIDHash removal_lock_value = tid.getHash();
     TIDHash expected_removal_lock_value = 0;
     bool locked = removal_tid_lock.compare_exchange_strong(expected_removal_lock_value, removal_lock_value);
     if (!locked)
     {
-        if (tid == Tx::PrehistoricTID && expected_removal_lock_value == Tx::PrehistoricTID.getHash())
-        {
-            /// Don't need to lock part for queries without transaction
-            LOG_TEST(log, "Assuming removal_tid is locked by {}, table: {}, part: {}", tid, context.table.getNameForLogs(), context.part_name);
-            return true;
-        }
+        if (expected_removal_lock_value == removal_lock_value)
+            throw Exception(ErrorCodes::LOGICAL_ERROR, "Tried to lock part {} for removal second time by {}", context.part_name, tid);
 
         if (locked_by_id)
             *locked_by_id = expected_removal_lock_value;
@@ -115,7 +111,7 @@ bool VersionMetadata::tryLockRemovalTID(const TransactionID & tid, const Transac
 void VersionMetadata::unlockRemovalTID(const TransactionID & tid, const TransactionInfoContext & context)
 {
     LOG_TEST(log, "Unlocking removal_tid by {}, table: {}, part: {}", tid, context.table.getNameForLogs(), context.part_name);
-    assert(!tid.isEmpty());
+    chassert(!tid.isEmpty());
     TIDHash removal_lock_value = tid.getHash();
     TIDHash locked_by = removal_tid_lock.load();
 
@@ -144,8 +140,8 @@ bool VersionMetadata::isRemovalTIDLocked() const
 
 void VersionMetadata::setCreationTID(const TransactionID & tid, TransactionInfoContext * context)
 {
-    /// NOTE ReplicatedMergeTreeBlockOutputStream may add one part multiple times
-    assert(creation_tid.isEmpty() || creation_tid == tid);
+    /// NOTE ReplicatedMergeTreeSink may add one part multiple times
+    chassert(creation_tid.isEmpty() || creation_tid == tid);
     creation_tid = tid;
     if (context)
         tryWriteEventToSystemLog(log, TransactionsInfoLogElement::ADD_PART, tid, *context);
@@ -158,7 +154,7 @@ bool VersionMetadata::isVisible(const MergeTreeTransaction & txn)
 
 bool VersionMetadata::isVisible(CSN snapshot_version, TransactionID current_tid)
 {
-    assert(!creation_tid.isEmpty());
+    chassert(!creation_tid.isEmpty());
     CSN creation = creation_csn.load(std::memory_order_relaxed);
     TIDHash removal_lock = removal_tid_lock.load(std::memory_order_relaxed);
     CSN removal = removal_csn.load(std::memory_order_relaxed);
@@ -166,10 +162,10 @@ bool VersionMetadata::isVisible(CSN snapshot_version, TransactionID current_tid)
     [[maybe_unused]] bool had_creation_csn = creation;
     [[maybe_unused]] bool had_removal_tid = removal_lock;
     [[maybe_unused]] bool had_removal_csn = removal;
-    assert(!had_removal_csn || had_removal_tid);
-    assert(!had_removal_csn || had_creation_csn);
-    assert(creation == Tx::UnknownCSN || creation == Tx::PrehistoricCSN || Tx::MaxReservedCSN < creation);
-    assert(removal == Tx::UnknownCSN || removal == Tx::PrehistoricCSN || Tx::MaxReservedCSN < removal);
+    chassert(!had_removal_csn || had_removal_tid);
+    chassert(!had_removal_csn || had_creation_csn);
+    chassert(creation == Tx::UnknownCSN || creation == Tx::PrehistoricCSN || Tx::MaxReservedCSN < creation);
+    chassert(removal == Tx::UnknownCSN || removal == Tx::PrehistoricCSN || Tx::MaxReservedCSN < removal);
 
     /// Special snapshot for introspection purposes
     if (unlikely(snapshot_version == Tx::EverythingVisibleCSN))
@@ -204,8 +200,8 @@ bool VersionMetadata::isVisible(CSN snapshot_version, TransactionID current_tid)
     /// Data part has creation_tid/removal_tid, but does not have creation_csn/removal_csn.
     /// It means that some transaction is creating/removing the part right now or has done it recently
     /// and we don't know if it was already committed or not.
-    assert(!had_creation_csn || (had_removal_tid && !had_removal_csn));
-    assert(current_tid.isEmpty() || (creation_tid != current_tid && removal_lock != current_tid.getHash()));
+    chassert(!had_creation_csn || (had_removal_tid && !had_removal_csn));
+    chassert(current_tid.isEmpty() || (creation_tid != current_tid && removal_lock != current_tid.getHash()));
 
     /// Before doing CSN lookup, let's check some extra conditions.
     /// If snapshot_version <= some_tid.start_csn, then changes of the transaction with some_tid
@@ -347,8 +343,8 @@ void VersionMetadata::write(WriteBuffer & buf) const
 
     if (removal_tid_lock)
     {
-        assert(!removal_tid.isEmpty());
-        assert(removal_tid.getHash() == removal_tid_lock);
+        chassert(!removal_tid.isEmpty());
+        chassert(removal_tid.getHash() == removal_tid_lock);
         writeRemovalTID(buf);
         writeCSN(buf, REMOVAL, /* internal */ true);
     }
@@ -384,21 +380,23 @@ void VersionMetadata::read(ReadBuffer & buf)
 
         if (name == CREATION_CSN_STR)
         {
-            assert(!creation_csn);
+            chassert(!creation_csn);
             creation_csn = read_csn();
         }
         else if (name == REMOVAL_TID_STR)
         {
             /// NOTE Metadata file may actually contain multiple creation TIDs, we need the last one.
             removal_tid = TransactionID::read(buf);
-            if (!removal_tid.isEmpty())
+            if (removal_tid.isEmpty())
+                removal_tid_lock = 0;
+            else
                 removal_tid_lock = removal_tid.getHash();
         }
         else if (name == REMOVAL_CSN_STR)
         {
             if (removal_tid.isEmpty())
                 throw Exception(ErrorCodes::CANNOT_PARSE_TEXT, "Found removal_csn in metadata file, but removal_tid is {}", removal_tid);
-            assert(!removal_csn);
+            chassert(!removal_csn);
             removal_csn = read_csn();
         }
         else
diff --git a/src/Interpreters/TransactionVersionMetadata.h b/src/Interpreters/TransactionVersionMetadata.h
index 55ed56fb96..18ac445cc2 100644
--- a/src/Interpreters/TransactionVersionMetadata.h
+++ b/src/Interpreters/TransactionVersionMetadata.h
@@ -9,6 +9,7 @@ class Logger;
 
 namespace DB
 {
+
 /// This structure allows to pass more information about a part that transaction is trying to create/remove.
 /// It's useful for logging and for exception messages.
 struct TransactionInfoContext
diff --git a/src/Interpreters/TransactionsInfoLog.cpp b/src/Interpreters/TransactionsInfoLog.cpp
index 0498ee00e9..b62cd4672d 100644
--- a/src/Interpreters/TransactionsInfoLog.cpp
+++ b/src/Interpreters/TransactionsInfoLog.cpp
@@ -55,7 +55,7 @@ void TransactionsInfoLogElement::fillCommonFields(const TransactionInfoContext *
     event_time = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
     thread_id = getThreadId();
 
-    query_id = CurrentThread::getQueryId().toString();
+    query_id = std::string(CurrentThread::getQueryId());
 
     if (!context)
         return;
diff --git a/src/Interpreters/TransactionsInfoLog.h b/src/Interpreters/TransactionsInfoLog.h
index f595413a72..fc3783b591 100644
--- a/src/Interpreters/TransactionsInfoLog.h
+++ b/src/Interpreters/TransactionsInfoLog.h
@@ -42,6 +42,7 @@ struct TransactionsInfoLogElement
     static NamesAndTypesList getNamesAndTypes();
     static NamesAndAliases getNamesAndAliases() { return {}; }
     void appendToBlock(MutableColumns & columns) const;
+    static const char * getCustomColumnList() { return nullptr; }
 
     void fillCommonFields(const TransactionInfoContext * context = nullptr);
 };
diff --git a/src/Interpreters/ZooKeeperLog.h b/src/Interpreters/ZooKeeperLog.h
index 284675a7ff..d79b75ec85 100644
--- a/src/Interpreters/ZooKeeperLog.h
+++ b/src/Interpreters/ZooKeeperLog.h
@@ -22,9 +22,13 @@ struct ZooKeeperLogElement
 
     Type type = UNKNOWN;
     Decimal64 event_time = 0;
+    UInt64 thread_id = 0;
+    String query_id;
     Poco::Net::SocketAddress address;
     Int64 session_id = 0;
 
+    UInt64 duration_ms = 0;
+
     /// Common request info
     Int32 xid = 0;
     bool has_watch = false;
@@ -67,6 +71,7 @@ struct ZooKeeperLogElement
     static NamesAndTypesList getNamesAndTypes();
     static NamesAndAliases getNamesAndAliases() { return {}; }
     void appendToBlock(MutableColumns & columns) const;
+    static const char * getCustomColumnList() { return nullptr; }
 };
 
 class ZooKeeperLog : public SystemLog<ZooKeeperLogElement>
diff --git a/src/Interpreters/executeQuery.cpp b/src/Interpreters/executeQuery.cpp
index a242232556..f7467a1bdf 100644
--- a/src/Interpreters/executeQuery.cpp
+++ b/src/Interpreters/executeQuery.cpp
@@ -45,17 +45,18 @@
 #include <Interpreters/ApplyWithGlobalVisitor.h>
 #include <Interpreters/Context.h>
 #include <Interpreters/InterpreterFactory.h>
-#include <Interpreters/InterpreterSetQuery.h>
 #include <Interpreters/InterpreterInsertQuery.h>
+#include <Interpreters/InterpreterSetQuery.h>
+#include <Interpreters/InterpreterTransactionControlQuery.h>
 #include <Interpreters/NormalizeSelectWithUnionQueryVisitor.h>
 #include <Interpreters/OpenTelemetrySpanLog.h>
 #include <Interpreters/ProcessList.h>
 #include <Interpreters/QueryLog.h>
 #include <Interpreters/ReplaceQueryParameterVisitor.h>
+#include <Interpreters/SelectIntersectExceptQueryVisitor.h>
 #include <Interpreters/SelectQueryOptions.h>
-#include <Interpreters/executeQuery.h>
 #include <Interpreters/TransactionLog.h>
-#include <Interpreters/SelectIntersectExceptQueryVisitor.h>
+#include <Interpreters/executeQuery.h>
 #include <Common/ProfileEvents.h>
 
 #include <Common/SensitiveDataMasker.h>
@@ -445,9 +446,12 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(
 
         if (auto txn = context->getCurrentTransaction())
         {
-            assert(txn->getState() != MergeTreeTransaction::COMMITTED);
+            chassert(txn->getState() != MergeTreeTransaction::COMMITTING);
+            chassert(txn->getState() != MergeTreeTransaction::COMMITTED);
             if (txn->getState() == MergeTreeTransaction::ROLLED_BACK && !ast->as<ASTTransactionControl>() && !ast->as<ASTExplainQuery>())
-                throw Exception(ErrorCodes::INVALID_TRANSACTION, "Cannot execute query: transaction is rolled back");
+                throw Exception(
+                    ErrorCodes::INVALID_TRANSACTION,
+                    "Cannot execute query because current transaction failed. Expecting ROLLBACK statement");
         }
 
         /// Interpret SETTINGS clauses as early as possible (before invoking the corresponding interpreter),
@@ -529,6 +533,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(
     BlockIO res;
 
     String query_for_logging;
+    std::shared_ptr<InterpreterTransactionControlQuery> implicit_txn_control{};
 
     try
     {
@@ -652,11 +657,37 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(
             if (!table_id.empty())
                 context->setInsertionTable(table_id);
 
-            if (context->getCurrentTransaction() && context->getSettingsRef().throw_on_unsupported_query_inside_transaction)
+            if (context->getCurrentTransaction() && settings.throw_on_unsupported_query_inside_transaction)
                 throw Exception(ErrorCodes::NOT_IMPLEMENTED, "Async inserts inside transactions are not supported");
+            if (settings.implicit_transaction && settings.throw_on_unsupported_query_inside_transaction)
+                throw Exception(ErrorCodes::NOT_IMPLEMENTED, "Async inserts with 'implicit_transaction' are not supported");
         }
         else
         {
+            /// We need to start the (implicit) transaction before getting the interpreter as this will get links to the latest snapshots
+            if (!context->getCurrentTransaction() && settings.implicit_transaction && !ast->as<ASTTransactionControl>())
+            {
+                try
+                {
+                    if (context->isGlobalContext())
+                        throw Exception(ErrorCodes::LOGICAL_ERROR, "Global context cannot create transactions");
+
+                    /// If there is no session (which is the default for the HTTP Handler), set up one just for this as it is necessary
+                    /// to control the transaction lifetime
+                    if (!context->hasSessionContext())
+                        context->makeSessionContext();
+
+                    auto tc = std::make_shared<InterpreterTransactionControlQuery>(ast, context);
+                    tc->executeBegin(context->getSessionContext());
+                    implicit_txn_control = std::move(tc);
+                }
+                catch (Exception & e)
+                {
+                    e.addMessage("while starting a transaction with 'implicit_transaction'");
+                    throw;
+                }
+            }
+
             interpreter = InterpreterFactory::get(ast, context, SelectQueryOptions(stage).setInternal(internal));
 
             if (context->getCurrentTransaction() && !interpreter->supportsTransactions() &&
@@ -840,14 +871,15 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(
             };
 
             /// Also make possible for caller to log successful query finish and exception during execution.
-            auto finish_callback = [elem, context, ast,
-                 log_queries,
-                 log_queries_min_type = settings.log_queries_min_type,
-                 log_queries_min_query_duration_ms = settings.log_queries_min_query_duration_ms.totalMilliseconds(),
-                 status_info_to_query_log,
-                 pulling_pipeline = pipeline.pulling()
-            ]
-                (QueryPipeline & query_pipeline) mutable
+            auto finish_callback = [elem,
+                                    context,
+                                    ast,
+                                    log_queries,
+                                    log_queries_min_type = settings.log_queries_min_type,
+                                    log_queries_min_query_duration_ms = settings.log_queries_min_query_duration_ms.totalMilliseconds(),
+                                    status_info_to_query_log,
+                                    implicit_txn_control,
+                                    pulling_pipeline = pipeline.pulling()](QueryPipeline & query_pipeline) mutable
             {
                 QueryStatus * process_list_elem = context->getProcessListElement();
 
@@ -870,11 +902,6 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(
                 elem.event_time_microseconds = time_in_microseconds(finish_time);
                 status_info_to_query_log(elem, info, ast, context);
 
-                auto progress_callback = context->getProgressCallback();
-
-                if (progress_callback)
-                    progress_callback(Progress(WriteProgress(info.written_rows, info.written_bytes)));
-
                 if (pulling_pipeline)
                 {
                     query_pipeline.tryGetResultRowsAndBytes(elem.result_rows, elem.result_bytes);
@@ -883,9 +910,14 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(
                 {
                     auto progress_out = process_list_elem->getProgressOut();
                     elem.result_rows = progress_out.written_rows;
-                    elem.result_bytes = progress_out.written_rows;
+                    elem.result_bytes = progress_out.written_bytes;
                 }
 
+                auto progress_callback = context->getProgressCallback();
+                if (progress_callback)
+                    progress_callback(Progress(WriteProgress(info.written_rows, info.written_bytes)));
+
+
                 if (elem.read_rows != 0)
                 {
                     LOG_INFO(&Poco::Logger::get("executeQuery"), "Read {} rows, {} in {} sec., {} rows/sec., {}/sec.",
@@ -930,15 +962,40 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(
 
                     opentelemetry_span_log->add(span);
                 }
+
+                if (implicit_txn_control)
+                {
+                    try
+                    {
+                        implicit_txn_control->executeCommit(context->getSessionContext());
+                        implicit_txn_control.reset();
+                    }
+                    catch (const Exception &)
+                    {
+                        /// An exception might happen when trying to commit the transaction. For example we might get an immediate exception
+                        /// because ZK is down and wait_changes_become_visible_after_commit_mode == WAIT_UNKNOWN
+                        implicit_txn_control.reset();
+                        throw;
+                    }
+                }
             };
 
-            auto exception_callback = [elem, context, ast,
-                 log_queries,
-                 log_queries_min_type = settings.log_queries_min_type,
-                 log_queries_min_query_duration_ms = settings.log_queries_min_query_duration_ms.totalMilliseconds(),
-                 quota(quota), status_info_to_query_log] () mutable
+            auto exception_callback = [elem,
+                                       context,
+                                       ast,
+                                       log_queries,
+                                       log_queries_min_type = settings.log_queries_min_type,
+                                       log_queries_min_query_duration_ms = settings.log_queries_min_query_duration_ms.totalMilliseconds(),
+                                       quota(quota),
+                                       status_info_to_query_log,
+                                       implicit_txn_control]() mutable
             {
-                if (auto txn = context->getCurrentTransaction())
+                if (implicit_txn_control)
+                {
+                    implicit_txn_control->executeRollback(context->getSessionContext());
+                    implicit_txn_control.reset();
+                }
+                else if (auto txn = context->getCurrentTransaction())
                     txn->onException();
 
                 if (quota)
@@ -973,7 +1030,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(
                 logException(context, elem);
 
                 /// In case of exception we log internal queries also
-                if (log_queries && elem.type >= log_queries_min_type && Int64(elem.query_duration_ms) >= log_queries_min_query_duration_ms)
+                if (log_queries && elem.type >= log_queries_min_type && static_cast<Int64>(elem.query_duration_ms) >= log_queries_min_query_duration_ms)
                 {
                     if (auto query_log = context->getQueryLog())
                         query_log->add(elem);
@@ -988,7 +1045,6 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(
                 {
                     ProfileEvents::increment(ProfileEvents::FailedInsertQuery);
                 }
-
             };
 
             res.finish_callback = std::move(finish_callback);
@@ -997,8 +1053,15 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(
     }
     catch (...)
     {
-        if (auto txn = context->getCurrentTransaction())
+        if (implicit_txn_control)
+        {
+            implicit_txn_control->executeRollback(context->getSessionContext());
+            implicit_txn_control.reset();
+        }
+        else if (auto txn = context->getCurrentTransaction())
+        {
             txn->onException();
+        }
 
         if (!internal)
         {
diff --git a/src/Parsers/ASTSystemQuery.h b/src/Parsers/ASTSystemQuery.h
index 22488e35e1..37b0ad9250 100644
--- a/src/Parsers/ASTSystemQuery.h
+++ b/src/Parsers/ASTSystemQuery.h
@@ -35,6 +35,7 @@ public:
         RESTORE_REPLICA,
         DROP_REPLICA,
         SYNC_REPLICA,
+        SYNC_TRANSACTION_LOG,
         RELOAD_DICTIONARY,
         RELOAD_DICTIONARIES,
         RELOAD_MODEL,
diff --git a/src/Parsers/ParserQuery.h b/src/Parsers/ParserQuery.h
index be72a436be..c19eedfabd 100644
--- a/src/Parsers/ParserQuery.h
+++ b/src/Parsers/ParserQuery.h
@@ -1,3 +1,8 @@
+/* Please note that the file has been modified by Moqi Technology (Beijing) Co.,
+ * Ltd. All the modifications are Copyright (C) 2022 Moqi Technology (Beijing)
+ * Co., Ltd. */
+
+
 #pragma once
 
 #include <Parsers/IParserBase.h>
diff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp
index 8551cb26cf..3a61cb782c 100644
--- a/src/Storages/MergeTree/MergeTreeData.cpp
+++ b/src/Storages/MergeTree/MergeTreeData.cpp
@@ -6332,10 +6332,10 @@ void MergeTreeData::setDataVolume(size_t bytes, size_t rows, size_t parts)
 bool MergeTreeData::insertQueryIdOrThrow(const String & query_id, size_t max_queries) const
 {
     std::lock_guard lock(query_id_set_mutex);
-    return insertQueryIdOrThrowNoLock(query_id, max_queries, lock);
+    return insertQueryIdOrThrowNoLock(query_id, max_queries);
 }
 
-bool MergeTreeData::insertQueryIdOrThrowNoLock(const String & query_id, size_t max_queries, const std::lock_guard<std::mutex> &) const
+bool MergeTreeData::insertQueryIdOrThrowNoLock(const String & query_id, size_t max_queries) const
 {
     if (query_id_set.find(query_id) != query_id_set.end())
         return false;
@@ -6349,10 +6349,10 @@ bool MergeTreeData::insertQueryIdOrThrowNoLock(const String & query_id, size_t m
 void MergeTreeData::removeQueryId(const String & query_id) const
 {
     std::lock_guard lock(query_id_set_mutex);
-    removeQueryIdNoLock(query_id, lock);
+    removeQueryIdNoLock(query_id);
 }
 
-void MergeTreeData::removeQueryIdNoLock(const String & query_id, const std::lock_guard<std::mutex> &) const
+void MergeTreeData::removeQueryIdNoLock(const String & query_id) const
 {
     if (query_id_set.find(query_id) == query_id_set.end())
         LOG_WARNING(log, "We have query_id removed but it's not recorded. This is a bug");
diff --git a/src/Storages/MergeTree/MergeTreeData.h b/src/Storages/MergeTree/MergeTreeData.h
index 3a120c6937..8bee0fe3e3 100644
--- a/src/Storages/MergeTree/MergeTreeData.h
+++ b/src/Storages/MergeTree/MergeTreeData.h
@@ -467,16 +467,6 @@ public:
         DataPartStateVector * out_states = nullptr,
         bool require_projection_parts = false) const;
 
-    /// Returns all detached parts
-    DetachedPartsInfo getDetachedParts() const;
-
-    static void validateDetachedPartName(const String & name);
-
-    void dropDetached(const ASTPtr & partition, bool part, ContextPtr context);
-
-    MutableDataPartsVector tryLoadPartsToAttach(const ASTPtr & partition, bool attach_part,
-                                                ContextPtr context, PartsTemporaryRename & renamed_parts);
-
     /// Returns parts in Active state
     DataParts getDataPartsForInternalUsage() const;
     DataPartsVector getDataPartsVectorForInternalUsage() const;
@@ -499,9 +489,14 @@ public:
     void swapActivePart(MergeTreeData::DataPartPtr part_copy);
 
     /// Returns all parts in specified partition
+    DataPartsVector getVisibleDataPartsVectorInPartition(MergeTreeTransaction * txn, const String & partition_id, DataPartsLock * acquired_lock = nullptr) const;
+    DataPartsVector getVisibleDataPartsVectorInPartition(ContextPtr local_context, const String & partition_id, DataPartsLock & lock) const;
     DataPartsVector getVisibleDataPartsVectorInPartition(ContextPtr local_context, const String & partition_id) const;
     DataPartsVector getVisibleDataPartsVectorInPartitions(ContextPtr local_context, const std::unordered_set<String> & partition_ids) const;
 
+    DataPartsVector getDataPartsVectorInPartitionForInternalUsage(const DataPartState & state, const String & partition_id, DataPartsLock * acquired_lock = nullptr) const;
+    DataPartsVector getDataPartsVectorInPartitionForInternalUsage(const DataPartStates & affordable_states, const String & partition_id, DataPartsLock * acquired_lock = nullptr) const;
+
     /// Returns the part with the given name and state or nullptr if no such part.
     DataPartPtr getPartIfExists(const String & part_name, const DataPartStates & valid_states);
     DataPartPtr getPartIfExists(const MergeTreePartInfo & part_info, const DataPartStates & valid_states);
@@ -520,6 +515,18 @@ public:
     /// Makes sense only for ordinary MergeTree engines because for them block numbering doesn't depend on partition.
     std::optional<Int64> getMinPartDataVersion() const;
 
+
+    /// Returns all detached parts
+    DetachedPartsInfo getDetachedParts() const;
+
+    static void validateDetachedPartName(const String & name);
+
+    void dropDetached(const ASTPtr & partition, bool part, ContextPtr context);
+
+    MutableDataPartsVector tryLoadPartsToAttach(const ASTPtr & partition, bool attach_part,
+                                                ContextPtr context, PartsTemporaryRename & renamed_parts);
+
+
     /// If the table contains too many active parts, sleep for a while to give them time to merge.
     /// If until is non-null, wake up from the sleep earlier if the event happened.
     void delayInsertOrThrowIfNeeded(Poco::Event * until = nullptr) const;
@@ -897,11 +904,11 @@ public:
     /// Record current query id where querying the table. Throw if there are already `max_queries` queries accessing the same table.
     /// Returns false if the `query_id` already exists in the running set, otherwise return true.
     bool insertQueryIdOrThrow(const String & query_id, size_t max_queries) const;
-    bool insertQueryIdOrThrowNoLock(const String & query_id, size_t max_queries, const std::lock_guard<std::mutex> &) const;
+    bool insertQueryIdOrThrowNoLock(const String & query_id, size_t max_queries) const TSA_REQUIRES(query_id_set_mutex);
 
     /// Remove current query id after query finished.
     void removeQueryId(const String & query_id) const;
-    void removeQueryIdNoLock(const String & query_id, const std::lock_guard<std::mutex> &) const;
+    void removeQueryIdNoLock(const String & query_id) const TSA_REQUIRES(query_id_set_mutex);
 
     /// Return the partition expression types as a Tuple type. Return DataTypeUInt8 if partition expression is empty.
     DataTypePtr getPartitionValueType() const;
@@ -1279,7 +1286,7 @@ private:
     std::atomic<size_t> total_active_size_parts = 0;
 
     // Record all query ids which access the table. It's guarded by `query_id_set_mutex` and is always mutable.
-    mutable std::set<String> query_id_set;
+    mutable std::set<String> query_id_set TSA_GUARDED_BY(query_id_set_mutex);
     mutable std::mutex query_id_set_mutex;
 
     // Get partition matcher for FREEZE / UNFREEZE queries.
diff --git a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp
index 99886f9b68..1547050c5e 100644
--- a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp
+++ b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp
@@ -1075,6 +1075,7 @@ std::shared_ptr<QueryIdHolder> MergeTreeDataSelectExecutor::checkLimits(
     const MergeTreeData & data,
     const ReadFromMergeTree::AnalysisResult & result,
     const ContextPtr & context)
+        TSA_NO_THREAD_SAFETY_ANALYSIS // disabled because TSA is confused by guaranteed copy elision in data.getQueryIdSetLock()
 {
     const auto & settings = context->getSettingsRef();
     const auto data_settings = data.getSettings();
@@ -1085,7 +1086,7 @@ std::shared_ptr<QueryIdHolder> MergeTreeDataSelectExecutor::checkLimits(
         std::set<String> partitions;
         for (const auto & part_with_ranges : result.parts_with_ranges)
             partitions.insert(part_with_ranges.data_part->info.partition_id);
-        if (partitions.size() > size_t(max_partitions_to_read))
+        if (partitions.size() > static_cast<size_t>(max_partitions_to_read))
             throw Exception(
                 ErrorCodes::TOO_MANY_PARTITIONS,
                 "Too many partitions to read. Current {}, max {}",
@@ -1100,7 +1101,7 @@ std::shared_ptr<QueryIdHolder> MergeTreeDataSelectExecutor::checkLimits(
         if (!query_id.empty())
         {
             auto lock = data.getQueryIdSetLock();
-            if (data.insertQueryIdOrThrowNoLock(query_id, data_settings->max_concurrent_queries, lock))
+            if (data.insertQueryIdOrThrowNoLock(query_id, data_settings->max_concurrent_queries))
             {
                 try
                 {
@@ -1109,7 +1110,7 @@ std::shared_ptr<QueryIdHolder> MergeTreeDataSelectExecutor::checkLimits(
                 catch (...)
                 {
                     /// If we fail to construct the holder, remove query_id explicitly to avoid leak.
-                    data.removeQueryIdNoLock(query_id, lock);
+                    data.removeQueryIdNoLock(query_id);
                     throw;
                 }
             }
diff --git a/tests/queries/0_stateless/01167_isolation_hermitage.sh b/tests/queries/0_stateless/01167_isolation_hermitage.sh
index 7f495801dd..3f2c830821 100755
--- a/tests/queries/0_stateless/01167_isolation_hermitage.sh
+++ b/tests/queries/0_stateless/01167_isolation_hermitage.sh
@@ -1,5 +1,5 @@
 #!/usr/bin/env bash
-# Tags: long, no-fasttest, no-replicated-database
+# Tags: long, no-fasttest, no-replicated-database, no-ordinary-database
 # Looks like server does not listen https port in fasttest
 # FIXME Replicated database executes ALTERs in separate context, so transaction info is lost
 
diff --git a/tests/queries/0_stateless/01168_mutations_isolation.sh b/tests/queries/0_stateless/01168_mutations_isolation.sh
index 888858edf3..ebfdffdaee 100755
--- a/tests/queries/0_stateless/01168_mutations_isolation.sh
+++ b/tests/queries/0_stateless/01168_mutations_isolation.sh
@@ -1,5 +1,5 @@
 #!/usr/bin/env bash
-# Tags: no-fasttest, no-replicated-database
+# Tags: no-fasttest, no-replicated-database, no-ordinary-database
 # Looks like server does not listen https port in fasttest
 # FIXME Replicated database executes ALTERs in separate context, so transaction info is lost
 
diff --git a/tests/queries/0_stateless/01169_alter_partition_isolation_stress.sh b/tests/queries/0_stateless/01169_alter_partition_isolation_stress.sh
index ab348fd31f..32ad78dead 100755
--- a/tests/queries/0_stateless/01169_alter_partition_isolation_stress.sh
+++ b/tests/queries/0_stateless/01169_alter_partition_isolation_stress.sh
@@ -1,5 +1,5 @@
 #!/usr/bin/env bash
-# Tags: long, no-replicated-database
+# Tags: long, no-replicated-database, no-ordinary-database
 
 # shellcheck disable=SC2015
 
@@ -17,7 +17,6 @@ $CLICKHOUSE_CLIENT --query "CREATE TABLE dst (n UInt64, type UInt8) ENGINE=Merge
 function thread_insert()
 {
     set -e
-    trap "exit 0" INT
     val=1
     while true; do
         $CLICKHOUSE_CLIENT --multiquery --query "
@@ -72,6 +71,7 @@ function thread_partition_dst_to_src()
         $CLICKHOUSE_CLIENT --multiquery --query "
         SYSTEM STOP MERGES dst;
         ALTER TABLE dst DROP PARTITION ID 'nonexistent';  -- STOP MERGES doesn't wait for started merges to finish, so we use this trick
+        SYSTEM SYNC TRANSACTION LOG;
         BEGIN TRANSACTION;
         INSERT INTO dst VALUES /* ($i, 4) */ ($i, 4);
         INSERT INTO src SELECT * FROM dst;
@@ -79,19 +79,13 @@ function thread_partition_dst_to_src()
         SET throw_on_unsupported_query_inside_transaction=0;
         SYSTEM START MERGES dst;
         SELECT throwIf((SELECT (count(), sum(n)) FROM merge(currentDatabase(), '') WHERE type=4) != (toUInt8($i/2 + 1), (select sum(number) from numbers(1, $i) where number % 2 or number=$i))) FORMAT Null;
-        $action;" || $CLICKHOUSE_CLIENT --multiquery --query "
-                          begin transaction;
-                          set transaction snapshot 3;
-                          select $i, 'src', type, n, _part from src order by type, n;
-                          select $i, 'dst', type, n, _part from dst order by type, n;
-                          rollback" ||:
+        $action;"
     done
 }
 
 function thread_select()
 {
     set -e
-    trap "exit 0" INT
     while true; do
         $CLICKHOUSE_CLIENT --multiquery --query "
         BEGIN TRANSACTION;
@@ -103,12 +97,7 @@ function thread_select()
         SELECT _table, throwIf(arraySort(groupArrayIf(n, type=1)) != arraySort(groupArrayIf(n, type=2))) FROM merge(currentDatabase(), '') GROUP BY _table FORMAT Null;
         -- all rows are inserted in insert_thread
         SELECT type, throwIf(count(n) != max(n)), throwIf(sum(n) != max(n)*(max(n)+1)/2) FROM merge(currentDatabase(), '') WHERE type IN (1, 2) GROUP BY type ORDER BY type FORMAT Null;
-        COMMIT;" || $CLICKHOUSE_CLIENT --multiquery --query "
-                         begin transaction;
-                         set transaction snapshot 3;
-                         select $i, 'src', type, n, _part from src order by type, n;
-                         select $i, 'dst', type, n, _part from dst order by type, n;
-                         rollback" ||:
+        COMMIT;"
     done
 }
 
@@ -119,9 +108,10 @@ thread_partition_src_to_dst & PID_3=$!
 thread_partition_dst_to_src & PID_4=$!
 wait $PID_3 && wait $PID_4
 
-kill -INT $PID_1
-kill -INT $PID_2
+kill -TERM $PID_1
+kill -TERM $PID_2
 wait
+wait_for_queries_to_finish
 
 $CLICKHOUSE_CLIENT -q "SELECT type, count(n) = countDistinct(n) FROM merge(currentDatabase(), '') GROUP BY type ORDER BY type"
 $CLICKHOUSE_CLIENT -q "SELECT DISTINCT arraySort(groupArrayIf(n, type=1)) = arraySort(groupArrayIf(n, type=2)) FROM merge(currentDatabase(), '') GROUP BY _table ORDER BY _table"
diff --git a/tests/queries/0_stateless/01170_alter_partition_isolation.sh b/tests/queries/0_stateless/01170_alter_partition_isolation.sh
index 2db178fb6d..6ac9571380 100755
--- a/tests/queries/0_stateless/01170_alter_partition_isolation.sh
+++ b/tests/queries/0_stateless/01170_alter_partition_isolation.sh
@@ -1,5 +1,5 @@
 #!/usr/bin/env bash
-# Tags: no-fasttest, no-replicated-database
+# Tags: no-fasttest, no-replicated-database, no-ordinary-database
 # Looks like server does not listen https port in fasttest
 # FIXME Replicated database executes ALTERs in separate context, so transaction info is lost
 
diff --git a/tests/queries/0_stateless/01171_mv_select_insert_isolation_long.sh b/tests/queries/0_stateless/01171_mv_select_insert_isolation_long.sh
index 3de63615bc..12b654f421 100755
--- a/tests/queries/0_stateless/01171_mv_select_insert_isolation_long.sh
+++ b/tests/queries/0_stateless/01171_mv_select_insert_isolation_long.sh
@@ -1,5 +1,5 @@
 #!/usr/bin/env bash
-# Tags: long, no-parallel
+# Tags: long, no-parallel, no-ordinary-database
 # Test is too heavy, avoid parallel run in Flaky Check
 
 CURDIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
@@ -11,6 +11,7 @@ set -e
 $CLICKHOUSE_CLIENT --query "DROP TABLE IF EXISTS src";
 $CLICKHOUSE_CLIENT --query "DROP TABLE IF EXISTS dst";
 $CLICKHOUSE_CLIENT --query "DROP TABLE IF EXISTS mv";
+$CLICKHOUSE_CLIENT --query "DROP TABLE IF EXISTS tmp";
 $CLICKHOUSE_CLIENT --query "CREATE TABLE src (n Int8, m Int8, CONSTRAINT c CHECK xxHash32(n+m) % 8 != 0) ENGINE=MergeTree ORDER BY n PARTITION BY 0 < n SETTINGS old_parts_lifetime=0";
 $CLICKHOUSE_CLIENT --query "CREATE TABLE dst (nm Int16, CONSTRAINT c CHECK xxHash32(nm) % 8 != 0) ENGINE=MergeTree ORDER BY nm SETTINGS old_parts_lifetime=0";
 $CLICKHOUSE_CLIENT --query "CREATE MATERIALIZED VIEW mv TO dst (nm Int16) AS SELECT n*m AS nm FROM src";
@@ -49,7 +50,6 @@ function thread_insert_rollback()
 function thread_optimize()
 {
     set -e
-    trap "exit 0" INT
     while true; do
         optimize_query="OPTIMIZE TABLE src"
         partition_id=$(( RANDOM % 2 ))
@@ -80,7 +80,6 @@ function thread_optimize()
 function thread_select()
 {
     set -e
-    trap "exit 0" INT
     while true; do
         $CLICKHOUSE_CLIENT --multiquery --query "
         BEGIN TRANSACTION;
@@ -89,19 +88,13 @@ function thread_select()
         SELECT throwIf((SELECT (sum(nm), count() % 2) FROM dst) != (0, 1)) FORMAT Null;
         SELECT throwIf((SELECT arraySort(groupArray(nm)) FROM mv) != (SELECT arraySort(groupArray(nm)) FROM dst)) FORMAT Null;
         SELECT throwIf((SELECT arraySort(groupArray(nm)) FROM mv) != (SELECT arraySort(groupArray(n*m)) FROM src)) FORMAT Null;
-        COMMIT;" || $CLICKHOUSE_CLIENT --multiquery --query "
-                          begin transaction;
-                          set transaction snapshot 3;
-                          select 'src', n, m, _part from src order by n, m;
-                          select 'dst', nm, _part from dst order by nm;
-                          rollback" ||:
+        COMMIT;"
     done
 }
 
 function thread_select_insert()
 {
     set -e
-    trap "exit 0" INT
     while true; do
         $CLICKHOUSE_CLIENT --multiquery --query "
         BEGIN TRANSACTION;
@@ -115,12 +108,7 @@ function thread_select_insert()
         -- now check that all results are the same
         SELECT throwIf(1 != (SELECT countDistinct(arr) FROM (SELECT x, arraySort(groupArray(nm)) AS arr FROM tmp WHERE x!=4 GROUP BY x))) FORMAT Null;
         SELECT throwIf((SELECT count(), sum(nm) FROM tmp WHERE x=4) != (SELECT count(), sum(nm) FROM tmp WHERE x!=4)) FORMAT Null;
-        ROLLBACK;" || $CLICKHOUSE_CLIENT --multiquery --query "
-                            begin transaction;
-                            set transaction snapshot 3;
-                            select 'src', n, m, _part from src order by n, m;
-                            select 'dst', nm, _part from dst order by nm;
-                            rollback" ||:
+        ROLLBACK;"
     done
 }
 
@@ -136,12 +124,13 @@ thread_select & PID_7=$!
 thread_select_insert & PID_8=$!
 
 wait $PID_1 && wait $PID_2 && wait $PID_3
-kill -INT $PID_4
-kill -INT $PID_5
-kill -INT $PID_6
-kill -INT $PID_7
-kill -INT $PID_8
+kill -TERM $PID_4
+kill -TERM $PID_5
+kill -TERM $PID_6
+kill -TERM $PID_7
+kill -TERM $PID_8
 wait
+wait_for_queries_to_finish
 
 $CLICKHOUSE_CLIENT --multiquery --query "
 BEGIN TRANSACTION;
@@ -154,3 +143,4 @@ $CLICKHOUSE_CLIENT --query "SELECT count(), sum(nm) FROM mv"
 $CLICKHOUSE_CLIENT --query "DROP TABLE src";
 $CLICKHOUSE_CLIENT --query "DROP TABLE dst";
 $CLICKHOUSE_CLIENT --query "DROP TABLE mv";
+$CLICKHOUSE_CLIENT --query "DROP TABLE tmp";
diff --git a/tests/queries/0_stateless/01172_transaction_counters.reference b/tests/queries/0_stateless/01172_transaction_counters.reference
index e2835c6e59..23445697eb 100644
--- a/tests/queries/0_stateless/01172_transaction_counters.reference
+++ b/tests/queries/0_stateless/01172_transaction_counters.reference
@@ -6,7 +6,7 @@
 3	all_1_1_0	0
 3	all_3_3_0	1
 4	all_1_1_0	1	(0,0,'00000000-0000-0000-0000-000000000000')	0
-4	all_2_2_0	18446744073709551615	(1,1,'00000000-0000-0000-0000-000000000000')	0
+4	all_2_2_0	18446744073709551615	(0,0,'00000000-0000-0000-0000-000000000000')	0
 4	all_3_3_0	0	(0,0,'00000000-0000-0000-0000-000000000000')	0
 5	1
 6	all_1_1_0	0
@@ -19,7 +19,6 @@
 1	1	AddPart	1	1	1	1	all_1_1_0
 2	1	Begin	1	1	1	1	
 2	1	AddPart	1	1	1	1	all_2_2_0
-1	1	LockPart	1	1	1	1	all_2_2_0
 2	1	Rollback	1	1	1	1
 3	1	Begin	1	1	1	1	
 3	1	AddPart	1	1	1	1	all_3_3_0
@@ -38,4 +37,3 @@
 5	1	UnlockPart	1	1	1	1	all_4_4_0
 5	1	UnlockPart	1	1	1	1	all_5_5_0
 5	1	Rollback	1	1	1	1	
-
diff --git a/tests/queries/0_stateless/01172_transaction_counters.sql b/tests/queries/0_stateless/01172_transaction_counters.sql
index 5431673fd6..ee00029501 100644
--- a/tests/queries/0_stateless/01172_transaction_counters.sql
+++ b/tests/queries/0_stateless/01172_transaction_counters.sql
@@ -1,5 +1,6 @@
--- Tags: no-s3-storage
+-- Tags: no-s3-storage, no-ordinary-database
 -- FIXME this test fails with S3 due to a bug in DiskCacheWrapper
+
 drop table if exists txn_counters;
 
 create table txn_counters (n Int64, creation_tid DEFAULT transactionID()) engine=MergeTree order by n;
@@ -42,7 +43,13 @@ rollback;
 
 system flush logs;
 select indexOf((select arraySort(groupUniqArray(tid)) from system.transactions_info_log where database=currentDatabase() and table='txn_counters'), tid),
-       (toDecimal64(now64(6), 6) - toDecimal64(event_time, 6)) < 100, type, thread_id!=0, length(query_id)=length(queryID()), tid_hash!=0, csn=0, part
+       (toDecimal64(now64(6), 6) - toDecimal64(event_time, 6)) < 100,
+       type,
+       thread_id!=0,
+       length(query_id)=length(queryID()) or type='Commit' and query_id='',  -- ignore fault injection after commit
+       tid_hash!=0,
+       csn=0,
+       part
 from system.transactions_info_log
 where tid in (select tid from system.transactions_info_log where database=currentDatabase() and table='txn_counters' and not (tid.1=1 and tid.2=1))
 or (database=currentDatabase() and table='txn_counters') order by event_time;
diff --git a/tests/queries/0_stateless/01173_transaction_control_queries.sql b/tests/queries/0_stateless/01173_transaction_control_queries.sql
index 930a2909f7..03c98f50cc 100644
--- a/tests/queries/0_stateless/01173_transaction_control_queries.sql
+++ b/tests/queries/0_stateless/01173_transaction_control_queries.sql
@@ -1,10 +1,12 @@
+-- Tags: no-ordinary-database
+
 drop table if exists mt1;
 drop table if exists mt2;
 
 create table mt1 (n Int64) engine=MergeTree order by n;
 create table mt2 (n Int64) engine=MergeTree order by n;
 
-commit; -- { serverError INVALID_TRANSACTION }
+commit; -- { serverError INVALID_TRANSACTION } -- no transaction
 rollback; -- { serverError INVALID_TRANSACTION }
 
 begin transaction;
@@ -31,7 +33,7 @@ select 'on exception before start', arraySort(groupArray(n)) from (select n from
 -- rollback on exception before start
 select functionThatDoesNotExist(); -- { serverError 46 }
 -- cannot commit after exception
-commit; -- { serverError INVALID_TRANSACTION }
+commit; -- { serverError INVALID_TRANSACTION } -- after 46
 begin transaction; -- { serverError INVALID_TRANSACTION }
 rollback;
 
@@ -42,7 +44,7 @@ select 'on exception while processing', arraySort(groupArray(n)) from (select n
 -- rollback on exception while processing
 select throwIf(100 < number) from numbers(1000); -- { serverError 395 }
 -- cannot commit after exception
-commit; -- { serverError INVALID_TRANSACTION }
+commit; -- { serverError INVALID_TRANSACTION } -- after 395
 insert into mt1 values (5); -- { serverError INVALID_TRANSACTION }
 insert into mt2 values (50); -- { serverError INVALID_TRANSACTION }
 select 1; -- { serverError INVALID_TRANSACTION }
@@ -52,10 +54,9 @@ begin transaction;
 insert into mt1 values (6);
 insert into mt2 values (60);
 select 'on session close', arraySort(groupArray(n)) from (select n from mt1 union all select * from mt2);
--- trigger reconnection by error on client, check rollback on session close
 insert into mt1 values ([1]); -- { clientError 43 }
-commit; -- { serverError INVALID_TRANSACTION }
-rollback; -- { serverError INVALID_TRANSACTION }
+-- INSERT failures does not produce client reconnect anymore, so rollback can be done
+rollback;
 
 begin transaction;
 insert into mt1 values (7);
@@ -82,19 +83,19 @@ rollback;
 
 begin transaction;
 create table m (n int) engine=Memory; -- { serverError 48 }
-commit; -- { serverError INVALID_TRANSACTION }
+commit; -- { serverError INVALID_TRANSACTION } -- after 48
 rollback;
 
 create table m (n int) engine=Memory;
 begin transaction;
 insert into m values (1); -- { serverError 48 }
 select * from m; -- { serverError INVALID_TRANSACTION }
-commit; -- { serverError INVALID_TRANSACTION }
+commit; -- { serverError INVALID_TRANSACTION } -- after 48
 rollback;
 
 begin transaction;
 select * from m; -- { serverError 48 }
-commit; -- { serverError INVALID_TRANSACTION }
+commit; -- { serverError INVALID_TRANSACTION } -- after 48
 rollback;
 
 drop table m;
diff --git a/tests/queries/0_stateless/01174_select_insert_isolation.sh b/tests/queries/0_stateless/01174_select_insert_isolation.sh
index 8872ab82c0..dc5c1d7a72 100755
--- a/tests/queries/0_stateless/01174_select_insert_isolation.sh
+++ b/tests/queries/0_stateless/01174_select_insert_isolation.sh
@@ -1,5 +1,5 @@
 #!/usr/bin/env bash
-# Tags: long
+# Tags: long, no-ordinary-database
 
 # shellcheck disable=SC2015
 
@@ -35,17 +35,16 @@ function thread_insert_rollback()
 
 function thread_select()
 {
-    trap "exit 0" INT
     while true; do
-        # Result of `uniq | wc -l` must be 1 if the first and the last queries got the same result
+        # The first and the last queries must get the same result
         $CLICKHOUSE_CLIENT --multiquery --query "
         BEGIN TRANSACTION;
-        SELECT arraySort(groupArray(n)), arraySort(groupArray(m)), arraySort(groupArray(_part)) FROM mt;
+        SET throw_on_unsupported_query_inside_transaction=0;
+        CREATE TEMPORARY TABLE tmp AS SELECT arraySort(groupArray(n)), arraySort(groupArray(m)), arraySort(groupArray(_part)) FROM mt FORMAT Null;
         SELECT throwIf((SELECT sum(n) FROM mt) != 0) FORMAT Null;
         SELECT throwIf((SELECT count() FROM mt) % 2 != 0) FORMAT Null;
-        SELECT arraySort(groupArray(n)), arraySort(groupArray(m)), arraySort(groupArray(_part)) FROM mt;
-        COMMIT;" | uniq | wc -l | grep -v "^1$" && $CLICKHOUSE_CLIENT -q "SELECT * FROM system.parts
-                    WHERE database='$CLICKHOUSE_DATABASE' AND table='mt'" ||:;
+        select throwIf((SELECT * FROM tmp) != (SELECT arraySort(groupArray(n)), arraySort(groupArray(m)), arraySort(groupArray(_part)) FROM mt)) FORMAT Null;
+        COMMIT;"
     done
 }
 
@@ -54,8 +53,9 @@ thread_insert_commit 2 & PID_2=$!
 thread_insert_rollback 3 & PID_3=$!
 thread_select & PID_4=$!
 wait $PID_1 && wait $PID_2 && wait $PID_3
-kill -INT $PID_4
+kill -TERM $PID_4
 wait
+wait_for_queries_to_finish
 
 $CLICKHOUSE_CLIENT --multiquery --query "
 BEGIN TRANSACTION;
diff --git a/tests/queries/shell_config.sh b/tests/queries/shell_config.sh
index e95f843363..2d2ae8f631 100644
--- a/tests/queries/shell_config.sh
+++ b/tests/queries/shell_config.sh
@@ -129,3 +129,23 @@ function clickhouse_client_removed_host_parameter()
     # bash regex magic is arcane, but version dependant and weak; sed or awk are not really portable.
     $(echo "$CLICKHOUSE_CLIENT"  | python3 -c "import sys, re; print(re.sub('--host(\s+|=)[^\s]+', '', sys.stdin.read()))") "$@"
 }
+
+function wait_for_queries_to_finish()
+{
+    # Wait for all queries to finish (query may still be running if thread is killed by timeout)
+    num_tries=0
+    while [[ $($CLICKHOUSE_CLIENT -q "SELECT count() FROM system.processes WHERE current_database=currentDatabase() AND query NOT LIKE '%system.processes%'") -ne 0 ]]; do
+        sleep 0.5;
+        num_tries=$((num_tries+1))
+        if [ $num_tries -eq 20 ]; then
+            $CLICKHOUSE_CLIENT -q "SELECT * FROM system.processes WHERE current_database=currentDatabase() AND query NOT LIKE '%system.processes%' FORMAT Vertical"
+            break
+        fi
+    done
+}
+
+function random_str()
+{
+    local n=$1 && shift
+    tr -cd '[:lower:]' < /dev/urandom | head -c"$n"
+}
diff --git a/utils/keeper-bench/Generator.cpp b/utils/keeper-bench/Generator.cpp
index 77185813a2..69f2475daf 100644
--- a/utils/keeper-bench/Generator.cpp
+++ b/utils/keeper-bench/Generator.cpp
@@ -62,7 +62,7 @@ void removeRecursive(Coordination::ZooKeeper & zookeeper, const std::string & pa
 
         promise->set_value();
     };
-    zookeeper.list(path, list_callback, nullptr);
+    zookeeper.list(path, ListRequestType::ALL, list_callback, nullptr);
     future.get();
 
     while (!children.empty())
-- 
2.32.1 (Apple Git-133)

