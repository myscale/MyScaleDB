From e6f8e8637fdfe7a4eab4fcb705f4284b97af8c7e Mon Sep 17 00:00:00 2001
From: Jianmei Zhang <jianmeiz@moqi.ai>
Date: Thu, 16 Mar 2023 03:11:58 +0000
Subject: [PATCH 24/51] Fix bugs when vector search works with subquery

---
 src/Interpreters/ExpressionAnalyzer.cpp       |  12 +-
 src/Interpreters/ExpressionAnalyzer.h         |   3 -
 src/Interpreters/InterpreterSelectQuery.cpp   |   4 -
 src/Interpreters/TreeRewriter.cpp             |   4 +
 .../MergeTree/MergeTreeVectorScanManager.cpp  | 139 ++++++++++--------
 ...0025_mqvs_distance_with_subquery.reference |  47 ++++++
 .../00025_mqvs_distance_with_subquery.sql     |  70 +++++++++
 7 files changed, 208 insertions(+), 71 deletions(-)
 create mode 100644 tests/queries/2_vector_search/00025_mqvs_distance_with_subquery.reference
 create mode 100644 tests/queries/2_vector_search/00025_mqvs_distance_with_subquery.sql

diff --git a/src/Interpreters/ExpressionAnalyzer.cpp b/src/Interpreters/ExpressionAnalyzer.cpp
index 0307ec7f81..4489273a19 100644
--- a/src/Interpreters/ExpressionAnalyzer.cpp
+++ b/src/Interpreters/ExpressionAnalyzer.cpp
@@ -660,11 +660,13 @@ bool ExpressionAnalyzer::makeVectorScanDescriptions(ActionsDAGPtr & actions)
                 "Unknown identifier '{}' in distance function", arguments[1]->getColumnName());
         }
 
-        if (!dag_node->column)
+      /// In cases with nested subquery, scalar subquery is not replaced with a const value if only analyze is requested.
+        if (dag_node->column)
         {
-           throw Exception(ErrorCodes::UNKNOWN_IDENTIFIER,
-                "Wrong query vector type in distance function"); 
+            if (!isColumnConst(*dag_node->column))
+                throw Exception(ErrorCodes::BAD_ARGUMENTS, "Wrong query vector type for argument {} in distance function", arguments[1]->getColumnName());
         }
+
         vector_scan_desc.query_column = dag_node->column;
         vector_scan_desc.query_column_name = arguments[1]->getColumnName();
         //vector_scan_desc.parameters = (node->parameters) ? getAggregateFunctionParametersArray(node->parameters, "", getContext()) : Array();
@@ -685,9 +687,7 @@ bool ExpressionAnalyzer::makeVectorScanDescriptions(ActionsDAGPtr & actions)
                 throw Exception("The input JSON's format is illegal ", ErrorCodes::BAD_ARGUMENTS);
             }
         }
-        // String test = vector_scan_desc.parameters->get("metric");
-        // LOG_DEBUG(&Poco::Logger::get("test select parse arg"), test);
-        // txh added
+
         LOG_DEBUG(log, "[makeVectorScanDescriptions] create vector scan function: {}", node->name);
 
         vector_scan_descriptions.push_back(vector_scan_desc);
diff --git a/src/Interpreters/ExpressionAnalyzer.h b/src/Interpreters/ExpressionAnalyzer.h
index 3cd8664e7d..78a1624a7c 100644
--- a/src/Interpreters/ExpressionAnalyzer.h
+++ b/src/Interpreters/ExpressionAnalyzer.h
@@ -71,8 +71,6 @@ struct ExpressionAnalyzerData
     /// Columns after window functions.
     NamesAndTypesList columns_after_window;
 
-    NamesAndTypesList vector_scan_columns;
-
     bool has_aggregation = false;
     NamesAndTypesList aggregation_keys;
     bool has_const_aggregation_keys = false;
@@ -404,7 +402,6 @@ private:
     ActionsDAGPtr appendPrewhere(ExpressionActionsChain & chain, bool only_types, const Names & additional_required_columns);
     bool appendWhere(ExpressionActionsChain & chain, bool only_types);
     bool appendGroupBy(ExpressionActionsChain & chain, bool only_types, bool optimize_aggregation_in_order, ManyExpressionActions &);
-    void appendVectorScanFunctionsArguments(ExpressionActionsChain & chain, bool only_types);
     void appendAggregateFunctionsArguments(ExpressionActionsChain & chain, bool only_types);
     void appendWindowFunctionsArguments(ExpressionActionsChain & chain, bool only_types);
 
diff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp
index 18d5c06fa6..df3c201409 100644
--- a/src/Interpreters/InterpreterSelectQuery.cpp
+++ b/src/Interpreters/InterpreterSelectQuery.cpp
@@ -420,14 +420,10 @@ InterpreterSelectQuery::InterpreterSelectQuery(
         if (view)
             view->replaceWithSubquery(getSelectQuery(), view_table, metadata_snapshot);
 
-        /// LOG_DEBUG(log, "[analyze] before analyze: source header: {}, required_result_column_names size: {}",
-        ///     source_header.getNamesAndTypesList().toString(), required_result_column_names.size());
-
         syntax_analyzer_result = TreeRewriter(context).analyzeSelect(
             query_ptr,
             TreeRewriterResult(source_header.getNamesAndTypesList(), storage, storage_snapshot),
             options, joined_tables.tablesWithColumns(), required_result_column_names, table_join);
-        /// LOG_DEBUG(log, "[analyze] after analyze: source header: {}", source_header.getNamesAndTypesList().toString());
 
         query_info.syntax_analyzer_result = syntax_analyzer_result;
         context->setDistributed(syntax_analyzer_result->is_remote_storage);
diff --git a/src/Interpreters/TreeRewriter.cpp b/src/Interpreters/TreeRewriter.cpp
index 0bcb9e966a..dbd74ad8a4 100644
--- a/src/Interpreters/TreeRewriter.cpp
+++ b/src/Interpreters/TreeRewriter.cpp
@@ -482,6 +482,10 @@ void removeUnneededColumnsFromSelectClause(const ASTSelectQuery * select_query,
             /// removing aggregation can change number of rows, so `count()` result in outer sub-query would be wrong
             if (func && AggregateFunctionFactory::instance().isAggregateFunctionName(func->name) && !select_query->groupBy())
                 new_elements.push_back(elem);
+
+            /// Removing vector search function can change number of rows.
+            if (func && isVectorScanFunc(func->name))
+                new_elements.push_back(elem);
         }
     }
 
diff --git a/src/Storages/MergeTree/MergeTreeVectorScanManager.cpp b/src/Storages/MergeTree/MergeTreeVectorScanManager.cpp
index 2654f95c2f..a3aa05a27e 100644
--- a/src/Storages/MergeTree/MergeTreeVectorScanManager.cpp
+++ b/src/Storages/MergeTree/MergeTreeVectorScanManager.cpp
@@ -27,6 +27,75 @@
 
 namespace DB
 {
+
+template <typename FloatType>
+std::vector<float> getQueryVector(const IColumn * query_vector_column, int dim, bool is_batch)
+{
+    const auto * query_data_concrete = checkAndGetColumn<ColumnVector<FloatType>>(query_vector_column);
+
+    if (!query_data_concrete)
+    {
+        if (is_batch)
+            throw Exception("Wrong query column type, expect Float32 or Float64 inside Array(Array()) in batch distance function", ErrorCodes::LOGICAL_ERROR);
+        else
+            throw Exception("Wrong query column type, expect Float32 or Float64 inside Array() in distance function", ErrorCodes::LOGICAL_ERROR);
+    }
+
+    const auto & query_vec = query_data_concrete->getData();
+
+    size_t dim_of_query = query_vec.size();
+
+    /// in batch distance case, dim_of_query = dim * offsets. dim in query is already checked in getQueryVectorInBatch().
+    if (!is_batch && (dim_of_query != dim))
+        throw Exception(
+            "Dimension is not equal: query: " + std::to_string(dim_of_query) + " vs search column: " + std::to_string(dim),
+            ErrorCodes::LOGICAL_ERROR);
+
+    /// TODO: effectively transform float64 array to float32 array
+    std::vector<float> query_new_data(dim_of_query);
+
+    for (size_t i = 0; i < dim_of_query; ++i)
+    {
+        query_new_data[i] = static_cast<float>(query_vec[i]);
+    }
+
+    return query_new_data;
+}
+
+std::vector<float> getQueryVectorInBatch(const IColumn * query_vectors_column, const int dim, int & query_vector_num)
+{
+    const ColumnArray * query_vectors_col = checkAndGetColumn<ColumnArray>(query_vectors_column);
+
+    if (!query_vectors_col)
+        throw Exception("Wrong query column type, expect Array(Array)) in batch distance function", ErrorCodes::LOGICAL_ERROR);
+
+    const IColumn & query_vectors = query_vectors_col->getData();
+    auto & offsets = query_vectors_col->getOffsets();
+
+    query_vector_num = offsets.size();
+    for (size_t row = 0; row < offsets.size(); ++row)
+    {
+        size_t vec_start_offset = row != 0 ? offsets[row - 1] : 0;
+        size_t vec_end_offset = offsets[row];
+        size_t vec_size = vec_end_offset - vec_start_offset;
+        if (vec_size != dim)
+            throw Exception(
+                "Having query vector with wrong dimension: " + std::to_string(vec_size)
+                + " vs search column dimension: " + std::to_string(dim),
+                ErrorCodes::LOGICAL_ERROR);
+    }
+
+    std::vector<float> query_new_data;
+    if (checkColumn<ColumnFloat32>(&query_vectors))
+        query_new_data = getQueryVector<Float32>(&query_vectors, dim, true);
+    else if (checkColumn<ColumnFloat64>(&query_vectors))
+        query_new_data = getQueryVector<Float64>(&query_vectors, dim, true);
+    else
+        throw Exception("Wrong query column type, expect Float64 or Float32 inside Array(Array()) in batch distance function", ErrorCodes::LOGICAL_ERROR);
+
+    return query_new_data;
+}
+
 void MergeTreeVectorScanManager::eraseResult()
 {
     if (vector_scan_result->is_batch)
@@ -56,44 +125,12 @@ VectorIndex::VectorDatasetPtr MergeTreeVectorScanManager::generateVectorDataset(
     if (is_batch)
     {
         if (!query_col)
-            throw Exception("Wrong query column type, expect Array(Array(float64))", ErrorCodes::LOGICAL_ERROR);
+            throw Exception("Wrong query column type, expect Array in batch distance function", ErrorCodes::LOGICAL_ERROR);
 
         const IColumn & query_data = query_col->getData();
 
-        const ColumnArray * query_vectors_col = checkAndGetColumn<ColumnArray>(&query_data);
-
-        if (!query_vectors_col)
-            throw Exception("Wrong query column type, expect Array(Array(float64))", ErrorCodes::LOGICAL_ERROR);
-
-        const IColumn & query_vectors = query_vectors_col->getData();
-
-        const ColumnFloat64 * query_data_concrete = checkAndGetColumn<ColumnFloat64>(&query_vectors);
-
-        if (!query_data_concrete)
-            throw Exception("Wrong query column type, expect Array(Array(float64))", ErrorCodes::LOGICAL_ERROR);
-
-        const PaddedPODArray<Float64> & query_vec = query_data_concrete->getData();
-        size_t elem_num = query_vec.size();
-        auto & offsets = query_vectors_col->getOffsets();
-
-        int query_vector_num = offsets.size();
-        for (size_t row = 0; row < offsets.size(); ++row)
-        {
-            size_t vec_start_offset = row != 0 ? offsets[row - 1] : 0;
-            size_t vec_end_offset = offsets[row];
-            size_t vec_size = vec_end_offset - vec_start_offset;
-            if (vec_size != dim)
-                throw Exception(
-                    "Having query vector with wrong dimension: " + std::to_string(vec_size)
-                        + " vs search column dimension: " + std::to_string(dim),
-                    ErrorCodes::LOGICAL_ERROR);
-        }
-
-        std::vector<float> query_new_data(elem_num);
-        for (size_t i = 0; i < elem_num; ++i)
-        {
-            query_new_data[i] = static_cast<float>(query_vec[i]);
-        }
+        int query_vector_num = 0;
+        std::vector<float> query_new_data = getQueryVectorInBatch(&query_data, dim, query_vector_num);
 
         // default value
         VectorIndex::Parameters vec_parameters = VectorIndex::convertPocoJsonToMap(desc.vector_parameters);
@@ -105,38 +142,24 @@ VectorIndex::VectorDatasetPtr MergeTreeVectorScanManager::generateVectorDataset(
         }
 
         LOG_DEBUG(log, "Set k to {}, dim to {}", k, dim);
+
         return std::make_shared<VectorIndex::VectorDataset>(
             query_vector_num, static_cast<int32_t>(dim), const_cast<float *>(query_new_data.data()));
     }
     else
     {
         if (!query_col)
-            throw Exception("Wrong query column type, expect Array(float64)", ErrorCodes::LOGICAL_ERROR);
+            throw Exception("Wrong query column type, expect Array in distance function", ErrorCodes::LOGICAL_ERROR);
 
         const IColumn & query_data = query_col->getData();
 
-        // const ColumnArray::Offsets & offsets = src_col->getOffsets();
-        const ColumnFloat64 * query_data_concrete = checkAndGetColumn<ColumnFloat64>(&query_data);
-
-        if (!query_data_concrete)
-            throw Exception("Wrong query column type, expect Array(float64)", ErrorCodes::LOGICAL_ERROR);
-
-        const PaddedPODArray<Float64> & query_vec = query_data_concrete->getData();
-
-        size_t dim_of_query = query_vec.size();
-
-        if (dim_of_query != dim)
-            throw Exception(
-                "Dimension is not equal: query: " + std::to_string(dim_of_query) + " vs search column: " + std::to_string(dim),
-                ErrorCodes::LOGICAL_ERROR);
-
-        /// TODO: effectively transform float64 array to float32 array
-        std::vector<float> query_new_data(dim);
-
-        for (size_t i = 0; i < dim; ++i)
-        {
-            query_new_data[i] = static_cast<float>(query_vec[i]);
-        }
+        std::vector<float> query_new_data;
+        if (checkColumn<ColumnFloat32>(&query_data))
+            query_new_data = getQueryVector<Float32>(&query_data, false, dim);
+        else if (checkColumn<ColumnFloat64>(&query_data))
+            query_new_data = getQueryVector<Float64>(&query_data, false, dim);
+        else
+            throw Exception("Wrong query column type, expect Float32 or Float64 inside Array() in distance function", ErrorCodes::LOGICAL_ERROR);
 
         return std::make_shared<VectorIndex::VectorDataset>(1, static_cast<int32_t>(dim), const_cast<float *>(query_new_data.data()));
     }
diff --git a/tests/queries/2_vector_search/00025_mqvs_distance_with_subquery.reference b/tests/queries/2_vector_search/00025_mqvs_distance_with_subquery.reference
new file mode 100644
index 0000000000..4996082e66
--- /dev/null
+++ b/tests/queries/2_vector_search/00025_mqvs_distance_with_subquery.reference
@@ -0,0 +1,47 @@
+0
+Scalar Subquery in distance function
+0
+1
+2
+3
+4
+5
+6
+7
+8
+9
+Scalar Subquery with float32 data type in distance function
+0
+1
+2
+3
+4
+5
+6
+7
+8
+9
+Scalar Subquery with float32 data type in batch distance function
+0
+1
+2
+3
+4
+0
+1
+2
+3
+4
+Scalar Subquery inside WITH clause in distance function
+0
+1
+2
+3
+4
+5
+6
+7
+8
+9
+Test remove unneeded distance function column in subquery
+1
diff --git a/tests/queries/2_vector_search/00025_mqvs_distance_with_subquery.sql b/tests/queries/2_vector_search/00025_mqvs_distance_with_subquery.sql
new file mode 100644
index 0000000000..eafb089426
--- /dev/null
+++ b/tests/queries/2_vector_search/00025_mqvs_distance_with_subquery.sql
@@ -0,0 +1,70 @@
+
+-- Tags: no-parallel
+
+DROP TABLE IF EXISTS test_vector_subquery;
+CREATE TABLE test_vector_subquery
+(
+    id    UInt32,
+    vector  Array(Float32),
+    CONSTRAINT check_length CHECK length(vector) = 3
+)
+engine = MergeTree PRIMARY KEY id;
+
+INSERT INTO test_vector_subquery SELECT number, [number,number,number] FROM numbers(1000);
+
+ALTER TABLE test_vector_subquery ADD VECTOR INDEX vec_ind vector TYPE HNSWFLAT;
+
+SELECT sleep(2);
+
+SELECT 'Scalar Subquery in distance function';
+select id FROM (
+select id, distance('topK=10')(vector, (
+    select arrayMap(x->CAST(x AS Float64), vector)
+    FROM test_vector_subquery
+    LIMIT 1)
+) as dist
+from test_vector_subquery
+)
+limit 10;
+
+SELECT 'Scalar Subquery with float32 data type in distance function';
+select id FROM (
+select id, distance('topK=10')(vector, (
+    select vector
+    FROM test_vector_subquery
+    LIMIT 1)
+) as dist
+from test_vector_subquery
+)
+limit 10;
+
+SELECT 'Scalar Subquery with float32 data type in batch distance function';
+select id FROM (
+select id, batch_distance('topK=5')(vector, (
+    select [vector,vector]
+    FROM test_vector_subquery
+    LIMIT 1)
+) as dist
+from test_vector_subquery
+)
+limit 10;
+
+SELECT 'Scalar Subquery inside WITH clause in distance function';
+WITH
+(
+    select arrayMap(x->CAST(x AS Float64), vector)
+    FROM test_vector_subquery
+    LIMIT 1
+) AS target_vector
+select id FROM (
+select id, distance('topK=10')(vector, target_vector) as dist
+from test_vector_subquery
+);
+
+SELECT 'Test remove unneeded distance function column in subquery';
+SELECT id FROM (
+    SELECT id, distance('topK=1')(vector, [1.0,1.0,1.0]) as dist
+    FROM test_vector_subquery
+);
+
+DROP TABLE test_vector_subquery;
-- 
2.32.1 (Apple Git-133)

