From b6a6580e60de1b1e2ca5647e8e9bc74822f123c8 Mon Sep 17 00:00:00 2001
From: Jianmei Zhang <jianmeiz@moqi.ai>
Date: Thu, 22 Dec 2022 01:44:09 +0000
Subject: [PATCH 019/150] Add failure parts and reasons in system table
 vector_indices

---
 src/Storages/MergeTree/MergeTreeData.cpp      | 29 +++++++++++++++++++
 src/Storages/MergeTree/MergeTreeData.h        | 26 +++++++++++++++++
 .../MergeTreeVectorIndexBuilderUpdater.cpp    | 12 ++++----
 .../MergeTree/VectorIndexMergeTreeTask.cpp    |  8 +++--
 .../System/StorageSystemVectorIndices.cpp     | 16 +++++++++-
 ...dd_fail_status_in_vector_indices.reference |  4 +++
 ...mqvs_add_fail_status_in_vector_indices.sql | 24 +++++++++++++++
 7 files changed, 111 insertions(+), 8 deletions(-)
 create mode 100644 tests/queries/2_vector_search/00019_mqvs_add_fail_status_in_vector_indices.reference
 create mode 100644 tests/queries/2_vector_search/00019_mqvs_add_fail_status_in_vector_indices.sql

diff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp
index a62146bbb3..f80ac646e3 100644
--- a/src/Storages/MergeTree/MergeTreeData.cpp
+++ b/src/Storages/MergeTree/MergeTreeData.cpp
@@ -6268,6 +6268,35 @@ StorageSnapshotPtr MergeTreeData::getStorageSnapshot(const StorageMetadataPtr &
     return std::make_shared<StorageSnapshot>(*this, metadata_snapshot, object_columns, std::move(snapshot_data));
 }
 
+MergeTreeData::MergeTreeVectorIndexStatus MergeTreeData::getVectorIndexBuildStatus() const
+{
+    std::lock_guard lock(currently_vector_index_status_mutex);
+    return vector_index_status;
+}
+
+void MergeTreeData::updateVectorIndexBuildStatus(const String & part_name, bool is_successful, const String & exception_message)
+{
+    /// Update the information about failed parts in the system.vector_indices table.
+
+    auto part_info = MergeTreePartInfo::fromPartName(part_name, format_version);
+
+    std::lock_guard lock(currently_vector_index_status_mutex);
+    if (is_successful)
+    {
+        /// If last failed part has been successfully built (in the part_info), clear the fail info.
+        if (!vector_index_status.latest_failed_part.empty() && part_info.contains(vector_index_status.latest_failed_part_info))
+        {
+            vector_index_status.clear();
+        }
+    }
+    else
+    {
+        vector_index_status.latest_failed_part = part_name;
+        vector_index_status.latest_failed_part_info = part_info;
+        vector_index_status.latest_fail_reason = exception_message;
+    }
+}
+
 CurrentlySubmergingEmergingTagger::~CurrentlySubmergingEmergingTagger()
 {
     std::lock_guard lock(storage.currently_submerging_emerging_mutex);
diff --git a/src/Storages/MergeTree/MergeTreeData.h b/src/Storages/MergeTree/MergeTreeData.h
index bb2bc3c692..3710c96fec 100644
--- a/src/Storages/MergeTree/MergeTreeData.h
+++ b/src/Storages/MergeTree/MergeTreeData.h
@@ -941,8 +941,31 @@ public:
     /// Store metadata for replicated tables
     /// Do nothing for non-replicated tables
     virtual void createAndStoreFreezeMetadata(DiskPtr disk, DataPartPtr part, String backup_part_path) const;
+
     virtual void finishVectorIndexJob(const std::vector<String> & processed_parts) = 0;
 
+    /// Similar as MergeTreeMutationStatus. For the system table vector_indices.
+    struct MergeTreeVectorIndexStatus
+    {
+        String latest_failed_part;
+        MergeTreePartInfo latest_failed_part_info;
+        String latest_fail_reason;
+
+        void clear()
+        {
+            latest_failed_part.clear();
+            latest_failed_part_info = MergeTreePartInfo();
+            latest_fail_reason.clear();
+        }
+    };
+
+    /// Return introspection information about currently processing or recently processed vector index build jobs.
+    MergeTreeVectorIndexStatus getVectorIndexBuildStatus() const;
+
+    /// Update vector index status after buildVectorIndexForOnePart() is called for this part. May reset old
+    /// error if built was successful. Otherwise update latested failed status.
+    void updateVectorIndexBuildStatus(const String & part_name, bool is_successful, const String & exception_message);
+
     /// Parts that currently submerging (merging to bigger parts) or emerging
     /// (to be appeared after merging finished). These two variables have to be used
     /// with `currently_submerging_emerging_mutex`.
@@ -1264,6 +1287,9 @@ private:
     virtual std::optional<ZeroCopyLock> tryCreateZeroCopyExclusiveLock(const String &, const DiskPtr &) { return std::nullopt; }
 
     TemporaryParts temporary_parts;
+
+    mutable std::mutex currently_vector_index_status_mutex;
+    MergeTreeVectorIndexStatus vector_index_status;
 };
 
 /// RAII struct to record big parts that are submerging or emerging.
diff --git a/src/Storages/MergeTree/MergeTreeVectorIndexBuilderUpdater.cpp b/src/Storages/MergeTree/MergeTreeVectorIndexBuilderUpdater.cpp
index a36ca14d55..cafee2bd36 100644
--- a/src/Storages/MergeTree/MergeTreeVectorIndexBuilderUpdater.cpp
+++ b/src/Storages/MergeTree/MergeTreeVectorIndexBuilderUpdater.cpp
@@ -20,6 +20,7 @@ namespace DB
 namespace ErrorCodes
 {
     extern const int MEMORY_LIMIT_EXCEEDED;
+    extern const int LOGICAL_ERROR;
 }
 
 /// minimum interval (seconds) between check if need to remove dropped vector index cache.
@@ -249,7 +250,7 @@ BuildVectorIndexStatus MergeTreeVectorIndexBuilderUpdater::buildVectorIndex(
         if (failed_count >= maxBuildRetryCount)
         {
             part->setBuildError();
-            return BuildVectorIndexStatus::BUILD_FAIL;
+            throw Exception(ErrorCodes::MEMORY_LIMIT_EXCEEDED, "part = {}, has MEMORY_LIMIT_EXCEEDED for max retry times {}", part->name, failed_count);
         }
 
         bool mem_limit_happened = false;
@@ -347,7 +348,7 @@ BuildVectorIndexStatus MergeTreeVectorIndexBuilderUpdater::buildVectorIndexForOn
                         if (dim == 0)
                         {
                             LOG_ERROR(log, "[buildVectorIndex] wrong dimension: 0");
-                            return BuildVectorIndexStatus::BUILD_FAIL;
+                            throw Exception(ErrorCodes::LOGICAL_ERROR, "wrong dimension: 0");
                         }
                     }
                     ///only reading one column
@@ -502,7 +503,7 @@ BuildVectorIndexStatus MergeTreeVectorIndexBuilderUpdater::buildVectorIndexForOn
         {
             if (part->vector_index_build_cancelled)
             {
-                return BuildVectorIndexStatus::BUILD_FAIL;
+                throw Exception(ErrorCodes::LOGICAL_ERROR, "Vector index build is cancelled for part {}", part->name);
             }
             empty_ids.clear();
             size_t remaining_size = part->rows_count - num_rows_read;
@@ -623,7 +624,7 @@ BuildVectorIndexStatus MergeTreeVectorIndexBuilderUpdater::buildVectorIndexForOn
                 {
                     LOG_ERROR(log, "[buildVectorIndex] failed to build vector index for part {}", part->name);
                     disk->removeRecursive(vector_tmp_relative_path);
-                    return BuildVectorIndexStatus::BUILD_FAIL;
+                    throw Exception(build_status.getCode(), build_status.getMessage());
                 }
                 training = false;
             }
@@ -665,7 +666,8 @@ BuildVectorIndexStatus MergeTreeVectorIndexBuilderUpdater::buildVectorIndexForOn
             {
                 /// Remove temporay directory
                 disk->removeRecursive(vector_tmp_relative_path);
-                return BuildVectorIndexStatus::BUILD_FAIL;
+
+                throw Exception(seri_status.getCode(), seri_status.getMessage());
             }
 
             /// Done with writing vector index files to temporary directory.
diff --git a/src/Storages/MergeTree/VectorIndexMergeTreeTask.cpp b/src/Storages/MergeTree/VectorIndexMergeTreeTask.cpp
index 8c999c0ef3..05cc960d55 100644
--- a/src/Storages/MergeTree/VectorIndexMergeTreeTask.cpp
+++ b/src/Storages/MergeTree/VectorIndexMergeTreeTask.cpp
@@ -25,10 +25,14 @@ bool VectorIndexMergeTreeTask::executeStep()
         try
         {
             builder.buildVectorIndex(metadata_snapshot, vector_index_entry->data_part_names, false, slow_mode);
+            storage.updateVectorIndexBuildStatus(vector_index_entry->data_part_names[0], true, "");
         }
-        catch (std::exception & e)
+        catch (...)
         {
-            LOG_DEBUG(&Poco::Logger::get("(VectorIndexMergeTreeTask)"), "something went wrong during index building: {}", e.what());
+            String exception_message = getCurrentExceptionMessage(false);
+            LOG_ERROR(&Poco::Logger::get("(VectorIndexMergeTreeTask)"), "something went wrong during index building: {}", exception_message);
+            storage.updateVectorIndexBuildStatus(vector_index_entry->data_part_names[0], false, exception_message);
+
             for (const String & part_name : vector_index_entry->data_part_names)
             {
                 auto part = storage.getActiveContainingPart(part_name);
diff --git a/src/Storages/System/StorageSystemVectorIndices.cpp b/src/Storages/System/StorageSystemVectorIndices.cpp
index b774989147..165c75d4b1 100644
--- a/src/Storages/System/StorageSystemVectorIndices.cpp
+++ b/src/Storages/System/StorageSystemVectorIndices.cpp
@@ -31,6 +31,8 @@ StorageSystemVectorIndices::StorageSystemVectorIndices(const StorageID & table_i
         {"small_parts", std::make_shared<DataTypeInt64>()},
         {"status", std::make_shared<DataTypeString>()},
         {"host_name", std::make_shared<DataTypeString>()},
+        {"latest_failed_part", std::make_shared<DataTypeString>()},
+        {"latest_fail_reason",  std::make_shared<DataTypeString>()},
     }));
     setInMemoryMetadata(storage_metadata);
 }
@@ -127,7 +129,6 @@ protected:
                 if (!metadata_snapshot)
                     continue;
 
-                String data_path = database->getTableDataPath(table_name);
                 MergeTreeData * data = dynamic_cast<MergeTreeData *>(table.get());
                 if (!data)
                     continue;
@@ -195,11 +196,24 @@ protected:
                             res_columns[res_index++]->insert("DataIncomplete");
                         }
                     }
+                    /// host
                     if (column_mask[src_index++])
                     {
                         auto host = escapeForFileName(getFQDNOrHostName()) + ':' + DB::toString(context->getTCPPort());
                         res_columns[res_index++]->insert(host);
                     }
+
+                    const auto fail_status = data->getVectorIndexBuildStatus();
+                    /// latest failed part
+                    if (column_mask[src_index++])
+                    {
+                        res_columns[res_index++]->insert(fail_status.latest_failed_part);
+                    }
+                    /// latest fail reason
+                    if (column_mask[src_index++])
+                    {
+                        res_columns[res_index++]->insert(fail_status.latest_fail_reason);
+                    }
                 }
             }
         }
diff --git a/tests/queries/2_vector_search/00019_mqvs_add_fail_status_in_vector_indices.reference b/tests/queries/2_vector_search/00019_mqvs_add_fail_status_in_vector_indices.reference
new file mode 100644
index 0000000000..795594de6e
--- /dev/null
+++ b/tests/queries/2_vector_search/00019_mqvs_add_fail_status_in_vector_indices.reference
@@ -0,0 +1,4 @@
+0
+test_fail_vector	v1_fail	v1_fail vector TYPE HNSWSQ(\'metric_type = cosine\', \'ef_c=256\')	NoVectorIndexData	all_1_1_0	 [VectorIndex] unsupported metric_type COSINE. (UNSUPPORTED_PARAMETER) (version 22.3.7.5)
+test_fail_vector_2	vindex	vindex vector TYPE IVFFLAT(\'metric=IP\', \'ncentroids=5000\')	NoVectorIndexData	all_1_1_0	 [VectorIndex] These parameters are not supported in Index type IVFFLAT : metric : IP, . (UNSUPPORTED_PARAMETER) (version 22.3.7.5)
+test_success_vector	v1_success	v1_success vector TYPE HNSWFLAT	Built		
diff --git a/tests/queries/2_vector_search/00019_mqvs_add_fail_status_in_vector_indices.sql b/tests/queries/2_vector_search/00019_mqvs_add_fail_status_in_vector_indices.sql
new file mode 100644
index 0000000000..33fd507de8
--- /dev/null
+++ b/tests/queries/2_vector_search/00019_mqvs_add_fail_status_in_vector_indices.sql
@@ -0,0 +1,24 @@
+DROP TABLE IF EXISTS test_success_vector;
+CREATE TABLE test_success_vector(id Float32, vector FixedArray(Float32, 3)) engine MergeTree primary key id SETTINGS index_granularity=1024, min_rows_to_build_vector_index=100;
+INSERT INTO test_success_vector SELECT number, [number, number, number] FROM numbers(2100);
+ALTER TABLE test_success_vector ADD VECTOR INDEX v1_success vector TYPE HNSWFLAT;
+
+DROP TABLE IF EXISTS test_fail_vector;
+CREATE TABLE test_fail_vector(id Float32, vector FixedArray(Float32, 3)) engine MergeTree primary key id SETTINGS index_granularity=1024, min_rows_to_build_vector_index=100;
+INSERT INTO test_fail_vector SELECT number, [number, number, number] FROM numbers(2100);
+-- Unsupported parameter: metric_type = cosine
+ALTER TABLE test_fail_vector ADD VECTOR INDEX v1_fail vector TYPE HNSWSQ('metric_type = cosine', 'ef_c=256');
+
+DROP TABLE IF EXISTS test_fail_vector_2;
+CREATE TABLE test_fail_vector_2(id Float32, vector FixedArray(Float32, 3)) engine MergeTree primary key id SETTINGS index_granularity=1024, min_rows_to_build_vector_index=100;
+INSERT INTO test_fail_vector_2 SELECT number, [number, number, number] FROM numbers(2100);
+-- Unsupported parameter: meric=IP
+ALTER TABLE test_fail_vector_2 ADD VECTOR INDEX vindex vector TYPE IVFFLAT('metric=IP', 'ncentroids=5000');
+
+select sleep(2);
+
+select table, name, expr, status, latest_failed_part, substr(latest_fail_reason, position(latest_fail_reason,'ception') + 8) from system.vector_indices where database = currentDatabase() order by table;
+
+DROP TABLE test_fail_vector_2;
+DROP TABLE test_fail_vector;
+DROP TABLE test_success_vector;
-- 
2.32.1 (Apple Git-133)

